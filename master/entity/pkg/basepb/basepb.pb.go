// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: basepb/basepb.proto

package basepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DataType int32

const (
	DataType_Invalid DataType = 0
	// 8 bit interger
	DataType_Tinyint DataType = 1
	// 16 bit interger
	DataType_Smallint DataType = 2
	// 32 bit interger
	DataType_Int DataType = 3
	// 64 bit interger
	DataType_BigInt DataType = 4
	// 32 bit float
	DataType_Float DataType = 5
	// 64 bit float
	DataType_Double DataType = 6
	// string UTF-8 max size 64 KB
	DataType_Varchar DataType = 7
	// Blob max size 64 KB
	DataType_Binary    DataType = 8
	DataType_Date      DataType = 9
	DataType_TimeStamp DataType = 10
	DataType_Boolean   DataType = 11
	DataType_Decimal   DataType = 12
	DataType_Number    DataType = 13
	DataType_Char      DataType = 14
	DataType_NChar     DataType = 15
	DataType_Text      DataType = 16
	DataType_VarBinary DataType = 17
	DataType_Time      DataType = 18
	DataType_Xml       DataType = 19
	DataType_Json      DataType = 20
	DataType_Null      DataType = 30
)

var DataType_name = map[int32]string{
	0:  "Invalid",
	1:  "Tinyint",
	2:  "Smallint",
	3:  "Int",
	4:  "BigInt",
	5:  "Float",
	6:  "Double",
	7:  "Varchar",
	8:  "Binary",
	9:  "Date",
	10: "TimeStamp",
	11: "Boolean",
	12: "Decimal",
	13: "Number",
	14: "Char",
	15: "NChar",
	16: "Text",
	17: "VarBinary",
	18: "Time",
	19: "Xml",
	20: "Json",
	30: "Null",
}

var DataType_value = map[string]int32{
	"Invalid":   0,
	"Tinyint":   1,
	"Smallint":  2,
	"Int":       3,
	"BigInt":    4,
	"Float":     5,
	"Double":    6,
	"Varchar":   7,
	"Binary":    8,
	"Date":      9,
	"TimeStamp": 10,
	"Boolean":   11,
	"Decimal":   12,
	"Number":    13,
	"Char":      14,
	"NChar":     15,
	"Text":      16,
	"VarBinary": 17,
	"Time":      18,
	"Xml":       19,
	"Json":      20,
	"Null":      30,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{0}
}

type StoreType int32

const (
	StoreType_Store_Invalid StoreType = 0
	StoreType_Store_Hot     StoreType = 1
	StoreType_Store_Warm    StoreType = 2
	StoreType_Store_Mix     StoreType = 3
)

var StoreType_name = map[int32]string{
	0: "Store_Invalid",
	1: "Store_Hot",
	2: "Store_Warm",
	3: "Store_Mix",
}

var StoreType_value = map[string]int32{
	"Store_Invalid": 0,
	"Store_Hot":     1,
	"Store_Warm":    2,
	"Store_Mix":     3,
}

func (x StoreType) String() string {
	return proto.EnumName(StoreType_name, int32(x))
}

func (StoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{1}
}

type RangeType int32

const (
	RangeType_RNG_Invalid RangeType = 0
	RangeType_RNG_Index   RangeType = 1
	RangeType_RNG_Data    RangeType = 2
)

var RangeType_name = map[int32]string{
	0: "RNG_Invalid",
	1: "RNG_Index",
	2: "RNG_Data",
}

var RangeType_value = map[string]int32{
	"RNG_Invalid": 0,
	"RNG_Index":   1,
	"RNG_Data":    2,
}

func (x RangeType) String() string {
	return proto.EnumName(RangeType_name, int32(x))
}

func (RangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{2}
}

type ColumnType int32

const (
	ColumnType_COL_Common ColumnType = 0
	ColumnType_COL_System ColumnType = 1
)

var ColumnType_name = map[int32]string{
	0: "COL_Common",
	1: "COL_System",
}

var ColumnType_value = map[string]int32{
	"COL_Common": 0,
	"COL_System": 1,
}

func (x ColumnType) String() string {
	return proto.EnumName(ColumnType_name, int32(x))
}

func (ColumnType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{3}
}

// 1. Under any conditions, ms should initialize the new and old ds nodes into an Initial state after they are added to the cluster, except for the nodes that have been Logout.
// after ds self-inspection is completed, the data read-write service is officially launched via NodeLogin report
// Logout nodeï¼Œneed to Initial by person
type NodeState int32

const (
	NodeState_N_Invalid   NodeState = 0
	NodeState_N_Online    NodeState = 1
	NodeState_N_Offline   NodeState = 2
	NodeState_N_Updating  NodeState = 3
	NodeState_N_Offlining NodeState = 4
)

var NodeState_name = map[int32]string{
	0: "N_Invalid",
	1: "N_Online",
	2: "N_Offline",
	3: "N_Updating",
	4: "N_Offlining",
}

var NodeState_value = map[string]int32{
	"N_Invalid":   0,
	"N_Online":    1,
	"N_Offline":   2,
	"N_Updating":  3,
	"N_Offlining": 4,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}

func (NodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{4}
}

type RangePeerState int32

const (
	RangePeerState_RPS_Invalid  RangePeerState = 0
	RangePeerState_RPS_NoLeader RangePeerState = 1
	RangePeerState_RPS_Follower RangePeerState = 2
	RangePeerState_RPS_Leader   RangePeerState = 3
)

var RangePeerState_name = map[int32]string{
	0: "RPS_Invalid",
	1: "RPS_NoLeader",
	2: "RPS_Follower",
	3: "RPS_Leader",
}

var RangePeerState_value = map[string]int32{
	"RPS_Invalid":  0,
	"RPS_NoLeader": 1,
	"RPS_Follower": 2,
	"RPS_Leader":   3,
}

func (x RangePeerState) String() string {
	return proto.EnumName(RangePeerState_name, int32(x))
}

func (RangePeerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{5}
}

type PeerType int32

const (
	PeerType_PeerType_Invalid PeerType = 0
	PeerType_PeerType_Normal  PeerType = 1
	PeerType_PeerType_Learner PeerType = 2
)

var PeerType_name = map[int32]string{
	0: "PeerType_Invalid",
	1: "PeerType_Normal",
	2: "PeerType_Learner",
}

var PeerType_value = map[string]int32{
	"PeerType_Invalid": 0,
	"PeerType_Normal":  1,
	"PeerType_Learner": 2,
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}

func (PeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{6}
}

type TableStatus int32

const (
	TableStatus_TableInvalid TableStatus = 0
	TableStatus_TableRunning TableStatus = 1
)

var TableStatus_name = map[int32]string{
	0: "TableInvalid",
	1: "TableRunning",
}

var TableStatus_value = map[string]int32{
	"TableInvalid": 0,
	"TableRunning": 1,
}

func (x TableStatus) String() string {
	return proto.EnumName(TableStatus_name, int32(x))
}

func (TableStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{7}
}

type IndexType int32

const (
	IndexType_I_Invalid IndexType = 0
	IndexType_I_Btree   IndexType = 1
	IndexType_I_Hash    IndexType = 2
)

var IndexType_name = map[int32]string{
	0: "I_Invalid",
	1: "I_Btree",
	2: "I_Hash",
}

var IndexType_value = map[string]int32{
	"I_Invalid": 0,
	"I_Btree":   1,
	"I_Hash":    2,
}

func (x IndexType) String() string {
	return proto.EnumName(IndexType_name, int32(x))
}

func (IndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{8}
}

type EventType int32

const (
	EventType_Event_Type_Invalid EventType = 0
	EventType_Event_Type_PUT     EventType = 1
	EventType_Event_Type_DELETE  EventType = 2
)

var EventType_name = map[int32]string{
	0: "Event_Type_Invalid",
	1: "Event_Type_PUT",
	2: "Event_Type_DELETE",
}

var EventType_value = map[string]int32{
	"Event_Type_Invalid": 0,
	"Event_Type_PUT":     1,
	"Event_Type_DELETE":  2,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{9}
}

type WatcherType int32

const (
	WatcherType_Watcher_Type_Invalid  WatcherType = 0
	WatcherType_Watcher_Type_Node     WatcherType = 1
	WatcherType_Watcher_Type_Database WatcherType = 2
	WatcherType_Watcher_Type_Table    WatcherType = 3
	WatcherType_Watcher_Type_Range    WatcherType = 4
)

var WatcherType_name = map[int32]string{
	0: "Watcher_Type_Invalid",
	1: "Watcher_Type_Node",
	2: "Watcher_Type_Database",
	3: "Watcher_Type_Table",
	4: "Watcher_Type_Range",
}

var WatcherType_value = map[string]int32{
	"Watcher_Type_Invalid":  0,
	"Watcher_Type_Node":     1,
	"Watcher_Type_Database": 2,
	"Watcher_Type_Table":    3,
	"Watcher_Type_Range":    4,
}

func (x WatcherType) String() string {
	return proto.EnumName(WatcherType_name, int32(x))
}

func (WatcherType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{10}
}

type RangePeer struct {
	RangeId              uint64         `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	PeerId               uint64         `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	State                RangePeerState `protobuf:"varint,3,opt,name=state,proto3,enum=basepb.RangePeerState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RangePeer) Reset()         { *m = RangePeer{} }
func (m *RangePeer) String() string { return proto.CompactTextString(m) }
func (*RangePeer) ProtoMessage()    {}
func (*RangePeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{0}
}
func (m *RangePeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangePeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangePeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangePeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangePeer.Merge(m, src)
}
func (m *RangePeer) XXX_Size() int {
	return m.Size()
}
func (m *RangePeer) XXX_DiscardUnknown() {
	xxx_messageInfo_RangePeer.DiscardUnknown(m)
}

var xxx_messageInfo_RangePeer proto.InternalMessageInfo

func (m *RangePeer) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *RangePeer) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *RangePeer) GetState() RangePeerState {
	if m != nil {
		return m.State
	}
	return RangePeerState_RPS_Invalid
}

type Node struct {
	Id                   uint64       `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Ip                   string       `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	ServerPort           uint32       `protobuf:"varint,3,opt,name=server_port,json=serverPort,proto3" json:"server_port,omitempty"`
	RaftPort             uint32       `protobuf:"varint,4,opt,name=raft_port,json=raftPort,proto3" json:"raft_port,omitempty"`
	AdminPort            uint32       `protobuf:"varint,5,opt,name=admin_port,json=adminPort,proto3" json:"admin_port,omitempty"`
	State                NodeState    `protobuf:"varint,6,opt,name=state,proto3,enum=basepb.NodeState" json:"state,omitempty"`
	Version              int64        `protobuf:"varint,7,opt,name=version,proto3" json:"version,omitempty"`
	RangePeers           []*RangePeer `protobuf:"bytes,8,rep,name=range_peers,json=rangePeers,proto3" json:"range_peers,omitempty"`
	LastUpdateTime       int64        `protobuf:"varint,9,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	Type                 StoreType    `protobuf:"varint,10,opt,name=type,proto3,enum=basepb.StoreType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Node) GetServerPort() uint32 {
	if m != nil {
		return m.ServerPort
	}
	return 0
}

func (m *Node) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Node) GetAdminPort() uint32 {
	if m != nil {
		return m.AdminPort
	}
	return 0
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_N_Invalid
}

func (m *Node) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Node) GetRangePeers() []*RangePeer {
	if m != nil {
		return m.RangePeers
	}
	return nil
}

func (m *Node) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *Node) GetType() StoreType {
	if m != nil {
		return m.Type
	}
	return StoreType_Store_Invalid
}

type Peer struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Type                 PeerType `protobuf:"varint,3,opt,name=type,proto3,enum=basepb.PeerType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{2}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Peer) GetType() PeerType {
	if m != nil {
		return m.Type
	}
	return PeerType_PeerType_Invalid
}

type PeerStatus struct {
	Peer                 *Peer    `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Commit               uint64   `protobuf:"varint,3,opt,name=commit,proto3" json:"commit,omitempty"`
	DownSeconds          uint64   `protobuf:"varint,4,opt,name=down_seconds,json=downSeconds,proto3" json:"down_seconds,omitempty"`
	Snapshotting         bool     `protobuf:"varint,5,opt,name=snapshotting,proto3" json:"snapshotting,omitempty"`
	Applied              uint64   `protobuf:"varint,6,opt,name=applied,proto3" json:"applied,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerStatus) Reset()         { *m = PeerStatus{} }
func (m *PeerStatus) String() string { return proto.CompactTextString(m) }
func (*PeerStatus) ProtoMessage()    {}
func (*PeerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{3}
}
func (m *PeerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStatus.Merge(m, src)
}
func (m *PeerStatus) XXX_Size() int {
	return m.Size()
}
func (m *PeerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStatus proto.InternalMessageInfo

func (m *PeerStatus) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *PeerStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PeerStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *PeerStatus) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

func (m *PeerStatus) GetSnapshotting() bool {
	if m != nil {
		return m.Snapshotting
	}
	return false
}

func (m *PeerStatus) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

type Replica struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Peer                 *Peer    `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	StartKey             []byte   `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte   `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{4}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Replica) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Replica) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Replica) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

// RegionEpoch is from tidb, and is and is licensed under the Apache Public License v2.
// Source code can be found here: https://github.com/pingcap/pd
type RangeEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Range version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RangeEpoch) Reset()         { *m = RangeEpoch{} }
func (m *RangeEpoch) String() string { return proto.CompactTextString(m) }
func (*RangeEpoch) ProtoMessage()    {}
func (*RangeEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{5}
}
func (m *RangeEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeEpoch.Merge(m, src)
}
func (m *RangeEpoch) XXX_Size() int {
	return m.Size()
}
func (m *RangeEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_RangeEpoch proto.InternalMessageInfo

func (m *RangeEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *RangeEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Range struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Range key range [start_key, end_key).
	// key by: prefix + table_id + real key
	StartKey   []byte      `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey     []byte      `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	RangeEpoch *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch,proto3" json:"range_epoch,omitempty"`
	//default first peer is leader
	Peers                []*Peer   `protobuf:"bytes,5,rep,name=peers,proto3" json:"peers,omitempty"`
	DbId                 uint64    `protobuf:"varint,6,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId              uint64    `protobuf:"varint,7,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	PrimaryKeys          []*Column `protobuf:"bytes,8,rep,name=primary_keys,json=primaryKeys,proto3" json:"primary_keys,omitempty"`
	Leader               uint64    `protobuf:"varint,9,opt,name=leader,proto3" json:"leader,omitempty"`
	RangeType            RangeType `protobuf:"varint,10,opt,name=range_type,json=rangeType,proto3,enum=basepb.RangeType" json:"range_type,omitempty"`
	StoreType            StoreType `protobuf:"varint,11,opt,name=store_type,json=storeType,proto3,enum=basepb.StoreType" json:"store_type,omitempty"`
	Term                 uint64    `protobuf:"varint,12,opt,name=term,proto3" json:"term,omitempty"`
	ParentRangeId        uint64    `protobuf:"varint,13,opt,name=parent_range_id,json=parentRangeId,proto3" json:"parent_range_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{6}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Range) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Range) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Range) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Range) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Range) GetPrimaryKeys() []*Column {
	if m != nil {
		return m.PrimaryKeys
	}
	return nil
}

func (m *Range) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *Range) GetRangeType() RangeType {
	if m != nil {
		return m.RangeType
	}
	return RangeType_RNG_Invalid
}

func (m *Range) GetStoreType() StoreType {
	if m != nil {
		return m.StoreType
	}
	return StoreType_Store_Invalid
}

func (m *Range) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Range) GetParentRangeId() uint64 {
	if m != nil {
		return m.ParentRangeId
	}
	return 0
}

type Leader struct {
	RangeId              uint64   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId               uint64   `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr             string   `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Leader) Reset()         { *m = Leader{} }
func (m *Leader) String() string { return proto.CompactTextString(m) }
func (*Leader) ProtoMessage()    {}
func (*Leader) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{7}
}
func (m *Leader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Leader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Leader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Leader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Leader.Merge(m, src)
}
func (m *Leader) XXX_Size() int {
	return m.Size()
}
func (m *Leader) XXX_DiscardUnknown() {
	xxx_messageInfo_Leader.DiscardUnknown(m)
}

var xxx_messageInfo_Leader proto.InternalMessageInfo

func (m *Leader) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Leader) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Leader) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

type DataBase struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id                   uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Version              uint64   `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	CreateTime           int64    `protobuf:"varint,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataBase) Reset()         { *m = DataBase{} }
func (m *DataBase) String() string { return proto.CompactTextString(m) }
func (*DataBase) ProtoMessage()    {}
func (*DataBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{8}
}
func (m *DataBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataBase.Merge(m, src)
}
func (m *DataBase) XXX_Size() int {
	return m.Size()
}
func (m *DataBase) XXX_DiscardUnknown() {
	xxx_messageInfo_DataBase.DiscardUnknown(m)
}

var xxx_messageInfo_DataBase proto.InternalMessageInfo

func (m *DataBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataBase) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DataBase) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DataBase) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Column struct {
	// max size 128 bytes
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// colID
	Id       uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DataType DataType `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=basepb.DataType" json:"data_type,omitempty"`
	Unsigned bool     `protobuf:"varint,4,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	// for float and varchar type
	Scale int32 `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	// for float
	Precision  int32  `protobuf:"varint,6,opt,name=precision,proto3" json:"precision,omitempty"`
	Nullable   bool   `protobuf:"varint,7,opt,name=nullable,proto3" json:"nullable,omitempty"`
	PrimaryKey uint64 `protobuf:"varint,8,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// col order type
	Ordinal int32 `protobuf:"varint,9,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	// index type , binary can not index
	Index                bool       `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	DefaultValue         []byte     `protobuf:"bytes,11,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Properties           string     `protobuf:"bytes,12,opt,name=properties,proto3" json:"properties,omitempty"`
	AutoIncrement        bool       `protobuf:"varint,13,opt,name=auto_increment,json=autoIncrement,proto3" json:"auto_increment,omitempty"`
	Unique               bool       `protobuf:"varint,14,opt,name=unique,proto3" json:"unique,omitempty"`
	ColType              ColumnType `protobuf:"varint,15,opt,name=col_type,json=colType,proto3,enum=basepb.ColumnType" json:"col_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{9}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

func (m *Column) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Column) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Column) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_Invalid
}

func (m *Column) GetUnsigned() bool {
	if m != nil {
		return m.Unsigned
	}
	return false
}

func (m *Column) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Column) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Column) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Column) GetPrimaryKey() uint64 {
	if m != nil {
		return m.PrimaryKey
	}
	return 0
}

func (m *Column) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *Column) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *Column) GetDefaultValue() []byte {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *Column) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Column) GetAutoIncrement() bool {
	if m != nil {
		return m.AutoIncrement
	}
	return false
}

func (m *Column) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *Column) GetColType() ColumnType {
	if m != nil {
		return m.ColType
	}
	return ColumnType_COL_Common
}

type Primary struct {
	ColumnName           string   `protobuf:"bytes,1,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	Next                 *Primary `protobuf:"bytes,2,opt,name=next,proto3" json:"next,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Primary) Reset()         { *m = Primary{} }
func (m *Primary) String() string { return proto.CompactTextString(m) }
func (*Primary) ProtoMessage()    {}
func (*Primary) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{10}
}
func (m *Primary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Primary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Primary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Primary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Primary.Merge(m, src)
}
func (m *Primary) XXX_Size() int {
	return m.Size()
}
func (m *Primary) XXX_DiscardUnknown() {
	xxx_messageInfo_Primary.DiscardUnknown(m)
}

var xxx_messageInfo_Primary proto.InternalMessageInfo

func (m *Primary) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *Primary) GetNext() *Primary {
	if m != nil {
		return m.Next
	}
	return nil
}

type TableEpoch struct {
	// Conf change version, auto increment when add or remove column
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Route version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableEpoch) Reset()         { *m = TableEpoch{} }
func (m *TableEpoch) String() string { return proto.CompactTextString(m) }
func (*TableEpoch) ProtoMessage()    {}
func (*TableEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{11}
}
func (m *TableEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableEpoch.Merge(m, src)
}
func (m *TableEpoch) XXX_Size() int {
	return m.Size()
}
func (m *TableEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_TableEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_TableEpoch proto.InternalMessageInfo

func (m *TableEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *TableEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Index struct {
	Id                   uint64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ColNames             []string  `protobuf:"bytes,3,rep,name=col_names,json=colNames,proto3" json:"col_names,omitempty"`
	Unique               bool      `protobuf:"varint,4,opt,name=unique,proto3" json:"unique,omitempty"`
	Comment              string    `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	IndexType            IndexType `protobuf:"varint,6,opt,name=index_type,json=indexType,proto3,enum=basepb.IndexType" json:"index_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Index) Reset()         { *m = Index{} }
func (m *Index) String() string { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()    {}
func (*Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{12}
}
func (m *Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Index.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Index.Merge(m, src)
}
func (m *Index) XXX_Size() int {
	return m.Size()
}
func (m *Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Index proto.InternalMessageInfo

func (m *Index) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Index) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Index) GetColNames() []string {
	if m != nil {
		return m.ColNames
	}
	return nil
}

func (m *Index) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *Index) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Index) GetIndexType() IndexType {
	if m != nil {
		return m.IndexType
	}
	return IndexType_I_Invalid
}

type Table struct {
	Name       string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DbName     string      `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	DbId       uint64      `protobuf:"varint,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Id         uint64      `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	Properties string      `protobuf:"bytes,5,opt,name=properties,proto3" json:"properties,omitempty"`
	Columns    []*Column   `protobuf:"bytes,6,rep,name=columns,proto3" json:"columns,omitempty"`
	Epoch      *TableEpoch `protobuf:"bytes,7,opt,name=epoch,proto3" json:"epoch,omitempty"`
	CreateTime int64       `protobuf:"varint,8,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// table status
	Status TableStatus `protobuf:"varint,9,opt,name=status,proto3,enum=basepb.TableStatus" json:"status,omitempty"`
	// table expand area
	// now when status is TableDelete, expand is the delete flag time
	Expand  []byte   `protobuf:"bytes,10,opt,name=expand,proto3" json:"expand,omitempty"`
	Indexes []*Index `protobuf:"bytes,11,rep,name=indexes,proto3" json:"indexes,omitempty"`
	//3 type of tableï¼Œwarm hot mix
	Type       StoreType `protobuf:"varint,12,opt,name=type,proto3,enum=basepb.StoreType" json:"type,omitempty"`
	ReplicaNum uint64    `protobuf:"varint,13,opt,name=replica_num,json=replicaNum,proto3" json:"replica_num,omitempty"`
	// how many date range live default 2
	DataRangeNum         uint64   `protobuf:"varint,14,opt,name=data_range_num,json=dataRangeNum,proto3" json:"data_range_num,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{13}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

func (m *Table) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Table) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Table) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Table) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Table) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Table) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *Table) GetEpoch() *TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *Table) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Table) GetStatus() TableStatus {
	if m != nil {
		return m.Status
	}
	return TableStatus_TableInvalid
}

func (m *Table) GetExpand() []byte {
	if m != nil {
		return m.Expand
	}
	return nil
}

func (m *Table) GetIndexes() []*Index {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *Table) GetType() StoreType {
	if m != nil {
		return m.Type
	}
	return StoreType_Store_Invalid
}

func (m *Table) GetReplicaNum() uint64 {
	if m != nil {
		return m.ReplicaNum
	}
	return 0
}

func (m *Table) GetDataRangeNum() uint64 {
	if m != nil {
		return m.DataRangeNum
	}
	return 0
}

//node event has nodeID
//db event has dbID
//table event has dbID,tableID
//range event has tableID, rangeID
type WatcherEvent struct {
	WatcherType          WatcherType `protobuf:"varint,1,opt,name=watcher_type,json=watcherType,proto3,enum=basepb.WatcherType" json:"watcher_type,omitempty"`
	EventType            EventType   `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3,enum=basepb.EventType" json:"event_type,omitempty"`
	NodeId               uint64      `protobuf:"varint,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	DbId                 uint64      `protobuf:"varint,4,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId              uint64      `protobuf:"varint,5,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	RangeId              uint64      `protobuf:"varint,6,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Value                []byte      `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
	Version              uint64      `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WatcherEvent) Reset()         { *m = WatcherEvent{} }
func (m *WatcherEvent) String() string { return proto.CompactTextString(m) }
func (*WatcherEvent) ProtoMessage()    {}
func (*WatcherEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_722048aedd2e50a3, []int{14}
}
func (m *WatcherEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherEvent.Merge(m, src)
}
func (m *WatcherEvent) XXX_Size() int {
	return m.Size()
}
func (m *WatcherEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherEvent.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherEvent proto.InternalMessageInfo

func (m *WatcherEvent) GetWatcherType() WatcherType {
	if m != nil {
		return m.WatcherType
	}
	return WatcherType_Watcher_Type_Invalid
}

func (m *WatcherEvent) GetEventType() EventType {
	if m != nil {
		return m.EventType
	}
	return EventType_Event_Type_Invalid
}

func (m *WatcherEvent) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *WatcherEvent) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *WatcherEvent) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *WatcherEvent) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *WatcherEvent) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WatcherEvent) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("basepb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("basepb.StoreType", StoreType_name, StoreType_value)
	proto.RegisterEnum("basepb.RangeType", RangeType_name, RangeType_value)
	proto.RegisterEnum("basepb.ColumnType", ColumnType_name, ColumnType_value)
	proto.RegisterEnum("basepb.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("basepb.RangePeerState", RangePeerState_name, RangePeerState_value)
	proto.RegisterEnum("basepb.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("basepb.TableStatus", TableStatus_name, TableStatus_value)
	proto.RegisterEnum("basepb.IndexType", IndexType_name, IndexType_value)
	proto.RegisterEnum("basepb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("basepb.WatcherType", WatcherType_name, WatcherType_value)
	proto.RegisterType((*RangePeer)(nil), "basepb.RangePeer")
	proto.RegisterType((*Node)(nil), "basepb.Node")
	proto.RegisterType((*Peer)(nil), "basepb.Peer")
	proto.RegisterType((*PeerStatus)(nil), "basepb.PeerStatus")
	proto.RegisterType((*Replica)(nil), "basepb.Replica")
	proto.RegisterType((*RangeEpoch)(nil), "basepb.RangeEpoch")
	proto.RegisterType((*Range)(nil), "basepb.Range")
	proto.RegisterType((*Leader)(nil), "basepb.Leader")
	proto.RegisterType((*DataBase)(nil), "basepb.DataBase")
	proto.RegisterType((*Column)(nil), "basepb.Column")
	proto.RegisterType((*Primary)(nil), "basepb.Primary")
	proto.RegisterType((*TableEpoch)(nil), "basepb.TableEpoch")
	proto.RegisterType((*Index)(nil), "basepb.Index")
	proto.RegisterType((*Table)(nil), "basepb.Table")
	proto.RegisterType((*WatcherEvent)(nil), "basepb.WatcherEvent")
}

func init() { proto.RegisterFile("basepb/basepb.proto", fileDescriptor_722048aedd2e50a3) }

var fileDescriptor_722048aedd2e50a3 = []byte{
	// 1845 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0x8e, 0x28, 0x4a, 0x22, 0x8f, 0x7e, 0x3c, 0x1e, 0x3b, 0x89, 0x76, 0xd3, 0xba, 0xae, 0x76,
	0xb7, 0x6b, 0xa8, 0x9b, 0xa4, 0xeb, 0x00, 0x05, 0x7a, 0xb9, 0x8e, 0xbd, 0x5d, 0x35, 0xae, 0x62,
	0xd0, 0x4e, 0x76, 0x7b, 0x45, 0x8c, 0xc4, 0xb1, 0x4d, 0x94, 0x1c, 0xb2, 0x43, 0xd2, 0xb1, 0x80,
	0xbe, 0x40, 0xd1, 0x3e, 0x40, 0x1f, 0xa2, 0xaf, 0xd0, 0x8b, 0xde, 0x15, 0xdd, 0x9b, 0x3e, 0x42,
	0x91, 0xbe, 0x48, 0x71, 0xce, 0x90, 0x32, 0xe9, 0x38, 0x41, 0x81, 0xbd, 0xf2, 0x7c, 0xe7, 0x0c,
	0xcf, 0x9c, 0x9f, 0x6f, 0x3e, 0x52, 0x86, 0xad, 0x85, 0xc8, 0x64, 0xba, 0x78, 0x6a, 0xfe, 0x3c,
	0x49, 0x75, 0x92, 0x27, 0xbc, 0x6b, 0xd0, 0xc7, 0x8f, 0x2f, 0xc2, 0xfc, 0xb2, 0x58, 0x3c, 0x59,
	0x26, 0xf1, 0xd3, 0x8b, 0xe4, 0x22, 0x79, 0x4a, 0xee, 0x45, 0x71, 0x4e, 0x88, 0x00, 0xad, 0xcc,
	0x63, 0x93, 0x18, 0x5c, 0x4f, 0xa8, 0x0b, 0x79, 0x22, 0xa5, 0xe6, 0x1f, 0x81, 0xa3, 0x11, 0xf8,
	0x61, 0x30, 0x6e, 0xed, 0xb6, 0xf6, 0x6c, 0xaf, 0x47, 0x78, 0x16, 0xf0, 0x87, 0xd0, 0x4b, 0xa5,
	0xd4, 0xe8, 0xb1, 0xc8, 0xd3, 0x45, 0x38, 0x0b, 0xf8, 0x17, 0xd0, 0xc9, 0x72, 0x91, 0xcb, 0x71,
	0x7b, 0xb7, 0xb5, 0x37, 0xda, 0x7f, 0xf0, 0xa4, 0xcc, 0x6a, 0x1d, 0xf5, 0x14, 0xbd, 0x9e, 0xd9,
	0x34, 0xf9, 0xde, 0x02, 0x7b, 0x9e, 0x04, 0x92, 0x8f, 0xc0, 0x5a, 0x1f, 0x62, 0x85, 0x01, 0xe1,
	0x94, 0x42, 0xbb, 0x9e, 0x15, 0xa6, 0xfc, 0x27, 0xd0, 0xcf, 0xa4, 0xbe, 0x92, 0xda, 0x4f, 0x13,
	0x9d, 0x53, 0xf0, 0xa1, 0x07, 0xc6, 0x74, 0x92, 0xe8, 0x9c, 0x3f, 0x02, 0x57, 0x8b, 0xf3, 0xdc,
	0xb8, 0x6d, 0x72, 0x3b, 0x68, 0x20, 0xe7, 0x8f, 0x01, 0x44, 0x10, 0x87, 0xca, 0x78, 0x3b, 0xe4,
	0x75, 0xc9, 0x42, 0xee, 0xcf, 0xab, 0x9c, 0xbb, 0x94, 0xf3, 0x66, 0x95, 0x33, 0x66, 0x56, 0x4f,
	0x97, 0x8f, 0xa1, 0x77, 0x25, 0x75, 0x16, 0x26, 0x6a, 0xdc, 0xdb, 0x6d, 0xed, 0xb5, 0xbd, 0x0a,
	0xf2, 0x7d, 0xe8, 0x9b, 0x56, 0x61, 0x1b, 0xb2, 0xb1, 0xb3, 0xdb, 0xde, 0xeb, 0xdf, 0x04, 0x5a,
	0x17, 0xef, 0x81, 0xae, 0x96, 0x19, 0xdf, 0x03, 0x16, 0x89, 0x2c, 0xf7, 0x8b, 0x34, 0x10, 0xb9,
	0xf4, 0xf3, 0x30, 0x96, 0x63, 0x97, 0xc2, 0x8e, 0xd0, 0xfe, 0x8a, 0xcc, 0x67, 0x61, 0x2c, 0xf9,
	0x67, 0x60, 0xe7, 0xab, 0x54, 0x8e, 0xa1, 0x99, 0xdf, 0x69, 0x9e, 0x68, 0x79, 0xb6, 0x4a, 0xa5,
	0x47, 0xee, 0xc9, 0x2b, 0xb0, 0x69, 0x6e, 0xb7, 0x9b, 0xf9, 0x10, 0x7a, 0x2a, 0x09, 0x64, 0x6d,
	0x58, 0x08, 0x67, 0x01, 0xff, 0xb4, 0x8c, 0x6b, 0x66, 0xc5, 0xaa, 0xb8, 0x18, 0xa4, 0x16, 0xf6,
	0xef, 0x2d, 0x80, 0x6a, 0x72, 0x45, 0xc6, 0x77, 0xc1, 0xc6, 0x22, 0x29, 0x7e, 0x7f, 0x7f, 0x50,
	0x7f, 0xc8, 0x23, 0x0f, 0xdf, 0x86, 0x4e, 0xa8, 0x02, 0x79, 0x5d, 0x9e, 0x66, 0x00, 0x7f, 0x00,
	0xdd, 0x65, 0x12, 0xc7, 0xa1, 0x99, 0x9e, 0xed, 0x95, 0x88, 0xff, 0x14, 0x06, 0x41, 0xf2, 0x46,
	0xf9, 0x99, 0x5c, 0x26, 0x2a, 0xc8, 0x68, 0x78, 0xb6, 0xd7, 0x47, 0xdb, 0xa9, 0x31, 0xf1, 0x09,
	0x0c, 0x32, 0x25, 0xd2, 0xec, 0x32, 0xc9, 0xf3, 0x50, 0x5d, 0xd0, 0x04, 0x1d, 0xaf, 0x61, 0xc3,
	0xd9, 0x88, 0x34, 0x8d, 0x42, 0x19, 0xd0, 0x18, 0x6d, 0xaf, 0x82, 0x93, 0x3f, 0x42, 0xcf, 0x93,
	0x69, 0x14, 0x2e, 0xc5, 0x87, 0x18, 0x5d, 0x95, 0x65, 0xbd, 0xb7, 0xac, 0x47, 0xe0, 0x66, 0xb9,
	0xd0, 0xb9, 0xff, 0x7b, 0xb9, 0xa2, 0x1a, 0x06, 0x9e, 0x43, 0x86, 0x17, 0x72, 0x85, 0x3d, 0x96,
	0x2a, 0x20, 0x97, 0x4d, 0xae, 0xae, 0x54, 0xc1, 0x0b, 0xb9, 0x9a, 0x7c, 0x05, 0x40, 0xe3, 0x3f,
	0x4a, 0x93, 0xe5, 0x25, 0x26, 0xb0, 0x4c, 0xd4, 0xb9, 0x7f, 0x55, 0x36, 0xd0, 0xf6, 0x7a, 0x88,
	0x5f, 0x4b, 0x5d, 0x27, 0x97, 0xe9, 0x5b, 0x05, 0x27, 0xff, 0x68, 0x43, 0x87, 0x62, 0xbc, 0x33,
	0xd9, 0x46, 0x4a, 0xd6, 0xfb, 0x53, 0x6a, 0xd7, 0x53, 0xe2, 0xcf, 0x2a, 0xb2, 0x4a, 0xcc, 0x89,
	0xf2, 0xed, 0xef, 0xf3, 0x06, 0x59, 0x29, 0xdb, 0x92, 0xad, 0x26, 0xf3, 0x09, 0x74, 0x0c, 0xb7,
	0x3b, 0xc4, 0xed, 0x66, 0x83, 0x8c, 0x8b, 0x6f, 0x41, 0x27, 0x58, 0x60, 0x6f, 0xcd, 0x04, 0xec,
	0x60, 0x31, 0x0b, 0xb0, 0xe4, 0x5c, 0x2c, 0x22, 0xea, 0x79, 0xcf, 0x14, 0x46, 0x78, 0x16, 0xf0,
	0x2f, 0x61, 0x90, 0xea, 0x30, 0x16, 0x7a, 0x85, 0x59, 0x56, 0xd7, 0x66, 0x54, 0x85, 0x7e, 0x9e,
	0x44, 0x45, 0xac, 0xbc, 0x7e, 0xb9, 0xe7, 0x85, 0x5c, 0x65, 0xc8, 0xa2, 0x48, 0x8a, 0x40, 0x6a,
	0xba, 0x2a, 0xb6, 0x57, 0x22, 0xfe, 0x0b, 0x30, 0xc9, 0xfa, 0x77, 0x5d, 0x14, 0x2a, 0x89, 0x18,
	0xed, 0xea, 0x6a, 0x89, 0x4f, 0x64, 0x78, 0x81, 0xcc, 0x13, 0xfd, 0xf7, 0x5d, 0x2d, 0x37, 0xab,
	0x96, 0x9c, 0x83, 0x9d, 0x4b, 0x1d, 0x8f, 0x07, 0xa6, 0x3a, 0x5c, 0xf3, 0x9f, 0xc1, 0x46, 0x2a,
	0xb4, 0x54, 0xb9, 0xbf, 0x26, 0xd6, 0x90, 0xdc, 0x43, 0x63, 0xf6, 0x0c, 0xbd, 0x26, 0xbf, 0x83,
	0xee, 0xb1, 0xc9, 0xf4, 0xc3, 0xaa, 0x7a, 0xf7, 0x45, 0x7d, 0x04, 0x2e, 0x39, 0x44, 0x10, 0x68,
	0x1a, 0xa6, 0xeb, 0x39, 0x68, 0xf8, 0x2a, 0x08, 0xf4, 0x24, 0x04, 0xe7, 0x50, 0xe4, 0xe2, 0x40,
	0x64, 0x94, 0xa2, 0x12, 0xb1, 0xa4, 0xc0, 0xae, 0x47, 0xeb, 0x92, 0x34, 0xd6, 0x9a, 0x34, 0x35,
	0xa2, 0xb5, 0x1b, 0x44, 0x43, 0x95, 0x5d, 0x6a, 0xb9, 0x16, 0x23, 0x9b, 0xc4, 0x08, 0x8c, 0x09,
	0x85, 0x68, 0xf2, 0x7d, 0x1b, 0xba, 0x66, 0x2a, 0xff, 0xd7, 0x49, 0x8f, 0xc1, 0x0d, 0x44, 0x2e,
	0xfc, 0xbb, 0x44, 0x06, 0x53, 0xa6, 0x06, 0x3b, 0x41, 0xb9, 0xe2, 0x1f, 0x83, 0x53, 0xa8, 0x2c,
	0xbc, 0x50, 0x32, 0xa0, 0xb3, 0x1d, 0x6f, 0x8d, 0x51, 0x53, 0xb2, 0xa5, 0x88, 0x24, 0xdd, 0xfd,
	0x8e, 0x67, 0x00, 0xff, 0x11, 0xb8, 0xa9, 0x96, 0xcb, 0x90, 0x8a, 0xe9, 0x92, 0xe7, 0xc6, 0x80,
	0xf1, 0x54, 0x11, 0x45, 0x48, 0x36, 0x62, 0x9e, 0xe3, 0xad, 0x31, 0x96, 0x5a, 0xa3, 0xde, 0xd8,
	0xa1, 0x9c, 0xe1, 0x86, 0x69, 0xd8, 0xa5, 0x44, 0x07, 0xa1, 0x12, 0x11, 0x31, 0xad, 0xe3, 0x55,
	0xf0, 0x46, 0xde, 0x80, 0x62, 0x96, 0xf2, 0xf6, 0x09, 0x0c, 0x03, 0x79, 0x2e, 0x8a, 0x28, 0xf7,
	0xaf, 0x44, 0x54, 0x18, 0x46, 0x0d, 0xbc, 0x41, 0x69, 0x7c, 0x8d, 0x36, 0xbe, 0x03, 0x90, 0xea,
	0x24, 0x95, 0x3a, 0x0f, 0x65, 0x46, 0x3c, 0x72, 0xbd, 0x9a, 0x85, 0x7f, 0x06, 0x23, 0x51, 0xe4,
	0x89, 0x1f, 0xaa, 0xa5, 0x96, 0xb1, 0x54, 0x39, 0x91, 0xc9, 0xf1, 0x86, 0x68, 0x9d, 0x55, 0x46,
	0xbc, 0x04, 0x85, 0x0a, 0xff, 0x50, 0xc8, 0xf1, 0x88, 0xdc, 0x25, 0xe2, 0x8f, 0x51, 0x5d, 0x22,
	0xd3, 0xee, 0x0d, 0x6a, 0x37, 0x6f, 0xde, 0x25, 0x6a, 0x78, 0x6f, 0x99, 0x44, 0xb8, 0x98, 0xbc,
	0x84, 0xde, 0x89, 0x29, 0x98, 0x26, 0x4f, 0x3b, 0xfc, 0xda, 0x50, 0xc1, 0x98, 0xe6, 0x38, 0xda,
	0x4f, 0xc0, 0x56, 0xf2, 0x3a, 0x2f, 0xe5, 0x71, 0x63, 0x7d, 0xfb, 0xcd, 0xf3, 0x1e, 0x39, 0x51,
	0xeb, 0xce, 0xb0, 0xbb, 0x3f, 0x40, 0xeb, 0xfe, 0xd6, 0x82, 0xce, 0x8c, 0x1a, 0x7a, 0x5b, 0xeb,
	0x2a, 0xc2, 0x59, 0x35, 0xc2, 0x3d, 0x02, 0x17, 0x0b, 0xc6, 0x75, 0x36, 0x6e, 0xef, 0xb6, 0xf1,
	0x5e, 0x2c, 0x93, 0x08, 0x33, 0xce, 0x6a, 0x5d, 0xb2, 0x1b, 0x5d, 0x1a, 0x43, 0x0f, 0x5f, 0x3d,
	0xd8, 0xdd, 0x0e, 0xc5, 0xaa, 0x20, 0x4a, 0x02, 0x0d, 0xd3, 0x74, 0xf0, 0xd6, 0xd7, 0x00, 0x65,
	0x65, 0x24, 0x21, 0xac, 0x96, 0x93, 0x7f, 0xb5, 0xa1, 0x43, 0x25, 0xdf, 0x79, 0x1f, 0x1e, 0x42,
	0x2f, 0x58, 0xf8, 0xb5, 0xac, 0xbb, 0xc1, 0x82, 0xba, 0xb9, 0x16, 0xca, 0x76, 0x4d, 0x28, 0x4d,
	0xc1, 0xf6, 0xba, 0xe0, 0x26, 0x59, 0x3a, 0xef, 0x90, 0x65, 0x0f, 0xeb, 0xc0, 0x01, 0x65, 0xe3,
	0xee, 0x9d, 0xc2, 0x59, 0xb9, 0xf9, 0x1e, 0x74, 0x8c, 0xd4, 0xf7, 0x9a, 0x52, 0x7f, 0x33, 0x2c,
	0xcf, 0x6c, 0xb8, 0xad, 0x00, 0xce, 0x6d, 0x05, 0xe0, 0x3f, 0x87, 0x6e, 0x46, 0xdf, 0x01, 0x74,
	0x2b, 0x46, 0xfb, 0x5b, 0x8d, 0x58, 0xe6, 0x13, 0xc1, 0x2b, 0xb7, 0xe0, 0x04, 0xe4, 0x75, 0x2a,
	0x54, 0x40, 0x57, 0x05, 0x5f, 0x40, 0x84, 0xf8, 0xe7, 0xd0, 0xa3, 0x16, 0xca, 0x6c, 0xdc, 0xa7,
	0xcc, 0x87, 0x8d, 0x26, 0x7b, 0x95, 0x77, 0xfd, 0xe1, 0x33, 0xf8, 0xe0, 0x87, 0x0f, 0x66, 0xad,
	0xcd, 0x1b, 0xde, 0x57, 0x45, 0x5c, 0x0a, 0x30, 0x94, 0xa6, 0x79, 0x11, 0xf3, 0x4f, 0x61, 0x44,
	0x42, 0x64, 0x84, 0x17, 0xf7, 0x8c, 0x68, 0xcf, 0x00, 0xad, 0x24, 0xd1, 0xf3, 0x22, 0x9e, 0xfc,
	0xc5, 0x82, 0xc1, 0xb7, 0x22, 0x5f, 0x5e, 0x4a, 0x7d, 0x74, 0x85, 0x7c, 0xf8, 0x25, 0x0c, 0xde,
	0x18, 0x6c, 0x18, 0xd1, 0x6a, 0x96, 0x5c, 0xee, 0xa5, 0x44, 0xfa, 0x6f, 0x6e, 0x00, 0xf2, 0x48,
	0x62, 0x00, 0xf3, 0x94, 0xd5, 0x4c, 0x9e, 0x42, 0x1b, 0x1e, 0xc9, 0x6a, 0x59, 0x57, 0xfe, 0x76,
	0x43, 0xf9, 0xd7, 0x4c, 0xb1, 0xdf, 0xf3, 0x4a, 0xed, 0x34, 0x5f, 0xa9, 0xf5, 0xb7, 0x4b, 0xb7,
	0xf9, 0x76, 0xd9, 0x86, 0x8e, 0x51, 0xa6, 0x1e, 0x0d, 0xc3, 0x80, 0xfa, 0x55, 0x74, 0x1a, 0x57,
	0x71, 0xfa, 0x67, 0xcb, 0xbc, 0x58, 0x28, 0xc1, 0x3e, 0xf4, 0x66, 0xea, 0x4a, 0x44, 0x61, 0xc0,
	0xee, 0x21, 0x38, 0x0b, 0xd5, 0x2a, 0x54, 0x39, 0x6b, 0xf1, 0x01, 0x38, 0xa7, 0xb1, 0x88, 0x22,
	0x44, 0x16, 0xef, 0x41, 0x7b, 0xa6, 0x72, 0xd6, 0xe6, 0x00, 0xdd, 0x83, 0xf0, 0x02, 0xd7, 0x36,
	0x77, 0xa1, 0xf3, 0x75, 0x94, 0x88, 0x9c, 0x75, 0xd0, 0x7c, 0x98, 0x14, 0x8b, 0x48, 0xb2, 0x2e,
	0x86, 0x79, 0x2d, 0xf4, 0xf2, 0x52, 0x68, 0xd6, 0x33, 0xfb, 0x95, 0xd0, 0x2b, 0xe6, 0x70, 0x07,
	0xec, 0x43, 0x91, 0x4b, 0xe6, 0xf2, 0x21, 0xb8, 0x48, 0xbb, 0xd3, 0x5c, 0xc4, 0x29, 0x03, 0x7c,
	0xe2, 0x20, 0x49, 0x22, 0x29, 0x14, 0xeb, 0x23, 0x38, 0x94, 0xcb, 0x30, 0x16, 0x11, 0x1b, 0xe0,
	0xe3, 0xf3, 0x22, 0x5e, 0x48, 0xcd, 0x86, 0xf8, 0xf8, 0x73, 0x0c, 0x3a, 0xc2, 0x83, 0xe7, 0xb4,
	0xdc, 0x40, 0xe3, 0x99, 0xbc, 0xce, 0x19, 0xc3, 0x98, 0xaf, 0x85, 0x2e, 0x0f, 0xdb, 0x24, 0x47,
	0x18, 0x4b, 0xc6, 0x31, 0xf7, 0xef, 0xe2, 0x88, 0x6d, 0xa1, 0xe9, 0x37, 0x59, 0xa2, 0xd8, 0x36,
	0xae, 0xe6, 0x45, 0x14, 0xb1, 0x9d, 0xe9, 0x31, 0xb8, 0x6b, 0xda, 0xf1, 0x4d, 0x18, 0x12, 0xf0,
	0x6f, 0x7a, 0x32, 0x2c, 0xfd, 0xfe, 0x37, 0x09, 0x76, 0x65, 0x04, 0x60, 0xe0, 0xb7, 0x42, 0xc7,
	0xcc, 0xba, 0x71, 0xff, 0x36, 0xbc, 0x66, 0xed, 0xe9, 0xaf, 0xca, 0xdf, 0x59, 0x14, 0x6d, 0x03,
	0xfa, 0xde, 0xfc, 0xd7, 0xcd, 0x58, 0xc6, 0x10, 0xc8, 0x6b, 0xd3, 0x61, 0x84, 0x38, 0x0b, 0x66,
	0x4d, 0xbf, 0x00, 0xb8, 0x11, 0x73, 0x3c, 0xe7, 0xf9, 0xcb, 0x63, 0xff, 0x79, 0x12, 0xc7, 0x89,
	0x62, 0xf7, 0x2a, 0x7c, 0xba, 0xca, 0x72, 0x19, 0xb3, 0xd6, 0xf4, 0x3b, 0x70, 0xd7, 0x3f, 0x63,
	0x30, 0xee, 0xbc, 0x76, 0xcc, 0x00, 0x9c, 0xb9, 0xff, 0x52, 0x45, 0xa1, 0x92, 0xac, 0x65, 0x9c,
	0x2f, 0xcf, 0xcf, 0x09, 0x5a, 0x18, 0x68, 0xee, 0xd3, 0x6f, 0x90, 0x50, 0x5d, 0xb0, 0x36, 0x26,
	0x59, 0xb9, 0xd1, 0x60, 0x4f, 0x5f, 0xc1, 0xa8, 0xf9, 0xa3, 0x8e, 0xea, 0x38, 0x39, 0xad, 0x1d,
	0xc0, 0x60, 0x80, 0x86, 0x79, 0x62, 0x3e, 0x7d, 0x58, 0xab, 0xb2, 0x7c, 0x9d, 0x44, 0x51, 0xf2,
	0x46, 0x6a, 0x73, 0x0e, 0x5a, 0xca, 0x1d, 0xed, 0xe9, 0x0b, 0x70, 0xaa, 0xdf, 0x1f, 0x7c, 0x1b,
	0x58, 0xb5, 0xae, 0x45, 0xdd, 0x82, 0x8d, 0xb5, 0x75, 0x9e, 0x68, 0x9c, 0x7f, 0xab, 0xb1, 0xf5,
	0x58, 0x0a, 0xad, 0x30, 0xf8, 0xf4, 0x4b, 0xe8, 0xd7, 0x74, 0x09, 0x4f, 0x27, 0xd8, 0xc8, 0x90,
	0x2c, 0x5e, 0xa1, 0xa8, 0xac, 0xd6, 0xf4, 0x19, 0xb8, 0x6b, 0xa5, 0xc7, 0x9e, 0xcc, 0xfc, 0x06,
	0xef, 0x67, 0xfe, 0x41, 0xae, 0x25, 0xf6, 0x0b, 0xa0, 0x3b, 0xf3, 0xbf, 0x11, 0xd9, 0x25, 0xb3,
	0xa6, 0x73, 0x70, 0xd7, 0xd7, 0x9a, 0x3f, 0x00, 0x4e, 0xc0, 0xbf, 0x95, 0x37, 0x87, 0x51, 0xcd,
	0x7e, 0xf2, 0xea, 0x8c, 0xb5, 0xf8, 0x7d, 0xd8, 0xac, 0xd9, 0x0e, 0x8f, 0x8e, 0x8f, 0xce, 0x8e,
	0x98, 0x35, 0xfd, 0x53, 0x0b, 0xfa, 0x35, 0x75, 0xe1, 0x63, 0xd8, 0x2e, 0xe1, 0xed, 0xa0, 0xf7,
	0x61, 0xb3, 0xe1, 0xc1, 0x61, 0xb3, 0x16, 0xff, 0x08, 0xee, 0x37, 0xcc, 0xc8, 0x1d, 0xd4, 0x1f,
	0x66, 0x61, 0x7a, 0x0d, 0x17, 0xd5, 0xcf, 0xda, 0xef, 0xd8, 0x69, 0xb8, 0xcc, 0x3e, 0x60, 0xff,
	0x7c, 0xbb, 0xd3, 0xfa, 0xf7, 0xdb, 0x9d, 0xd6, 0x7f, 0xde, 0xee, 0xb4, 0xfe, 0xfa, 0xdf, 0x9d,
	0x7b, 0x8b, 0x2e, 0xfd, 0xaf, 0xe0, 0xd9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x76, 0xcc, 0xa5,
	0x79, 0x79, 0x10, 0x00, 0x00,
}

func (m *RangePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangePeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangePeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x48
	}
	if len(m.RangePeers) > 0 {
		for iNdEx := len(m.RangePeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RangePeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.AdminPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.AdminPort))
		i--
		dAtA[i] = 0x28
	}
	if m.RaftPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RaftPort))
		i--
		dAtA[i] = 0x20
	}
	if m.ServerPort != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ServerPort))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Applied != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Applied))
		i--
		dAtA[i] = 0x30
	}
	if m.Snapshotting {
		i--
		if m.Snapshotting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DownSeconds != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DownSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.Commit != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RangeEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.ConfVer != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ConfVer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ParentRangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ParentRangeId))
		i--
		dAtA[i] = 0x68
	}
	if m.Term != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x60
	}
	if m.StoreType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.StoreType))
		i--
		dAtA[i] = 0x58
	}
	if m.RangeType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeType))
		i--
		dAtA[i] = 0x50
	}
	if m.Leader != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PrimaryKeys) > 0 {
		for iNdEx := len(m.PrimaryKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrimaryKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.TableId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x38
	}
	if m.DbId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RangeEpoch != nil {
		{
			size, err := m.RangeEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Leader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Leader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateTime != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ColType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ColType))
		i--
		dAtA[i] = 0x78
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.AutoIncrement {
		i--
		if m.AutoIncrement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.Properties) > 0 {
		i -= len(m.Properties)
		copy(dAtA[i:], m.Properties)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Properties)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Index {
		i--
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ordinal != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Ordinal))
		i--
		dAtA[i] = 0x48
	}
	if m.PrimaryKey != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.PrimaryKey))
		i--
		dAtA[i] = 0x40
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Precision != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x30
	}
	if m.Scale != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Scale))
		i--
		dAtA[i] = 0x28
	}
	if m.Unsigned {
		i--
		if m.Unsigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DataType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DataType))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Primary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Primary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Next != nil {
		{
			size, err := m.Next.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ColumnName) > 0 {
		i -= len(m.ColumnName)
		copy(dAtA[i:], m.ColumnName)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.ColumnName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.ConfVer != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ConfVer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.IndexType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColNames) > 0 {
		for iNdEx := len(m.ColNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColNames[iNdEx])
			copy(dAtA[i:], m.ColNames[iNdEx])
			i = encodeVarintBasepb(dAtA, i, uint64(len(m.ColNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataRangeNum != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DataRangeNum))
		i--
		dAtA[i] = 0x70
	}
	if m.ReplicaNum != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.ReplicaNum))
		i--
		dAtA[i] = 0x68
	}
	if m.Type != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Indexes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Expand) > 0 {
		i -= len(m.Expand)
		copy(dAtA[i:], m.Expand)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Expand)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.CreateTime != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.Epoch != nil {
		{
			size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBasepb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBasepb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Properties) > 0 {
		i -= len(m.Properties)
		copy(dAtA[i:], m.Properties)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Properties)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if m.DbId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatcherEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintBasepb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RangeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.RangeId))
		i--
		dAtA[i] = 0x30
	}
	if m.TableId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x28
	}
	if m.DbId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.DbId))
		i--
		dAtA[i] = 0x20
	}
	if m.NodeId != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x18
	}
	if m.EventType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.EventType))
		i--
		dAtA[i] = 0x10
	}
	if m.WatcherType != 0 {
		i = encodeVarintBasepb(dAtA, i, uint64(m.WatcherType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBasepb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBasepb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RangePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.PeerId != 0 {
		n += 1 + sovBasepb(uint64(m.PeerId))
	}
	if m.State != 0 {
		n += 1 + sovBasepb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.ServerPort != 0 {
		n += 1 + sovBasepb(uint64(m.ServerPort))
	}
	if m.RaftPort != 0 {
		n += 1 + sovBasepb(uint64(m.RaftPort))
	}
	if m.AdminPort != 0 {
		n += 1 + sovBasepb(uint64(m.AdminPort))
	}
	if m.State != 0 {
		n += 1 + sovBasepb(uint64(m.State))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if len(m.RangePeers) > 0 {
		for _, e := range m.RangePeers {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovBasepb(uint64(m.LastUpdateTime))
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBasepb(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovBasepb(uint64(m.Commit))
	}
	if m.DownSeconds != 0 {
		n += 1 + sovBasepb(uint64(m.DownSeconds))
	}
	if m.Snapshotting {
		n += 2
	}
	if m.Applied != 0 {
		n += 1 + sovBasepb(uint64(m.Applied))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovBasepb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.DbId != 0 {
		n += 1 + sovBasepb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovBasepb(uint64(m.TableId))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, e := range m.PrimaryKeys {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.Leader != 0 {
		n += 1 + sovBasepb(uint64(m.Leader))
	}
	if m.RangeType != 0 {
		n += 1 + sovBasepb(uint64(m.RangeType))
	}
	if m.StoreType != 0 {
		n += 1 + sovBasepb(uint64(m.StoreType))
	}
	if m.Term != 0 {
		n += 1 + sovBasepb(uint64(m.Term))
	}
	if m.ParentRangeId != 0 {
		n += 1 + sovBasepb(uint64(m.ParentRangeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Leader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.CreateTime != 0 {
		n += 1 + sovBasepb(uint64(m.CreateTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	if m.DataType != 0 {
		n += 1 + sovBasepb(uint64(m.DataType))
	}
	if m.Unsigned {
		n += 2
	}
	if m.Scale != 0 {
		n += 1 + sovBasepb(uint64(m.Scale))
	}
	if m.Precision != 0 {
		n += 1 + sovBasepb(uint64(m.Precision))
	}
	if m.Nullable {
		n += 2
	}
	if m.PrimaryKey != 0 {
		n += 1 + sovBasepb(uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		n += 1 + sovBasepb(uint64(m.Ordinal))
	}
	if m.Index {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.AutoIncrement {
		n += 2
	}
	if m.Unique {
		n += 2
	}
	if m.ColType != 0 {
		n += 1 + sovBasepb(uint64(m.ColType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Primary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TableEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovBasepb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if len(m.ColNames) > 0 {
		for _, s := range m.ColNames {
			l = len(s)
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.Unique {
		n += 2
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.IndexType != 0 {
		n += 1 + sovBasepb(uint64(m.IndexType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovBasepb(uint64(m.DbId))
	}
	if m.Id != 0 {
		n += 1 + sovBasepb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovBasepb(uint64(m.CreateTime))
	}
	if m.Status != 0 {
		n += 1 + sovBasepb(uint64(m.Status))
	}
	l = len(m.Expand)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if len(m.Indexes) > 0 {
		for _, e := range m.Indexes {
			l = e.Size()
			n += 1 + l + sovBasepb(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovBasepb(uint64(m.Type))
	}
	if m.ReplicaNum != 0 {
		n += 1 + sovBasepb(uint64(m.ReplicaNum))
	}
	if m.DataRangeNum != 0 {
		n += 1 + sovBasepb(uint64(m.DataRangeNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatcherEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WatcherType != 0 {
		n += 1 + sovBasepb(uint64(m.WatcherType))
	}
	if m.EventType != 0 {
		n += 1 + sovBasepb(uint64(m.EventType))
	}
	if m.NodeId != 0 {
		n += 1 + sovBasepb(uint64(m.NodeId))
	}
	if m.DbId != 0 {
		n += 1 + sovBasepb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovBasepb(uint64(m.TableId))
	}
	if m.RangeId != 0 {
		n += 1 + sovBasepb(uint64(m.RangeId))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBasepb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBasepb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBasepb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBasepb(x uint64) (n int) {
	return sovBasepb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RangePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RangePeerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPort", wireType)
			}
			m.ServerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftPort", wireType)
			}
			m.RaftPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPort", wireType)
			}
			m.AdminPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangePeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangePeers = append(m.RangePeers, &RangePeer{})
			if err := m.RangePeers[len(m.RangePeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshotting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshotting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKeys = append(m.PrimaryKeys, &Column{})
			if err := m.PrimaryKeys[len(m.PrimaryKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeType", wireType)
			}
			m.RangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeType |= RangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreType", wireType)
			}
			m.StoreType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreType |= StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRangeId", wireType)
			}
			m.ParentRangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentRangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unsigned = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			m.PrimaryKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKey |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = append(m.DefaultValue[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultValue == nil {
				m.DefaultValue = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncrement = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColType", wireType)
			}
			m.ColType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColType |= ColumnType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Primary{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColNames = append(m.ColNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			m.IndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexType |= IndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TableStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expand", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expand = append(m.Expand[:0], dAtA[iNdEx:postIndex]...)
			if m.Expand == nil {
				m.Expand = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, &Index{})
			if err := m.Indexes[len(m.Indexes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StoreType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNum", wireType)
			}
			m.ReplicaNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRangeNum", wireType)
			}
			m.DataRangeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataRangeNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatcherEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatcherEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatcherType", wireType)
			}
			m.WatcherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatcherType |= WatcherType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBasepb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBasepb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBasepb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBasepb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBasepb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBasepb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBasepb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBasepb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBasepb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBasepb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBasepb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBasepb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBasepb = fmt.Errorf("proto: unexpected end of group")
)
