// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mspb/mspb.proto

#ifndef PROTOBUF_mspb_2fmspb_2eproto__INCLUDED
#define PROTOBUF_mspb_2fmspb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basepb/basepb.pb.h"
#include "dspb/schedule.pb.h"
// @@protoc_insertion_point(includes)
namespace mspb {
class AskSplitRequest;
class AskSplitRequestDefaultTypeInternal;
extern AskSplitRequestDefaultTypeInternal _AskSplitRequest_default_instance_;
class AskSplitResponse;
class AskSplitResponseDefaultTypeInternal;
extern AskSplitResponseDefaultTypeInternal _AskSplitResponse_default_instance_;
class CreateDatabaseRequest;
class CreateDatabaseRequestDefaultTypeInternal;
extern CreateDatabaseRequestDefaultTypeInternal _CreateDatabaseRequest_default_instance_;
class CreateDatabaseResponse;
class CreateDatabaseResponseDefaultTypeInternal;
extern CreateDatabaseResponseDefaultTypeInternal _CreateDatabaseResponse_default_instance_;
class CreateTableRequest;
class CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableResponse;
class CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class DelDatabaseRequest;
class DelDatabaseRequestDefaultTypeInternal;
extern DelDatabaseRequestDefaultTypeInternal _DelDatabaseRequest_default_instance_;
class DelDatabaseResponse;
class DelDatabaseResponseDefaultTypeInternal;
extern DelDatabaseResponseDefaultTypeInternal _DelDatabaseResponse_default_instance_;
class DelTableRequest;
class DelTableRequestDefaultTypeInternal;
extern DelTableRequestDefaultTypeInternal _DelTableRequest_default_instance_;
class DelTableResponse;
class DelTableResponseDefaultTypeInternal;
extern DelTableResponseDefaultTypeInternal _DelTableResponse_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GetAutoIncIdRequest;
class GetAutoIncIdRequestDefaultTypeInternal;
extern GetAutoIncIdRequestDefaultTypeInternal _GetAutoIncIdRequest_default_instance_;
class GetAutoIncIdResponse;
class GetAutoIncIdResponseDefaultTypeInternal;
extern GetAutoIncIdResponseDefaultTypeInternal _GetAutoIncIdResponse_default_instance_;
class GetColumnRequest;
class GetColumnRequestDefaultTypeInternal;
extern GetColumnRequestDefaultTypeInternal _GetColumnRequest_default_instance_;
class GetColumnResponse;
class GetColumnResponseDefaultTypeInternal;
extern GetColumnResponseDefaultTypeInternal _GetColumnResponse_default_instance_;
class GetColumnsRequest;
class GetColumnsRequestDefaultTypeInternal;
extern GetColumnsRequestDefaultTypeInternal _GetColumnsRequest_default_instance_;
class GetColumnsResponse;
class GetColumnsResponseDefaultTypeInternal;
extern GetColumnsResponseDefaultTypeInternal _GetColumnsResponse_default_instance_;
class GetDBRequest;
class GetDBRequestDefaultTypeInternal;
extern GetDBRequestDefaultTypeInternal _GetDBRequest_default_instance_;
class GetDBResponse;
class GetDBResponseDefaultTypeInternal;
extern GetDBResponseDefaultTypeInternal _GetDBResponse_default_instance_;
class GetDBsResponse;
class GetDBsResponseDefaultTypeInternal;
extern GetDBsResponseDefaultTypeInternal _GetDBsResponse_default_instance_;
class GetNodeInfo;
class GetNodeInfoDefaultTypeInternal;
extern GetNodeInfoDefaultTypeInternal _GetNodeInfo_default_instance_;
class GetNodeInfoRequest;
class GetNodeInfoRequestDefaultTypeInternal;
extern GetNodeInfoRequestDefaultTypeInternal _GetNodeInfoRequest_default_instance_;
class GetNodeInfoResponse;
class GetNodeInfoResponseDefaultTypeInternal;
extern GetNodeInfoResponseDefaultTypeInternal _GetNodeInfoResponse_default_instance_;
class GetNodeRequest;
class GetNodeRequestDefaultTypeInternal;
extern GetNodeRequestDefaultTypeInternal _GetNodeRequest_default_instance_;
class GetNodeResponse;
class GetNodeResponseDefaultTypeInternal;
extern GetNodeResponseDefaultTypeInternal _GetNodeResponse_default_instance_;
class GetNodesRequest;
class GetNodesRequestDefaultTypeInternal;
extern GetNodesRequestDefaultTypeInternal _GetNodesRequest_default_instance_;
class GetNodesResponse;
class GetNodesResponseDefaultTypeInternal;
extern GetNodesResponseDefaultTypeInternal _GetNodesResponse_default_instance_;
class GetRouteRequest;
class GetRouteRequestDefaultTypeInternal;
extern GetRouteRequestDefaultTypeInternal _GetRouteRequest_default_instance_;
class GetRouteResponse;
class GetRouteResponseDefaultTypeInternal;
extern GetRouteResponseDefaultTypeInternal _GetRouteResponse_default_instance_;
class GetTableRequest;
class GetTableRequestDefaultTypeInternal;
extern GetTableRequestDefaultTypeInternal _GetTableRequest_default_instance_;
class GetTableResponse;
class GetTableResponseDefaultTypeInternal;
extern GetTableResponseDefaultTypeInternal _GetTableResponse_default_instance_;
class GetTablesRequest;
class GetTablesRequestDefaultTypeInternal;
extern GetTablesRequestDefaultTypeInternal _GetTablesRequest_default_instance_;
class GetTablesResponse;
class GetTablesResponseDefaultTypeInternal;
extern GetTablesResponseDefaultTypeInternal _GetTablesResponse_default_instance_;
class NodeHeartbeatRequest;
class NodeHeartbeatRequestDefaultTypeInternal;
extern NodeHeartbeatRequestDefaultTypeInternal _NodeHeartbeatRequest_default_instance_;
class NodeHeartbeatResponse;
class NodeHeartbeatResponseDefaultTypeInternal;
extern NodeHeartbeatResponseDefaultTypeInternal _NodeHeartbeatResponse_default_instance_;
class RangeHeartbeatRequest;
class RangeHeartbeatRequestDefaultTypeInternal;
extern RangeHeartbeatRequestDefaultTypeInternal _RangeHeartbeatRequest_default_instance_;
class RangeHeartbeatResponse;
class RangeHeartbeatResponseDefaultTypeInternal;
extern RangeHeartbeatResponseDefaultTypeInternal _RangeHeartbeatResponse_default_instance_;
class RegisterNodeRequest;
class RegisterNodeRequestDefaultTypeInternal;
extern RegisterNodeRequestDefaultTypeInternal _RegisterNodeRequest_default_instance_;
class RegisterNodeResponse;
class RegisterNodeResponseDefaultTypeInternal;
extern RegisterNodeResponseDefaultTypeInternal _RegisterNodeResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
}  // namespace mspb

namespace mspb {

namespace protobuf_mspb_2fmspb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mspb_2fmspb_2eproto

enum ErrorType {
  No = 0,
  UnDefine = 1,
  ClusterIDNotSame = 2,
  NoSelectedNode = 3,
  InternalError = 4,
  GenID = 5,
  DupDatabase = 6,
  DupTable = 7,
  NotRuningTable = 8,
  NotExistDatabase = 9,
  NotExistTable = 10,
  NotExistNode = 11,
  NotActiveNode = 12,
  NotExistRange = 13,
  ExistsRange = 14,
  NotExistPeer = 15,
  NotEnoughResources = 16,
  InvalidParam = 17,
  InvalidColumn = 18,
  InvalidIndex = 19,
  ColumnNameTooLong = 20,
  ColumnNotExist = 21,
  DupColumnName = 22,
  PkMustNotNull = 23,
  MissingPk = 24,
  PkMustNotSetDefaultValue = 25,
  NodeRejectNewPeer = 26,
  NodeBlocked = 27,
  NodeStateConfused = 28,
  NodeNotEnough = 29,
  SchedulerExisted = 30,
  SchedulerNotFound = 31,
  WorkerExisted = 32,
  WorkerNotFound = 33,
  SqlReservedWord = 34,
  SQLSyntaxError = 35,
  RangeMetaConflict = 36,
  NotFound = 37,
  NotAllowSplit = 38,
  NotCancel = 39,
  NotAllowDelete = 40,
  ClientIPNotSet = 41,
  DatabaseNotEmpty = 42,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = No;
const ErrorType ErrorType_MAX = DatabaseNotEmpty;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
// ===================================================================

class RangeHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RangeHeartbeatRequest) */ {
 public:
  RangeHeartbeatRequest();
  virtual ~RangeHeartbeatRequest();

  RangeHeartbeatRequest(const RangeHeartbeatRequest& from);

  inline RangeHeartbeatRequest& operator=(const RangeHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeHeartbeatRequest(RangeHeartbeatRequest&& from) noexcept
    : RangeHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline RangeHeartbeatRequest& operator=(RangeHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeHeartbeatRequest& default_instance();

  static inline const RangeHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const RangeHeartbeatRequest*>(
               &_RangeHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RangeHeartbeatRequest* other);
  friend void swap(RangeHeartbeatRequest& a, RangeHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeHeartbeatRequest& from);
  void MergeFrom(const RangeHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.PeerStatus peers_status = 4;
  int peers_status_size() const;
  void clear_peers_status();
  static const int kPeersStatusFieldNumber = 4;
  const ::basepb::PeerStatus& peers_status(int index) const;
  ::basepb::PeerStatus* mutable_peers_status(int index);
  ::basepb::PeerStatus* add_peers_status();
  ::google::protobuf::RepeatedPtrField< ::basepb::PeerStatus >*
      mutable_peers_status();
  const ::google::protobuf::RepeatedPtrField< ::basepb::PeerStatus >&
      peers_status() const;

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .basepb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::basepb::Range& range() const;
  ::basepb::Range* mutable_range();
  ::basepb::Range* release_range();
  void set_allocated_range(::basepb::Range* range);

  // uint64 term = 3;
  void clear_term();
  static const int kTermFieldNumber = 3;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RangeHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::PeerStatus > peers_status_;
  ::mspb::RequestHeader* header_;
  ::basepb::Range* range_;
  ::google::protobuf::uint64 term_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RangeHeartbeatResponse) */ {
 public:
  RangeHeartbeatResponse();
  virtual ~RangeHeartbeatResponse();

  RangeHeartbeatResponse(const RangeHeartbeatResponse& from);

  inline RangeHeartbeatResponse& operator=(const RangeHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeHeartbeatResponse(RangeHeartbeatResponse&& from) noexcept
    : RangeHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline RangeHeartbeatResponse& operator=(RangeHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeHeartbeatResponse& default_instance();

  static inline const RangeHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const RangeHeartbeatResponse*>(
               &_RangeHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RangeHeartbeatResponse* other);
  friend void swap(RangeHeartbeatResponse& a, RangeHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeHeartbeatResponse& from);
  void MergeFrom(const RangeHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.RangeEpoch epoch = 3;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 3;
  const ::basepb::RangeEpoch& epoch() const;
  ::basepb::RangeEpoch* mutable_epoch();
  ::basepb::RangeEpoch* release_epoch();
  void set_allocated_epoch(::basepb::RangeEpoch* epoch);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RangeHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::RangeEpoch* epoch_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeHeartbeatRequest) */ {
 public:
  NodeHeartbeatRequest();
  virtual ~NodeHeartbeatRequest();

  NodeHeartbeatRequest(const NodeHeartbeatRequest& from);

  inline NodeHeartbeatRequest& operator=(const NodeHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatRequest(NodeHeartbeatRequest&& from) noexcept
    : NodeHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatRequest& operator=(NodeHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatRequest& default_instance();

  static inline const NodeHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatRequest*>(
               &_NodeHeartbeatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NodeHeartbeatRequest* other);
  friend void swap(NodeHeartbeatRequest& a, NodeHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeHeartbeatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeHeartbeatRequest& from);
  void MergeFrom(const NodeHeartbeatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.NodeHeartbeatResponse) */ {
 public:
  NodeHeartbeatResponse();
  virtual ~NodeHeartbeatResponse();

  NodeHeartbeatResponse(const NodeHeartbeatResponse& from);

  inline NodeHeartbeatResponse& operator=(const NodeHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatResponse(NodeHeartbeatResponse&& from) noexcept
    : NodeHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatResponse& operator=(NodeHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatResponse& default_instance();

  static inline const NodeHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatResponse*>(
               &_NodeHeartbeatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NodeHeartbeatResponse* other);
  friend void swap(NodeHeartbeatResponse& a, NodeHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeHeartbeatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeHeartbeatResponse& from);
  void MergeFrom(const NodeHeartbeatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.NodeHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AskSplitRequest) */ {
 public:
  AskSplitRequest();
  virtual ~AskSplitRequest();

  AskSplitRequest(const AskSplitRequest& from);

  inline AskSplitRequest& operator=(const AskSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitRequest(AskSplitRequest&& from) noexcept
    : AskSplitRequest() {
    *this = ::std::move(from);
  }

  inline AskSplitRequest& operator=(AskSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitRequest& default_instance();

  static inline const AskSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AskSplitRequest*>(
               &_AskSplitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AskSplitRequest* other);
  friend void swap(AskSplitRequest& a, AskSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitRequest& from);
  void MergeFrom(const AskSplitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes split_key = 3;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 3;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // .basepb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::basepb::Range& range() const;
  ::basepb::Range* mutable_range();
  ::basepb::Range* release_range();
  void set_allocated_range(::basepb::Range* range);

  // bool force = 4;
  void clear_force();
  static const int kForceFieldNumber = 4;
  bool force() const;
  void set_force(bool value);

  // @@protoc_insertion_point(class_scope:mspb.AskSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::mspb::RequestHeader* header_;
  ::basepb::Range* range_;
  bool force_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.AskSplitResponse) */ {
 public:
  AskSplitResponse();
  virtual ~AskSplitResponse();

  AskSplitResponse(const AskSplitResponse& from);

  inline AskSplitResponse& operator=(const AskSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AskSplitResponse(AskSplitResponse&& from) noexcept
    : AskSplitResponse() {
    *this = ::std::move(from);
  }

  inline AskSplitResponse& operator=(AskSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AskSplitResponse& default_instance();

  static inline const AskSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AskSplitResponse*>(
               &_AskSplitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AskSplitResponse* other);
  friend void swap(AskSplitResponse& a, AskSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AskSplitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskSplitResponse& from);
  void MergeFrom(const AskSplitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 4;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 4;
  ::google::protobuf::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::google::protobuf::uint64 value);
  void add_new_peer_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      new_peer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_new_peer_ids();

  // bytes split_key = 5;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 5;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Range range = 2;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 2;
  const ::basepb::Range& range() const;
  ::basepb::Range* mutable_range();
  ::basepb::Range* release_range();
  void set_allocated_range(::basepb::Range* range);

  // uint64 new_range_id = 3;
  void clear_new_range_id();
  static const int kNewRangeIdFieldNumber = 3;
  ::google::protobuf::uint64 new_range_id() const;
  void set_new_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.AskSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > new_peer_ids_;
  mutable int _new_peer_ids_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Range* range_;
  ::google::protobuf::uint64 new_range_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RegisterNodeRequest) */ {
 public:
  RegisterNodeRequest();
  virtual ~RegisterNodeRequest();

  RegisterNodeRequest(const RegisterNodeRequest& from);

  inline RegisterNodeRequest& operator=(const RegisterNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterNodeRequest(RegisterNodeRequest&& from) noexcept
    : RegisterNodeRequest() {
    *this = ::std::move(from);
  }

  inline RegisterNodeRequest& operator=(RegisterNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterNodeRequest& default_instance();

  static inline const RegisterNodeRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeRequest*>(
               &_RegisterNodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RegisterNodeRequest* other);
  friend void swap(RegisterNodeRequest& a, RegisterNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterNodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterNodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterNodeRequest& from);
  void MergeFrom(const RegisterNodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint32 server_port = 2;
  void clear_server_port();
  static const int kServerPortFieldNumber = 2;
  ::google::protobuf::uint32 server_port() const;
  void set_server_port(::google::protobuf::uint32 value);

  // uint32 raft_port = 3;
  void clear_raft_port();
  static const int kRaftPortFieldNumber = 3;
  ::google::protobuf::uint32 raft_port() const;
  void set_raft_port(::google::protobuf::uint32 value);

  // uint32 admin_port = 4;
  void clear_admin_port();
  static const int kAdminPortFieldNumber = 4;
  ::google::protobuf::uint32 admin_port() const;
  void set_admin_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.RegisterNodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint32 server_port_;
  ::google::protobuf::uint32 raft_port_;
  ::google::protobuf::uint32 admin_port_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RegisterNodeResponse) */ {
 public:
  RegisterNodeResponse();
  virtual ~RegisterNodeResponse();

  RegisterNodeResponse(const RegisterNodeResponse& from);

  inline RegisterNodeResponse& operator=(const RegisterNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterNodeResponse(RegisterNodeResponse&& from) noexcept
    : RegisterNodeResponse() {
    *this = ::std::move(from);
  }

  inline RegisterNodeResponse& operator=(RegisterNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterNodeResponse& default_instance();

  static inline const RegisterNodeResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeResponse*>(
               &_RegisterNodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RegisterNodeResponse* other);
  friend void swap(RegisterNodeResponse& a, RegisterNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterNodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterNodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterNodeResponse& from);
  void MergeFrom(const RegisterNodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // uint64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 node_id() const;
  void set_node_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RegisterNodeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::google::protobuf::uint64 node_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRouteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetRouteRequest) */ {
 public:
  GetRouteRequest();
  virtual ~GetRouteRequest();

  GetRouteRequest(const GetRouteRequest& from);

  inline GetRouteRequest& operator=(const GetRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRouteRequest(GetRouteRequest&& from) noexcept
    : GetRouteRequest() {
    *this = ::std::move(from);
  }

  inline GetRouteRequest& operator=(GetRouteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRouteRequest& default_instance();

  static inline const GetRouteRequest* internal_default_instance() {
    return reinterpret_cast<const GetRouteRequest*>(
               &_GetRouteRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetRouteRequest* other);
  friend void swap(GetRouteRequest& a, GetRouteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRouteRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRouteRequest& from);
  void MergeFrom(const GetRouteRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRouteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 4;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // uint32 max = 5;
  void clear_max();
  static const int kMaxFieldNumber = 5;
  ::google::protobuf::uint32 max() const;
  void set_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.GetRouteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  ::google::protobuf::uint32 max_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRouteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetRouteResponse) */ {
 public:
  GetRouteResponse();
  virtual ~GetRouteResponse();

  GetRouteResponse(const GetRouteResponse& from);

  inline GetRouteResponse& operator=(const GetRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRouteResponse(GetRouteResponse&& from) noexcept
    : GetRouteResponse() {
    *this = ::std::move(from);
  }

  inline GetRouteResponse& operator=(GetRouteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRouteResponse& default_instance();

  static inline const GetRouteResponse* internal_default_instance() {
    return reinterpret_cast<const GetRouteResponse*>(
               &_GetRouteResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GetRouteResponse* other);
  friend void swap(GetRouteResponse& a, GetRouteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRouteResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRouteResponse& from);
  void MergeFrom(const GetRouteResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRouteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.Range routes = 2;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 2;
  const ::basepb::Range& routes(int index) const;
  ::basepb::Range* mutable_routes(int index);
  ::basepb::Range* add_routes();
  ::google::protobuf::RepeatedPtrField< ::basepb::Range >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::basepb::Range >&
      routes() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetRouteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::Range > routes_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodesRequest) */ {
 public:
  GetNodesRequest();
  virtual ~GetNodesRequest();

  GetNodesRequest(const GetNodesRequest& from);

  inline GetNodesRequest& operator=(const GetNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodesRequest(GetNodesRequest&& from) noexcept
    : GetNodesRequest() {
    *this = ::std::move(from);
  }

  inline GetNodesRequest& operator=(GetNodesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodesRequest& default_instance();

  static inline const GetNodesRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodesRequest*>(
               &_GetNodesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(GetNodesRequest* other);
  friend void swap(GetNodesRequest& a, GetNodesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodesRequest& from);
  void MergeFrom(const GetNodesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetNodesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodesResponse) */ {
 public:
  GetNodesResponse();
  virtual ~GetNodesResponse();

  GetNodesResponse(const GetNodesResponse& from);

  inline GetNodesResponse& operator=(const GetNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodesResponse(GetNodesResponse&& from) noexcept
    : GetNodesResponse() {
    *this = ::std::move(from);
  }

  inline GetNodesResponse& operator=(GetNodesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodesResponse& default_instance();

  static inline const GetNodesResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodesResponse*>(
               &_GetNodesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(GetNodesResponse* other);
  friend void swap(GetNodesResponse& a, GetNodesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodesResponse& from);
  void MergeFrom(const GetNodesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.Node nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  const ::basepb::Node& nodes(int index) const;
  ::basepb::Node* mutable_nodes(int index);
  ::basepb::Node* add_nodes();
  ::google::protobuf::RepeatedPtrField< ::basepb::Node >*
      mutable_nodes();
  const ::google::protobuf::RepeatedPtrField< ::basepb::Node >&
      nodes() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetNodesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::Node > nodes_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeRequest) */ {
 public:
  GetNodeRequest();
  virtual ~GetNodeRequest();

  GetNodeRequest(const GetNodeRequest& from);

  inline GetNodeRequest& operator=(const GetNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeRequest(GetNodeRequest&& from) noexcept
    : GetNodeRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeRequest& operator=(GetNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeRequest& default_instance();

  static inline const GetNodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeRequest*>(
               &_GetNodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(GetNodeRequest* other);
  friend void swap(GetNodeRequest& a, GetNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeRequest& from);
  void MergeFrom(const GetNodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeResponse) */ {
 public:
  GetNodeResponse();
  virtual ~GetNodeResponse();

  GetNodeResponse(const GetNodeResponse& from);

  inline GetNodeResponse& operator=(const GetNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeResponse(GetNodeResponse&& from) noexcept
    : GetNodeResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeResponse& operator=(GetNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeResponse& default_instance();

  static inline const GetNodeResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeResponse*>(
               &_GetNodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(GetNodeResponse* other);
  friend void swap(GetNodeResponse& a, GetNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeResponse& from);
  void MergeFrom(const GetNodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::basepb::Node& node() const;
  ::basepb::Node* mutable_node();
  ::basepb::Node* release_node();
  void set_allocated_node(::basepb::Node* node);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Node* node_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelDatabaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.DelDatabaseRequest) */ {
 public:
  DelDatabaseRequest();
  virtual ~DelDatabaseRequest();

  DelDatabaseRequest(const DelDatabaseRequest& from);

  inline DelDatabaseRequest& operator=(const DelDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DelDatabaseRequest(DelDatabaseRequest&& from) noexcept
    : DelDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline DelDatabaseRequest& operator=(DelDatabaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DelDatabaseRequest& default_instance();

  static inline const DelDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const DelDatabaseRequest*>(
               &_DelDatabaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DelDatabaseRequest* other);
  friend void swap(DelDatabaseRequest& a, DelDatabaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DelDatabaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DelDatabaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelDatabaseRequest& from);
  void MergeFrom(const DelDatabaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelDatabaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.DelDatabaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelDatabaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.DelDatabaseResponse) */ {
 public:
  DelDatabaseResponse();
  virtual ~DelDatabaseResponse();

  DelDatabaseResponse(const DelDatabaseResponse& from);

  inline DelDatabaseResponse& operator=(const DelDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DelDatabaseResponse(DelDatabaseResponse&& from) noexcept
    : DelDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline DelDatabaseResponse& operator=(DelDatabaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DelDatabaseResponse& default_instance();

  static inline const DelDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const DelDatabaseResponse*>(
               &_DelDatabaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(DelDatabaseResponse* other);
  friend void swap(DelDatabaseResponse& a, DelDatabaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DelDatabaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DelDatabaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelDatabaseResponse& from);
  void MergeFrom(const DelDatabaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelDatabaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.DelDatabaseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDBRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetDBRequest) */ {
 public:
  GetDBRequest();
  virtual ~GetDBRequest();

  GetDBRequest(const GetDBRequest& from);

  inline GetDBRequest& operator=(const GetDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDBRequest(GetDBRequest&& from) noexcept
    : GetDBRequest() {
    *this = ::std::move(from);
  }

  inline GetDBRequest& operator=(GetDBRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDBRequest& default_instance();

  static inline const GetDBRequest* internal_default_instance() {
    return reinterpret_cast<const GetDBRequest*>(
               &_GetDBRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetDBRequest* other);
  friend void swap(GetDBRequest& a, GetDBRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDBRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDBRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDBRequest& from);
  void MergeFrom(const GetDBRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDBRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetDBRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDBResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetDBResponse) */ {
 public:
  GetDBResponse();
  virtual ~GetDBResponse();

  GetDBResponse(const GetDBResponse& from);

  inline GetDBResponse& operator=(const GetDBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDBResponse(GetDBResponse&& from) noexcept
    : GetDBResponse() {
    *this = ::std::move(from);
  }

  inline GetDBResponse& operator=(GetDBResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDBResponse& default_instance();

  static inline const GetDBResponse* internal_default_instance() {
    return reinterpret_cast<const GetDBResponse*>(
               &_GetDBResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetDBResponse* other);
  friend void swap(GetDBResponse& a, GetDBResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDBResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDBResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDBResponse& from);
  void MergeFrom(const GetDBResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDBResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.DataBase db = 2;
  bool has_db() const;
  void clear_db();
  static const int kDbFieldNumber = 2;
  const ::basepb::DataBase& db() const;
  ::basepb::DataBase* mutable_db();
  ::basepb::DataBase* release_db();
  void set_allocated_db(::basepb::DataBase* db);

  // @@protoc_insertion_point(class_scope:mspb.GetDBResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::DataBase* db_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDBsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetDBsResponse) */ {
 public:
  GetDBsResponse();
  virtual ~GetDBsResponse();

  GetDBsResponse(const GetDBsResponse& from);

  inline GetDBsResponse& operator=(const GetDBsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDBsResponse(GetDBsResponse&& from) noexcept
    : GetDBsResponse() {
    *this = ::std::move(from);
  }

  inline GetDBsResponse& operator=(GetDBsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDBsResponse& default_instance();

  static inline const GetDBsResponse* internal_default_instance() {
    return reinterpret_cast<const GetDBsResponse*>(
               &_GetDBsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(GetDBsResponse* other);
  friend void swap(GetDBsResponse& a, GetDBsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDBsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetDBsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetDBsResponse& from);
  void MergeFrom(const GetDBsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetDBsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.DataBase dbs = 2;
  int dbs_size() const;
  void clear_dbs();
  static const int kDbsFieldNumber = 2;
  const ::basepb::DataBase& dbs(int index) const;
  ::basepb::DataBase* mutable_dbs(int index);
  ::basepb::DataBase* add_dbs();
  ::google::protobuf::RepeatedPtrField< ::basepb::DataBase >*
      mutable_dbs();
  const ::google::protobuf::RepeatedPtrField< ::basepb::DataBase >&
      dbs() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetDBsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::DataBase > dbs_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.DelTableRequest) */ {
 public:
  DelTableRequest();
  virtual ~DelTableRequest();

  DelTableRequest(const DelTableRequest& from);

  inline DelTableRequest& operator=(const DelTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DelTableRequest(DelTableRequest&& from) noexcept
    : DelTableRequest() {
    *this = ::std::move(from);
  }

  inline DelTableRequest& operator=(DelTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DelTableRequest& default_instance();

  static inline const DelTableRequest* internal_default_instance() {
    return reinterpret_cast<const DelTableRequest*>(
               &_DelTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DelTableRequest* other);
  friend void swap(DelTableRequest& a, DelTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DelTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DelTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelTableRequest& from);
  void MergeFrom(const DelTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 3;
  void clear_db_name();
  static const int kDbNameFieldNumber = 3;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string table_name = 5;
  void clear_table_name();
  static const int kTableNameFieldNumber = 5;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 4;
  void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.DelTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.DelTableResponse) */ {
 public:
  DelTableResponse();
  virtual ~DelTableResponse();

  DelTableResponse(const DelTableResponse& from);

  inline DelTableResponse& operator=(const DelTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DelTableResponse(DelTableResponse&& from) noexcept
    : DelTableResponse() {
    *this = ::std::move(from);
  }

  inline DelTableResponse& operator=(DelTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DelTableResponse& default_instance();

  static inline const DelTableResponse* internal_default_instance() {
    return reinterpret_cast<const DelTableResponse*>(
               &_DelTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(DelTableResponse* other);
  friend void swap(DelTableResponse& a, DelTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DelTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DelTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelTableResponse& from);
  void MergeFrom(const DelTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Table table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::basepb::Table& table() const;
  ::basepb::Table* mutable_table();
  ::basepb::Table* release_table();
  void set_allocated_table(::basepb::Table* table);

  // @@protoc_insertion_point(class_scope:mspb.DelTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Table* table_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableRequest) */ {
 public:
  GetTableRequest();
  virtual ~GetTableRequest();

  GetTableRequest(const GetTableRequest& from);

  inline GetTableRequest& operator=(const GetTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableRequest(GetTableRequest&& from) noexcept
    : GetTableRequest() {
    *this = ::std::move(from);
  }

  inline GetTableRequest& operator=(GetTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableRequest& default_instance();

  static inline const GetTableRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableRequest*>(
               &_GetTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(GetTableRequest* other);
  friend void swap(GetTableRequest& a, GetTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableRequest& from);
  void MergeFrom(const GetTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 3;
  void clear_db_name();
  static const int kDbNameFieldNumber = 3;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string table_name = 5;
  void clear_table_name();
  static const int kTableNameFieldNumber = 5;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 4;
  void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTableResponse) */ {
 public:
  GetTableResponse();
  virtual ~GetTableResponse();

  GetTableResponse(const GetTableResponse& from);

  inline GetTableResponse& operator=(const GetTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTableResponse(GetTableResponse&& from) noexcept
    : GetTableResponse() {
    *this = ::std::move(from);
  }

  inline GetTableResponse& operator=(GetTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTableResponse& default_instance();

  static inline const GetTableResponse* internal_default_instance() {
    return reinterpret_cast<const GetTableResponse*>(
               &_GetTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(GetTableResponse* other);
  friend void swap(GetTableResponse& a, GetTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTableResponse& from);
  void MergeFrom(const GetTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Table table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::basepb::Table& table() const;
  ::basepb::Table* mutable_table();
  ::basepb::Table* release_table();
  void set_allocated_table(::basepb::Table* table);

  // @@protoc_insertion_point(class_scope:mspb.GetTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Table* table_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTablesRequest) */ {
 public:
  GetTablesRequest();
  virtual ~GetTablesRequest();

  GetTablesRequest(const GetTablesRequest& from);

  inline GetTablesRequest& operator=(const GetTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesRequest(GetTablesRequest&& from) noexcept
    : GetTablesRequest() {
    *this = ::std::move(from);
  }

  inline GetTablesRequest& operator=(GetTablesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesRequest& default_instance();

  static inline const GetTablesRequest* internal_default_instance() {
    return reinterpret_cast<const GetTablesRequest*>(
               &_GetTablesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(GetTablesRequest* other);
  friend void swap(GetTablesRequest& a, GetTablesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTablesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTablesRequest& from);
  void MergeFrom(const GetTablesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTablesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 3;
  void clear_db_name();
  static const int kDbNameFieldNumber = 3;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetTablesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetTablesResponse) */ {
 public:
  GetTablesResponse();
  virtual ~GetTablesResponse();

  GetTablesResponse(const GetTablesResponse& from);

  inline GetTablesResponse& operator=(const GetTablesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesResponse(GetTablesResponse&& from) noexcept
    : GetTablesResponse() {
    *this = ::std::move(from);
  }

  inline GetTablesResponse& operator=(GetTablesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesResponse& default_instance();

  static inline const GetTablesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTablesResponse*>(
               &_GetTablesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(GetTablesResponse* other);
  friend void swap(GetTablesResponse& a, GetTablesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTablesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTablesResponse& from);
  void MergeFrom(const GetTablesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTablesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.Table tables = 2;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 2;
  const ::basepb::Table& tables(int index) const;
  ::basepb::Table* mutable_tables(int index);
  ::basepb::Table* add_tables();
  ::google::protobuf::RepeatedPtrField< ::basepb::Table >*
      mutable_tables();
  const ::google::protobuf::RepeatedPtrField< ::basepb::Table >&
      tables() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetTablesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::Table > tables_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnsRequest) */ {
 public:
  GetColumnsRequest();
  virtual ~GetColumnsRequest();

  GetColumnsRequest(const GetColumnsRequest& from);

  inline GetColumnsRequest& operator=(const GetColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsRequest(GetColumnsRequest&& from) noexcept
    : GetColumnsRequest() {
    *this = ::std::move(from);
  }

  inline GetColumnsRequest& operator=(GetColumnsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsRequest& default_instance();

  static inline const GetColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const GetColumnsRequest*>(
               &_GetColumnsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(GetColumnsRequest* other);
  friend void swap(GetColumnsRequest& a, GetColumnsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnsRequest& from);
  void MergeFrom(const GetColumnsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnsResponse) */ {
 public:
  GetColumnsResponse();
  virtual ~GetColumnsResponse();

  GetColumnsResponse(const GetColumnsResponse& from);

  inline GetColumnsResponse& operator=(const GetColumnsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnsResponse(GetColumnsResponse&& from) noexcept
    : GetColumnsResponse() {
    *this = ::std::move(from);
  }

  inline GetColumnsResponse& operator=(GetColumnsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnsResponse& default_instance();

  static inline const GetColumnsResponse* internal_default_instance() {
    return reinterpret_cast<const GetColumnsResponse*>(
               &_GetColumnsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetColumnsResponse* other);
  friend void swap(GetColumnsResponse& a, GetColumnsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnsResponse& from);
  void MergeFrom(const GetColumnsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .basepb.Column columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::basepb::Column& columns(int index) const;
  ::basepb::Column* mutable_columns(int index);
  ::basepb::Column* add_columns();
  ::google::protobuf::RepeatedPtrField< ::basepb::Column >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::basepb::Column >&
      columns() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::basepb::Column > columns_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeInfoRequest) */ {
 public:
  GetNodeInfoRequest();
  virtual ~GetNodeInfoRequest();

  GetNodeInfoRequest(const GetNodeInfoRequest& from);

  inline GetNodeInfoRequest& operator=(const GetNodeInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeInfoRequest(GetNodeInfoRequest&& from) noexcept
    : GetNodeInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoRequest& operator=(GetNodeInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoRequest& default_instance();

  static inline const GetNodeInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoRequest*>(
               &_GetNodeInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(GetNodeInfoRequest* other);
  friend void swap(GetNodeInfoRequest& a, GetNodeInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeInfoRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeInfoRequest& from);
  void MergeFrom(const GetNodeInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeInfoResponse) */ {
 public:
  GetNodeInfoResponse();
  virtual ~GetNodeInfoResponse();

  GetNodeInfoResponse(const GetNodeInfoResponse& from);

  inline GetNodeInfoResponse& operator=(const GetNodeInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeInfoResponse(GetNodeInfoResponse&& from) noexcept
    : GetNodeInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoResponse& operator=(GetNodeInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfoResponse& default_instance();

  static inline const GetNodeInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoResponse*>(
               &_GetNodeInfoResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(GetNodeInfoResponse* other);
  friend void swap(GetNodeInfoResponse& a, GetNodeInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeInfoResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeInfoResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeInfoResponse& from);
  void MergeFrom(const GetNodeInfoResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mspb.GetNodeInfo nodeInfos = 2;
  int nodeinfos_size() const;
  void clear_nodeinfos();
  static const int kNodeInfosFieldNumber = 2;
  const ::mspb::GetNodeInfo& nodeinfos(int index) const;
  ::mspb::GetNodeInfo* mutable_nodeinfos(int index);
  ::mspb::GetNodeInfo* add_nodeinfos();
  ::google::protobuf::RepeatedPtrField< ::mspb::GetNodeInfo >*
      mutable_nodeinfos();
  const ::google::protobuf::RepeatedPtrField< ::mspb::GetNodeInfo >&
      nodeinfos() const;

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::mspb::GetNodeInfo > nodeinfos_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetNodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetNodeInfo) */ {
 public:
  GetNodeInfo();
  virtual ~GetNodeInfo();

  GetNodeInfo(const GetNodeInfo& from);

  inline GetNodeInfo& operator=(const GetNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetNodeInfo(GetNodeInfo&& from) noexcept
    : GetNodeInfo() {
    *this = ::std::move(from);
  }

  inline GetNodeInfo& operator=(GetNodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNodeInfo& default_instance();

  static inline const GetNodeInfo* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfo*>(
               &_GetNodeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(GetNodeInfo* other);
  friend void swap(GetNodeInfo& a, GetNodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetNodeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GetNodeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetNodeInfo& from);
  void MergeFrom(const GetNodeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetNodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string err = 1;
  void clear_err();
  static const int kErrFieldNumber = 1;
  const ::std::string& err() const;
  void set_err(const ::std::string& value);
  #if LANG_CXX11
  void set_err(::std::string&& value);
  #endif
  void set_err(const char* value);
  void set_err(const char* value, size_t size);
  ::std::string* mutable_err();
  ::std::string* release_err();
  void set_allocated_err(::std::string* err);

  // .basepb.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::basepb::Node& node() const;
  ::basepb::Node* mutable_node();
  ::basepb::Node* release_node();
  void set_allocated_node(::basepb::Node* node);

  // .dspb.NodeInfoResponse info = 3;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 3;
  const ::dspb::NodeInfoResponse& info() const;
  ::dspb::NodeInfoResponse* mutable_info();
  ::dspb::NodeInfoResponse* release_info();
  void set_allocated_info(::dspb::NodeInfoResponse* info);

  // @@protoc_insertion_point(class_scope:mspb.GetNodeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr err_;
  ::basepb::Node* node_;
  ::dspb::NodeInfoResponse* info_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnRequest) */ {
 public:
  GetColumnRequest();
  virtual ~GetColumnRequest();

  GetColumnRequest(const GetColumnRequest& from);

  inline GetColumnRequest& operator=(const GetColumnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnRequest(GetColumnRequest&& from) noexcept
    : GetColumnRequest() {
    *this = ::std::move(from);
  }

  inline GetColumnRequest& operator=(GetColumnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnRequest& default_instance();

  static inline const GetColumnRequest* internal_default_instance() {
    return reinterpret_cast<const GetColumnRequest*>(
               &_GetColumnRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(GetColumnRequest* other);
  friend void swap(GetColumnRequest& a, GetColumnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnRequest& from);
  void MergeFrom(const GetColumnRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string col_name = 5;
  void clear_col_name();
  static const int kColNameFieldNumber = 5;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // uint64 col_id = 4;
  void clear_col_id();
  static const int kColIdFieldNumber = 4;
  ::google::protobuf::uint64 col_id() const;
  void set_col_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  ::google::protobuf::uint64 col_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetColumnResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetColumnResponse) */ {
 public:
  GetColumnResponse();
  virtual ~GetColumnResponse();

  GetColumnResponse(const GetColumnResponse& from);

  inline GetColumnResponse& operator=(const GetColumnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetColumnResponse(GetColumnResponse&& from) noexcept
    : GetColumnResponse() {
    *this = ::std::move(from);
  }

  inline GetColumnResponse& operator=(GetColumnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetColumnResponse& default_instance();

  static inline const GetColumnResponse* internal_default_instance() {
    return reinterpret_cast<const GetColumnResponse*>(
               &_GetColumnResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(GetColumnResponse* other);
  friend void swap(GetColumnResponse& a, GetColumnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetColumnResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetColumnResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetColumnResponse& from);
  void MergeFrom(const GetColumnResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetColumnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Column column = 2;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  const ::basepb::Column& column() const;
  ::basepb::Column* mutable_column();
  ::basepb::Column* release_column();
  void set_allocated_column(::basepb::Column* column);

  // @@protoc_insertion_point(class_scope:mspb.GetColumnResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Column* column_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateDatabaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateDatabaseRequest) */ {
 public:
  CreateDatabaseRequest();
  virtual ~CreateDatabaseRequest();

  CreateDatabaseRequest(const CreateDatabaseRequest& from);

  inline CreateDatabaseRequest& operator=(const CreateDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateDatabaseRequest(CreateDatabaseRequest&& from) noexcept
    : CreateDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseRequest& operator=(CreateDatabaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDatabaseRequest& default_instance();

  static inline const CreateDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseRequest*>(
               &_CreateDatabaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(CreateDatabaseRequest* other);
  friend void swap(CreateDatabaseRequest& a, CreateDatabaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateDatabaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateDatabaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateDatabaseRequest& from);
  void MergeFrom(const CreateDatabaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateDatabaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateDatabaseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateDatabaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateDatabaseResponse) */ {
 public:
  CreateDatabaseResponse();
  virtual ~CreateDatabaseResponse();

  CreateDatabaseResponse(const CreateDatabaseResponse& from);

  inline CreateDatabaseResponse& operator=(const CreateDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateDatabaseResponse(CreateDatabaseResponse&& from) noexcept
    : CreateDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseResponse& operator=(CreateDatabaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDatabaseResponse& default_instance();

  static inline const CreateDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseResponse*>(
               &_CreateDatabaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(CreateDatabaseResponse* other);
  friend void swap(CreateDatabaseResponse& a, CreateDatabaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateDatabaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateDatabaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateDatabaseResponse& from);
  void MergeFrom(const CreateDatabaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateDatabaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.DataBase database = 2;
  bool has_database() const;
  void clear_database();
  static const int kDatabaseFieldNumber = 2;
  const ::basepb::DataBase& database() const;
  ::basepb::DataBase* mutable_database();
  ::basepb::DataBase* release_database();
  void set_allocated_database(::basepb::DataBase* database);

  // @@protoc_insertion_point(class_scope:mspb.CreateDatabaseResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::DataBase* database_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateTableRequest) */ {
 public:
  CreateTableRequest();
  virtual ~CreateTableRequest();

  CreateTableRequest(const CreateTableRequest& from);

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableRequest& default_instance();

  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(CreateTableRequest* other);
  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateTableRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateTableRequest& from);
  void MergeFrom(const CreateTableRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string range_keys = 5;
  int range_keys_size() const;
  void clear_range_keys();
  static const int kRangeKeysFieldNumber = 5;
  const ::std::string& range_keys(int index) const;
  ::std::string* mutable_range_keys(int index);
  void set_range_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_range_keys(int index, ::std::string&& value);
  #endif
  void set_range_keys(int index, const char* value);
  void set_range_keys(int index, const char* value, size_t size);
  ::std::string* add_range_keys();
  void add_range_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_range_keys(::std::string&& value);
  #endif
  void add_range_keys(const char* value);
  void add_range_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& range_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_range_keys();

  // string db_name = 2;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string table_name = 3;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // string properties = 4;
  void clear_properties();
  static const int kPropertiesFieldNumber = 4;
  const ::std::string& properties() const;
  void set_properties(const ::std::string& value);
  #if LANG_CXX11
  void set_properties(::std::string&& value);
  #endif
  void set_properties(const char* value);
  void set_properties(const char* value, size_t size);
  ::std::string* mutable_properties();
  ::std::string* release_properties();
  void set_allocated_properties(::std::string* properties);

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.CreateTableRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> range_keys_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  ::google::protobuf::internal::ArenaStringPtr properties_;
  ::mspb::RequestHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.CreateTableResponse) */ {
 public:
  CreateTableResponse();
  virtual ~CreateTableResponse();

  CreateTableResponse(const CreateTableResponse& from);

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableResponse& default_instance();

  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(CreateTableResponse* other);
  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateTableResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateTableResponse& from);
  void MergeFrom(const CreateTableResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // .basepb.Table table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  const ::basepb::Table& table() const;
  ::basepb::Table* mutable_table();
  ::basepb::Table* release_table();
  void set_allocated_table(::basepb::Table* table);

  // @@protoc_insertion_point(class_scope:mspb.CreateTableResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::ResponseHeader* header_;
  ::basepb::Table* table_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAutoIncIdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetAutoIncIdRequest) */ {
 public:
  GetAutoIncIdRequest();
  virtual ~GetAutoIncIdRequest();

  GetAutoIncIdRequest(const GetAutoIncIdRequest& from);

  inline GetAutoIncIdRequest& operator=(const GetAutoIncIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutoIncIdRequest(GetAutoIncIdRequest&& from) noexcept
    : GetAutoIncIdRequest() {
    *this = ::std::move(from);
  }

  inline GetAutoIncIdRequest& operator=(GetAutoIncIdRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAutoIncIdRequest& default_instance();

  static inline const GetAutoIncIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetAutoIncIdRequest*>(
               &_GetAutoIncIdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(GetAutoIncIdRequest* other);
  friend void swap(GetAutoIncIdRequest& a, GetAutoIncIdRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutoIncIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAutoIncIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAutoIncIdRequest& from);
  void MergeFrom(const GetAutoIncIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAutoIncIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::RequestHeader& header() const;
  ::mspb::RequestHeader* mutable_header();
  ::mspb::RequestHeader* release_header();
  void set_allocated_header(::mspb::RequestHeader* header);

  // uint64 db_id = 2;
  void clear_db_id();
  static const int kDbIdFieldNumber = 2;
  ::google::protobuf::uint64 db_id() const;
  void set_db_id(::google::protobuf::uint64 value);

  // uint64 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::uint64 table_id() const;
  void set_table_id(::google::protobuf::uint64 value);

  // uint32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.GetAutoIncIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::RequestHeader* header_;
  ::google::protobuf::uint64 db_id_;
  ::google::protobuf::uint64 table_id_;
  ::google::protobuf::uint32 size_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAutoIncIdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.GetAutoIncIdResponse) */ {
 public:
  GetAutoIncIdResponse();
  virtual ~GetAutoIncIdResponse();

  GetAutoIncIdResponse(const GetAutoIncIdResponse& from);

  inline GetAutoIncIdResponse& operator=(const GetAutoIncIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAutoIncIdResponse(GetAutoIncIdResponse&& from) noexcept
    : GetAutoIncIdResponse() {
    *this = ::std::move(from);
  }

  inline GetAutoIncIdResponse& operator=(GetAutoIncIdResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAutoIncIdResponse& default_instance();

  static inline const GetAutoIncIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetAutoIncIdResponse*>(
               &_GetAutoIncIdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(GetAutoIncIdResponse* other);
  friend void swap(GetAutoIncIdResponse& a, GetAutoIncIdResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAutoIncIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAutoIncIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAutoIncIdResponse& from);
  void MergeFrom(const GetAutoIncIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAutoIncIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 ids = 2;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 2;
  ::google::protobuf::uint64 ids(int index) const;
  void set_ids(int index, ::google::protobuf::uint64 value);
  void add_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ids();

  // .mspb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::mspb::ResponseHeader& header() const;
  ::mspb::ResponseHeader* mutable_header();
  ::mspb::ResponseHeader* release_header();
  void set_allocated_header(::mspb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:mspb.GetAutoIncIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ids_;
  mutable int _ids_cached_byte_size_;
  ::mspb::ResponseHeader* header_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.RequestHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .mspb.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::mspb::Error& error() const;
  ::mspb::Error* mutable_error();
  ::mspb::Error* release_error();
  void set_allocated_error(::mspb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mspb.ResponseHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::mspb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mspb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mspb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct protobuf_mspb_2fmspb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RangeHeartbeatRequest

// .mspb.RequestHeader header = 1;
inline bool RangeHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& RangeHeartbeatRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* RangeHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* RangeHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.header)
}

// .basepb.Range range = 2;
inline bool RangeHeartbeatRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void RangeHeartbeatRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::basepb::Range& RangeHeartbeatRequest::range() const {
  const ::basepb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Range*>(
      &::basepb::_Range_default_instance_);
}
inline ::basepb::Range* RangeHeartbeatRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::basepb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.range)
  return range_;
}
inline ::basepb::Range* RangeHeartbeatRequest::release_range() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatRequest.range)
  
  ::basepb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void RangeHeartbeatRequest::set_allocated_range(::basepb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatRequest.range)
}

// uint64 term = 3;
inline void RangeHeartbeatRequest::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeHeartbeatRequest::term() const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.term)
  return term_;
}
inline void RangeHeartbeatRequest::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeHeartbeatRequest.term)
}

// repeated .basepb.PeerStatus peers_status = 4;
inline int RangeHeartbeatRequest::peers_status_size() const {
  return peers_status_.size();
}
inline void RangeHeartbeatRequest::clear_peers_status() {
  peers_status_.Clear();
}
inline const ::basepb::PeerStatus& RangeHeartbeatRequest::peers_status(int index) const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Get(index);
}
inline ::basepb::PeerStatus* RangeHeartbeatRequest::mutable_peers_status(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Mutable(index);
}
inline ::basepb::PeerStatus* RangeHeartbeatRequest::add_peers_status() {
  // @@protoc_insertion_point(field_add:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::PeerStatus >*
RangeHeartbeatRequest::mutable_peers_status() {
  // @@protoc_insertion_point(field_mutable_list:mspb.RangeHeartbeatRequest.peers_status)
  return &peers_status_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::PeerStatus >&
RangeHeartbeatRequest::peers_status() const {
  // @@protoc_insertion_point(field_list:mspb.RangeHeartbeatRequest.peers_status)
  return peers_status_;
}

// -------------------------------------------------------------------

// RangeHeartbeatResponse

// .mspb.ResponseHeader header = 1;
inline bool RangeHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& RangeHeartbeatResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* RangeHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* RangeHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.header)
}

// uint64 range_id = 2;
inline void RangeHeartbeatResponse::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeHeartbeatResponse::range_id() const {
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.range_id)
  return range_id_;
}
inline void RangeHeartbeatResponse::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.RangeHeartbeatResponse.range_id)
}

// .basepb.RangeEpoch epoch = 3;
inline bool RangeHeartbeatResponse::has_epoch() const {
  return this != internal_default_instance() && epoch_ != NULL;
}
inline void RangeHeartbeatResponse::clear_epoch() {
  if (GetArenaNoVirtual() == NULL && epoch_ != NULL) delete epoch_;
  epoch_ = NULL;
}
inline const ::basepb::RangeEpoch& RangeHeartbeatResponse::epoch() const {
  const ::basepb::RangeEpoch* p = epoch_;
  // @@protoc_insertion_point(field_get:mspb.RangeHeartbeatResponse.epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::RangeEpoch*>(
      &::basepb::_RangeEpoch_default_instance_);
}
inline ::basepb::RangeEpoch* RangeHeartbeatResponse::mutable_epoch() {
  
  if (epoch_ == NULL) {
    epoch_ = new ::basepb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RangeHeartbeatResponse.epoch)
  return epoch_;
}
inline ::basepb::RangeEpoch* RangeHeartbeatResponse::release_epoch() {
  // @@protoc_insertion_point(field_release:mspb.RangeHeartbeatResponse.epoch)
  
  ::basepb::RangeEpoch* temp = epoch_;
  epoch_ = NULL;
  return temp;
}
inline void RangeHeartbeatResponse::set_allocated_epoch(::basepb::RangeEpoch* epoch) {
  delete epoch_;
  epoch_ = epoch;
  if (epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RangeHeartbeatResponse.epoch)
}

// -------------------------------------------------------------------

// NodeHeartbeatRequest

// .mspb.RequestHeader header = 1;
inline bool NodeHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& NodeHeartbeatRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* NodeHeartbeatRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeHeartbeatRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* NodeHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeHeartbeatRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeHeartbeatRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeHeartbeatRequest.header)
}

// uint64 node_id = 2;
inline void NodeHeartbeatRequest::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeHeartbeatRequest::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatRequest.node_id)
  return node_id_;
}
inline void NodeHeartbeatRequest::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatRequest.node_id)
}

// -------------------------------------------------------------------

// NodeHeartbeatResponse

// .mspb.ResponseHeader header = 1;
inline bool NodeHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NodeHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& NodeHeartbeatResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* NodeHeartbeatResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.NodeHeartbeatResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* NodeHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.NodeHeartbeatResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NodeHeartbeatResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.NodeHeartbeatResponse.header)
}

// uint64 node_id = 2;
inline void NodeHeartbeatResponse::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NodeHeartbeatResponse::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.NodeHeartbeatResponse.node_id)
  return node_id_;
}
inline void NodeHeartbeatResponse::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.NodeHeartbeatResponse.node_id)
}

// -------------------------------------------------------------------

// AskSplitRequest

// .mspb.RequestHeader header = 1;
inline bool AskSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& AskSplitRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* AskSplitRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* AskSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AskSplitRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.header)
}

// .basepb.Range range = 2;
inline bool AskSplitRequest::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void AskSplitRequest::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::basepb::Range& AskSplitRequest::range() const {
  const ::basepb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.range)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Range*>(
      &::basepb::_Range_default_instance_);
}
inline ::basepb::Range* AskSplitRequest::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::basepb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.range)
  return range_;
}
inline ::basepb::Range* AskSplitRequest::release_range() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.range)
  
  ::basepb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void AskSplitRequest::set_allocated_range(::basepb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.range)
}

// bytes split_key = 3;
inline void AskSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AskSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.split_key)
  return split_key_.GetNoArena();
}
inline void AskSplitRequest::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitRequest.split_key)
}
#if LANG_CXX11
inline void AskSplitRequest::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.AskSplitRequest.split_key)
}
#endif
inline void AskSplitRequest::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.AskSplitRequest.split_key)
}
inline void AskSplitRequest::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.AskSplitRequest.split_key)
}
inline ::std::string* AskSplitRequest::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskSplitRequest::release_split_key() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitRequest.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitRequest.split_key)
}

// bool force = 4;
inline void AskSplitRequest::clear_force() {
  force_ = false;
}
inline bool AskSplitRequest::force() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitRequest.force)
  return force_;
}
inline void AskSplitRequest::set_force(bool value) {
  
  force_ = value;
  // @@protoc_insertion_point(field_set:mspb.AskSplitRequest.force)
}

// -------------------------------------------------------------------

// AskSplitResponse

// .mspb.ResponseHeader header = 1;
inline bool AskSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void AskSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& AskSplitResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* AskSplitResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* AskSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AskSplitResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.header)
}

// .basepb.Range range = 2;
inline bool AskSplitResponse::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void AskSplitResponse::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::basepb::Range& AskSplitResponse::range() const {
  const ::basepb::Range* p = range_;
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.range)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Range*>(
      &::basepb::_Range_default_instance_);
}
inline ::basepb::Range* AskSplitResponse::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::basepb::Range;
  }
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.range)
  return range_;
}
inline ::basepb::Range* AskSplitResponse::release_range() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.range)
  
  ::basepb::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void AskSplitResponse::set_allocated_range(::basepb::Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.range)
}

// uint64 new_range_id = 3;
inline void AskSplitResponse::clear_new_range_id() {
  new_range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AskSplitResponse::new_range_id() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.new_range_id)
  return new_range_id_;
}
inline void AskSplitResponse::set_new_range_id(::google::protobuf::uint64 value) {
  
  new_range_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.new_range_id)
}

// repeated uint64 new_peer_ids = 4;
inline int AskSplitResponse::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void AskSplitResponse::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::google::protobuf::uint64 AskSplitResponse::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void AskSplitResponse::set_new_peer_ids(int index, ::google::protobuf::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.new_peer_ids)
}
inline void AskSplitResponse::add_new_peer_ids(::google::protobuf::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.AskSplitResponse.new_peer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AskSplitResponse::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:mspb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AskSplitResponse::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:mspb.AskSplitResponse.new_peer_ids)
  return &new_peer_ids_;
}

// bytes split_key = 5;
inline void AskSplitResponse::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AskSplitResponse::split_key() const {
  // @@protoc_insertion_point(field_get:mspb.AskSplitResponse.split_key)
  return split_key_.GetNoArena();
}
inline void AskSplitResponse::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.AskSplitResponse.split_key)
}
#if LANG_CXX11
inline void AskSplitResponse::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.AskSplitResponse.split_key)
}
#endif
inline void AskSplitResponse::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.AskSplitResponse.split_key)
}
inline void AskSplitResponse::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.AskSplitResponse.split_key)
}
inline ::std::string* AskSplitResponse::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.AskSplitResponse.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskSplitResponse::release_split_key() {
  // @@protoc_insertion_point(field_release:mspb.AskSplitResponse.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskSplitResponse::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:mspb.AskSplitResponse.split_key)
}

// -------------------------------------------------------------------

// RegisterNodeRequest

// .mspb.RequestHeader header = 1;
inline bool RegisterNodeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegisterNodeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& RegisterNodeRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* RegisterNodeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RegisterNodeRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* RegisterNodeRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RegisterNodeRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RegisterNodeRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RegisterNodeRequest.header)
}

// uint32 server_port = 2;
inline void RegisterNodeRequest::clear_server_port() {
  server_port_ = 0u;
}
inline ::google::protobuf::uint32 RegisterNodeRequest::server_port() const {
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeRequest.server_port)
  return server_port_;
}
inline void RegisterNodeRequest::set_server_port(::google::protobuf::uint32 value) {
  
  server_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.RegisterNodeRequest.server_port)
}

// uint32 raft_port = 3;
inline void RegisterNodeRequest::clear_raft_port() {
  raft_port_ = 0u;
}
inline ::google::protobuf::uint32 RegisterNodeRequest::raft_port() const {
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeRequest.raft_port)
  return raft_port_;
}
inline void RegisterNodeRequest::set_raft_port(::google::protobuf::uint32 value) {
  
  raft_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.RegisterNodeRequest.raft_port)
}

// uint32 admin_port = 4;
inline void RegisterNodeRequest::clear_admin_port() {
  admin_port_ = 0u;
}
inline ::google::protobuf::uint32 RegisterNodeRequest::admin_port() const {
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeRequest.admin_port)
  return admin_port_;
}
inline void RegisterNodeRequest::set_admin_port(::google::protobuf::uint32 value) {
  
  admin_port_ = value;
  // @@protoc_insertion_point(field_set:mspb.RegisterNodeRequest.admin_port)
}

// string version = 5;
inline void RegisterNodeRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterNodeRequest::version() const {
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeRequest.version)
  return version_.GetNoArena();
}
inline void RegisterNodeRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.RegisterNodeRequest.version)
}
#if LANG_CXX11
inline void RegisterNodeRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.RegisterNodeRequest.version)
}
#endif
inline void RegisterNodeRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.RegisterNodeRequest.version)
}
inline void RegisterNodeRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.RegisterNodeRequest.version)
}
inline ::std::string* RegisterNodeRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:mspb.RegisterNodeRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterNodeRequest::release_version() {
  // @@protoc_insertion_point(field_release:mspb.RegisterNodeRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterNodeRequest::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mspb.RegisterNodeRequest.version)
}

// -------------------------------------------------------------------

// RegisterNodeResponse

// .mspb.ResponseHeader header = 1;
inline bool RegisterNodeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RegisterNodeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& RegisterNodeResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* RegisterNodeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.RegisterNodeResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* RegisterNodeResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.RegisterNodeResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RegisterNodeResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.RegisterNodeResponse.header)
}

// uint64 node_id = 2;
inline void RegisterNodeResponse::clear_node_id() {
  node_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegisterNodeResponse::node_id() const {
  // @@protoc_insertion_point(field_get:mspb.RegisterNodeResponse.node_id)
  return node_id_;
}
inline void RegisterNodeResponse::set_node_id(::google::protobuf::uint64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.RegisterNodeResponse.node_id)
}

// -------------------------------------------------------------------

// GetRouteRequest

// .mspb.RequestHeader header = 1;
inline bool GetRouteRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRouteRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetRouteRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetRouteRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetRouteRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRouteRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteRequest.header)
}

// uint64 db_id = 2;
inline void GetRouteRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRouteRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.db_id)
  return db_id_;
}
inline void GetRouteRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.db_id)
}

// uint64 table_id = 3;
inline void GetRouteRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRouteRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.table_id)
  return table_id_;
}
inline void GetRouteRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.table_id)
}

// bytes key = 4;
inline void GetRouteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRouteRequest::key() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.key)
  return key_.GetNoArena();
}
inline void GetRouteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.key)
}
#if LANG_CXX11
inline void GetRouteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetRouteRequest.key)
}
#endif
inline void GetRouteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetRouteRequest.key)
}
inline void GetRouteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetRouteRequest.key)
}
inline ::std::string* GetRouteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRouteRequest::release_key() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRouteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteRequest.key)
}

// uint32 max = 5;
inline void GetRouteRequest::clear_max() {
  max_ = 0u;
}
inline ::google::protobuf::uint32 GetRouteRequest::max() const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteRequest.max)
  return max_;
}
inline void GetRouteRequest::set_max(::google::protobuf::uint32 value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetRouteRequest.max)
}

// -------------------------------------------------------------------

// GetRouteResponse

// .mspb.ResponseHeader header = 1;
inline bool GetRouteResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetRouteResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetRouteResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetRouteResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetRouteResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetRouteResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetRouteResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRouteResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetRouteResponse.header)
}

// repeated .basepb.Range routes = 2;
inline int GetRouteResponse::routes_size() const {
  return routes_.size();
}
inline void GetRouteResponse::clear_routes() {
  routes_.Clear();
}
inline const ::basepb::Range& GetRouteResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetRouteResponse.routes)
  return routes_.Get(index);
}
inline ::basepb::Range* GetRouteResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetRouteResponse.routes)
  return routes_.Mutable(index);
}
inline ::basepb::Range* GetRouteResponse::add_routes() {
  // @@protoc_insertion_point(field_add:mspb.GetRouteResponse.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::Range >*
GetRouteResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetRouteResponse.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::Range >&
GetRouteResponse::routes() const {
  // @@protoc_insertion_point(field_list:mspb.GetRouteResponse.routes)
  return routes_;
}

// -------------------------------------------------------------------

// GetNodesRequest

// .mspb.RequestHeader header = 1;
inline bool GetNodesRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodesRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetNodesRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodesRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetNodesRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodesRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetNodesRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodesRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodesRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodesRequest.header)
}

// -------------------------------------------------------------------

// GetNodesResponse

// .mspb.ResponseHeader header = 1;
inline bool GetNodesResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodesResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetNodesResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodesResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetNodesResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodesResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetNodesResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodesResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodesResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodesResponse.header)
}

// repeated .basepb.Node nodes = 2;
inline int GetNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void GetNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::basepb::Node& GetNodesResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetNodesResponse.nodes)
  return nodes_.Get(index);
}
inline ::basepb::Node* GetNodesResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetNodesResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::basepb::Node* GetNodesResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:mspb.GetNodesResponse.nodes)
  return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::Node >*
GetNodesResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetNodesResponse.nodes)
  return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::Node >&
GetNodesResponse::nodes() const {
  // @@protoc_insertion_point(field_list:mspb.GetNodesResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetNodeRequest

// .mspb.RequestHeader header = 1;
inline bool GetNodeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetNodeRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetNodeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetNodeRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeRequest.header)
}

// uint64 id = 2;
inline void GetNodeRequest::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetNodeRequest::id() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeRequest.id)
  return id_;
}
inline void GetNodeRequest::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetNodeRequest.id)
}

// -------------------------------------------------------------------

// GetNodeResponse

// .mspb.ResponseHeader header = 1;
inline bool GetNodeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetNodeResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetNodeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetNodeResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeResponse.header)
}

// .basepb.Node node = 2;
inline bool GetNodeResponse::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void GetNodeResponse::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::basepb::Node& GetNodeResponse::node() const {
  const ::basepb::Node* p = node_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeResponse.node)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Node*>(
      &::basepb::_Node_default_instance_);
}
inline ::basepb::Node* GetNodeResponse::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::basepb::Node;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeResponse.node)
  return node_;
}
inline ::basepb::Node* GetNodeResponse::release_node() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeResponse.node)
  
  ::basepb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void GetNodeResponse::set_allocated_node(::basepb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeResponse.node)
}

// -------------------------------------------------------------------

// DelDatabaseRequest

// .mspb.RequestHeader header = 1;
inline bool DelDatabaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DelDatabaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& DelDatabaseRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.DelDatabaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* DelDatabaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.DelDatabaseRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* DelDatabaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.DelDatabaseRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DelDatabaseRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.DelDatabaseRequest.header)
}

// uint64 id = 2;
inline void DelDatabaseRequest::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DelDatabaseRequest::id() const {
  // @@protoc_insertion_point(field_get:mspb.DelDatabaseRequest.id)
  return id_;
}
inline void DelDatabaseRequest::set_id(::google::protobuf::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:mspb.DelDatabaseRequest.id)
}

// string name = 3;
inline void DelDatabaseRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DelDatabaseRequest::name() const {
  // @@protoc_insertion_point(field_get:mspb.DelDatabaseRequest.name)
  return name_.GetNoArena();
}
inline void DelDatabaseRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.DelDatabaseRequest.name)
}
#if LANG_CXX11
inline void DelDatabaseRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.DelDatabaseRequest.name)
}
#endif
inline void DelDatabaseRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.DelDatabaseRequest.name)
}
inline void DelDatabaseRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.DelDatabaseRequest.name)
}
inline ::std::string* DelDatabaseRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.DelDatabaseRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DelDatabaseRequest::release_name() {
  // @@protoc_insertion_point(field_release:mspb.DelDatabaseRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelDatabaseRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mspb.DelDatabaseRequest.name)
}

// -------------------------------------------------------------------

// DelDatabaseResponse

// .mspb.ResponseHeader header = 1;
inline bool DelDatabaseResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DelDatabaseResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& DelDatabaseResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.DelDatabaseResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* DelDatabaseResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.DelDatabaseResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* DelDatabaseResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.DelDatabaseResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DelDatabaseResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.DelDatabaseResponse.header)
}

// -------------------------------------------------------------------

// GetDBRequest

// .mspb.RequestHeader header = 1;
inline bool GetDBRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetDBRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetDBRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetDBRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetDBRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetDBRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetDBRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetDBRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBRequest.header)
}

// string name = 2;
inline void GetDBRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetDBRequest::name() const {
  // @@protoc_insertion_point(field_get:mspb.GetDBRequest.name)
  return name_.GetNoArena();
}
inline void GetDBRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetDBRequest.name)
}
#if LANG_CXX11
inline void GetDBRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetDBRequest.name)
}
#endif
inline void GetDBRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetDBRequest.name)
}
inline void GetDBRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetDBRequest.name)
}
inline ::std::string* GetDBRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetDBRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetDBRequest::release_name() {
  // @@protoc_insertion_point(field_release:mspb.GetDBRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetDBRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBRequest.name)
}

// -------------------------------------------------------------------

// GetDBResponse

// .mspb.ResponseHeader header = 1;
inline bool GetDBResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetDBResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetDBResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetDBResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetDBResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetDBResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetDBResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetDBResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBResponse.header)
}

// .basepb.DataBase db = 2;
inline bool GetDBResponse::has_db() const {
  return this != internal_default_instance() && db_ != NULL;
}
inline void GetDBResponse::clear_db() {
  if (GetArenaNoVirtual() == NULL && db_ != NULL) delete db_;
  db_ = NULL;
}
inline const ::basepb::DataBase& GetDBResponse::db() const {
  const ::basepb::DataBase* p = db_;
  // @@protoc_insertion_point(field_get:mspb.GetDBResponse.db)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::DataBase*>(
      &::basepb::_DataBase_default_instance_);
}
inline ::basepb::DataBase* GetDBResponse::mutable_db() {
  
  if (db_ == NULL) {
    db_ = new ::basepb::DataBase;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBResponse.db)
  return db_;
}
inline ::basepb::DataBase* GetDBResponse::release_db() {
  // @@protoc_insertion_point(field_release:mspb.GetDBResponse.db)
  
  ::basepb::DataBase* temp = db_;
  db_ = NULL;
  return temp;
}
inline void GetDBResponse::set_allocated_db(::basepb::DataBase* db) {
  delete db_;
  db_ = db;
  if (db) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBResponse.db)
}

// -------------------------------------------------------------------

// GetDBsResponse

// .mspb.ResponseHeader header = 1;
inline bool GetDBsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetDBsResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetDBsResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetDBsResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetDBsResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetDBsResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetDBsResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetDBsResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetDBsResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetDBsResponse.header)
}

// repeated .basepb.DataBase dbs = 2;
inline int GetDBsResponse::dbs_size() const {
  return dbs_.size();
}
inline void GetDBsResponse::clear_dbs() {
  dbs_.Clear();
}
inline const ::basepb::DataBase& GetDBsResponse::dbs(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetDBsResponse.dbs)
  return dbs_.Get(index);
}
inline ::basepb::DataBase* GetDBsResponse::mutable_dbs(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetDBsResponse.dbs)
  return dbs_.Mutable(index);
}
inline ::basepb::DataBase* GetDBsResponse::add_dbs() {
  // @@protoc_insertion_point(field_add:mspb.GetDBsResponse.dbs)
  return dbs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::DataBase >*
GetDBsResponse::mutable_dbs() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetDBsResponse.dbs)
  return &dbs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::DataBase >&
GetDBsResponse::dbs() const {
  // @@protoc_insertion_point(field_list:mspb.GetDBsResponse.dbs)
  return dbs_;
}

// -------------------------------------------------------------------

// DelTableRequest

// .mspb.RequestHeader header = 1;
inline bool DelTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DelTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& DelTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.DelTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* DelTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.DelTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* DelTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.DelTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DelTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.DelTableRequest.header)
}

// uint64 db_id = 2;
inline void DelTableRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DelTableRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.DelTableRequest.db_id)
  return db_id_;
}
inline void DelTableRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.DelTableRequest.db_id)
}

// string db_name = 3;
inline void DelTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DelTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.DelTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void DelTableRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.DelTableRequest.db_name)
}
#if LANG_CXX11
inline void DelTableRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.DelTableRequest.db_name)
}
#endif
inline void DelTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.DelTableRequest.db_name)
}
inline void DelTableRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.DelTableRequest.db_name)
}
inline ::std::string* DelTableRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.DelTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DelTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.DelTableRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.DelTableRequest.db_name)
}

// uint64 table_id = 4;
inline void DelTableRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 DelTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.DelTableRequest.table_id)
  return table_id_;
}
inline void DelTableRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.DelTableRequest.table_id)
}

// string table_name = 5;
inline void DelTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DelTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:mspb.DelTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void DelTableRequest::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.DelTableRequest.table_name)
}
#if LANG_CXX11
inline void DelTableRequest::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.DelTableRequest.table_name)
}
#endif
inline void DelTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.DelTableRequest.table_name)
}
inline void DelTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.DelTableRequest.table_name)
}
inline ::std::string* DelTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.DelTableRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DelTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:mspb.DelTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelTableRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.DelTableRequest.table_name)
}

// -------------------------------------------------------------------

// DelTableResponse

// .mspb.ResponseHeader header = 1;
inline bool DelTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void DelTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& DelTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.DelTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* DelTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.DelTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* DelTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.DelTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DelTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.DelTableResponse.header)
}

// .basepb.Table table = 2;
inline bool DelTableResponse::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline void DelTableResponse::clear_table() {
  if (GetArenaNoVirtual() == NULL && table_ != NULL) delete table_;
  table_ = NULL;
}
inline const ::basepb::Table& DelTableResponse::table() const {
  const ::basepb::Table* p = table_;
  // @@protoc_insertion_point(field_get:mspb.DelTableResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Table*>(
      &::basepb::_Table_default_instance_);
}
inline ::basepb::Table* DelTableResponse::mutable_table() {
  
  if (table_ == NULL) {
    table_ = new ::basepb::Table;
  }
  // @@protoc_insertion_point(field_mutable:mspb.DelTableResponse.table)
  return table_;
}
inline ::basepb::Table* DelTableResponse::release_table() {
  // @@protoc_insertion_point(field_release:mspb.DelTableResponse.table)
  
  ::basepb::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void DelTableResponse::set_allocated_table(::basepb::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.DelTableResponse.table)
}

// -------------------------------------------------------------------

// GetTableRequest

// .mspb.RequestHeader header = 1;
inline bool GetTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.header)
}

// uint64 db_id = 2;
inline void GetTableRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetTableRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.db_id)
  return db_id_;
}
inline void GetTableRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.db_id)
}

// string db_name = 3;
inline void GetTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void GetTableRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.db_name)
}
#if LANG_CXX11
inline void GetTableRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetTableRequest.db_name)
}
#endif
inline void GetTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetTableRequest.db_name)
}
inline void GetTableRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetTableRequest.db_name)
}
inline ::std::string* GetTableRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.db_name)
}

// uint64 table_id = 4;
inline void GetTableRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.table_id)
  return table_id_;
}
inline void GetTableRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.table_id)
}

// string table_name = 5;
inline void GetTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void GetTableRequest::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetTableRequest.table_name)
}
#if LANG_CXX11
inline void GetTableRequest::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetTableRequest.table_name)
}
#endif
inline void GetTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetTableRequest.table_name)
}
inline void GetTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetTableRequest.table_name)
}
inline ::std::string* GetTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetTableRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:mspb.GetTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTableRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableRequest.table_name)
}

// -------------------------------------------------------------------

// GetTableResponse

// .mspb.ResponseHeader header = 1;
inline bool GetTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableResponse.header)
}

// .basepb.Table table = 2;
inline bool GetTableResponse::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline void GetTableResponse::clear_table() {
  if (GetArenaNoVirtual() == NULL && table_ != NULL) delete table_;
  table_ = NULL;
}
inline const ::basepb::Table& GetTableResponse::table() const {
  const ::basepb::Table* p = table_;
  // @@protoc_insertion_point(field_get:mspb.GetTableResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Table*>(
      &::basepb::_Table_default_instance_);
}
inline ::basepb::Table* GetTableResponse::mutable_table() {
  
  if (table_ == NULL) {
    table_ = new ::basepb::Table;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTableResponse.table)
  return table_;
}
inline ::basepb::Table* GetTableResponse::release_table() {
  // @@protoc_insertion_point(field_release:mspb.GetTableResponse.table)
  
  ::basepb::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void GetTableResponse::set_allocated_table(::basepb::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTableResponse.table)
}

// -------------------------------------------------------------------

// GetTablesRequest

// .mspb.RequestHeader header = 1;
inline bool GetTablesRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTablesRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetTablesRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTablesRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetTablesRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTablesRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetTablesRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTablesRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTablesRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTablesRequest.header)
}

// uint64 db_id = 2;
inline void GetTablesRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetTablesRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetTablesRequest.db_id)
  return db_id_;
}
inline void GetTablesRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetTablesRequest.db_id)
}

// string db_name = 3;
inline void GetTablesRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetTablesRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetTablesRequest.db_name)
  return db_name_.GetNoArena();
}
inline void GetTablesRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetTablesRequest.db_name)
}
#if LANG_CXX11
inline void GetTablesRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetTablesRequest.db_name)
}
#endif
inline void GetTablesRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetTablesRequest.db_name)
}
inline void GetTablesRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetTablesRequest.db_name)
}
inline ::std::string* GetTablesRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetTablesRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTablesRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.GetTablesRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTablesRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTablesRequest.db_name)
}

// -------------------------------------------------------------------

// GetTablesResponse

// .mspb.ResponseHeader header = 1;
inline bool GetTablesResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetTablesResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetTablesResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetTablesResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetTablesResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetTablesResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetTablesResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetTablesResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetTablesResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetTablesResponse.header)
}

// repeated .basepb.Table tables = 2;
inline int GetTablesResponse::tables_size() const {
  return tables_.size();
}
inline void GetTablesResponse::clear_tables() {
  tables_.Clear();
}
inline const ::basepb::Table& GetTablesResponse::tables(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetTablesResponse.tables)
  return tables_.Get(index);
}
inline ::basepb::Table* GetTablesResponse::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetTablesResponse.tables)
  return tables_.Mutable(index);
}
inline ::basepb::Table* GetTablesResponse::add_tables() {
  // @@protoc_insertion_point(field_add:mspb.GetTablesResponse.tables)
  return tables_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::Table >*
GetTablesResponse::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetTablesResponse.tables)
  return &tables_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::Table >&
GetTablesResponse::tables() const {
  // @@protoc_insertion_point(field_list:mspb.GetTablesResponse.tables)
  return tables_;
}

// -------------------------------------------------------------------

// GetColumnsRequest

// .mspb.RequestHeader header = 1;
inline bool GetColumnsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetColumnsRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetColumnsRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetColumnsRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnsRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnsRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnsRequest.header)
}

// uint64 db_id = 2;
inline void GetColumnsRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnsRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.db_id)
  return db_id_;
}
inline void GetColumnsRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnsRequest.db_id)
}

// uint64 table_id = 3;
inline void GetColumnsRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnsRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsRequest.table_id)
  return table_id_;
}
inline void GetColumnsRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnsRequest.table_id)
}

// -------------------------------------------------------------------

// GetColumnsResponse

// .mspb.ResponseHeader header = 1;
inline bool GetColumnsResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnsResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetColumnsResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnsResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetColumnsResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetColumnsResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnsResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnsResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnsResponse.header)
}

// repeated .basepb.Column columns = 2;
inline int GetColumnsResponse::columns_size() const {
  return columns_.size();
}
inline void GetColumnsResponse::clear_columns() {
  columns_.Clear();
}
inline const ::basepb::Column& GetColumnsResponse::columns(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnsResponse.columns)
  return columns_.Get(index);
}
inline ::basepb::Column* GetColumnsResponse::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnsResponse.columns)
  return columns_.Mutable(index);
}
inline ::basepb::Column* GetColumnsResponse::add_columns() {
  // @@protoc_insertion_point(field_add:mspb.GetColumnsResponse.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::basepb::Column >*
GetColumnsResponse::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetColumnsResponse.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::basepb::Column >&
GetColumnsResponse::columns() const {
  // @@protoc_insertion_point(field_list:mspb.GetColumnsResponse.columns)
  return columns_;
}

// -------------------------------------------------------------------

// GetNodeInfoRequest

// .mspb.RequestHeader header = 1;
inline bool GetNodeInfoRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeInfoRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetNodeInfoRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfoRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetNodeInfoRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfoRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetNodeInfoRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeInfoRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeInfoRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeInfoRequest.header)
}

// -------------------------------------------------------------------

// GetNodeInfoResponse

// .mspb.ResponseHeader header = 1;
inline bool GetNodeInfoResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetNodeInfoResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetNodeInfoResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfoResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetNodeInfoResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfoResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetNodeInfoResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeInfoResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetNodeInfoResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeInfoResponse.header)
}

// repeated .mspb.GetNodeInfo nodeInfos = 2;
inline int GetNodeInfoResponse::nodeinfos_size() const {
  return nodeinfos_.size();
}
inline void GetNodeInfoResponse::clear_nodeinfos() {
  nodeinfos_.Clear();
}
inline const ::mspb::GetNodeInfo& GetNodeInfoResponse::nodeinfos(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfoResponse.nodeInfos)
  return nodeinfos_.Get(index);
}
inline ::mspb::GetNodeInfo* GetNodeInfoResponse::mutable_nodeinfos(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfoResponse.nodeInfos)
  return nodeinfos_.Mutable(index);
}
inline ::mspb::GetNodeInfo* GetNodeInfoResponse::add_nodeinfos() {
  // @@protoc_insertion_point(field_add:mspb.GetNodeInfoResponse.nodeInfos)
  return nodeinfos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mspb::GetNodeInfo >*
GetNodeInfoResponse::mutable_nodeinfos() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetNodeInfoResponse.nodeInfos)
  return &nodeinfos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mspb::GetNodeInfo >&
GetNodeInfoResponse::nodeinfos() const {
  // @@protoc_insertion_point(field_list:mspb.GetNodeInfoResponse.nodeInfos)
  return nodeinfos_;
}

// -------------------------------------------------------------------

// GetNodeInfo

// string err = 1;
inline void GetNodeInfo::clear_err() {
  err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetNodeInfo::err() const {
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfo.err)
  return err_.GetNoArena();
}
inline void GetNodeInfo::set_err(const ::std::string& value) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetNodeInfo.err)
}
#if LANG_CXX11
inline void GetNodeInfo::set_err(::std::string&& value) {
  
  err_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetNodeInfo.err)
}
#endif
inline void GetNodeInfo::set_err(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetNodeInfo.err)
}
inline void GetNodeInfo::set_err(const char* value, size_t size) {
  
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetNodeInfo.err)
}
inline ::std::string* GetNodeInfo::mutable_err() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfo.err)
  return err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetNodeInfo::release_err() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeInfo.err)
  
  return err_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetNodeInfo::set_allocated_err(::std::string* err) {
  if (err != NULL) {
    
  } else {
    
  }
  err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeInfo.err)
}

// .basepb.Node node = 2;
inline bool GetNodeInfo::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void GetNodeInfo::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::basepb::Node& GetNodeInfo::node() const {
  const ::basepb::Node* p = node_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfo.node)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Node*>(
      &::basepb::_Node_default_instance_);
}
inline ::basepb::Node* GetNodeInfo::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::basepb::Node;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfo.node)
  return node_;
}
inline ::basepb::Node* GetNodeInfo::release_node() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeInfo.node)
  
  ::basepb::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void GetNodeInfo::set_allocated_node(::basepb::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeInfo.node)
}

// .dspb.NodeInfoResponse info = 3;
inline bool GetNodeInfo::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void GetNodeInfo::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::dspb::NodeInfoResponse& GetNodeInfo::info() const {
  const ::dspb::NodeInfoResponse* p = info_;
  // @@protoc_insertion_point(field_get:mspb.GetNodeInfo.info)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::NodeInfoResponse*>(
      &::dspb::_NodeInfoResponse_default_instance_);
}
inline ::dspb::NodeInfoResponse* GetNodeInfo::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::dspb::NodeInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetNodeInfo.info)
  return info_;
}
inline ::dspb::NodeInfoResponse* GetNodeInfo::release_info() {
  // @@protoc_insertion_point(field_release:mspb.GetNodeInfo.info)
  
  ::dspb::NodeInfoResponse* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GetNodeInfo::set_allocated_info(::dspb::NodeInfoResponse* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetNodeInfo.info)
}

// -------------------------------------------------------------------

// GetColumnRequest

// .mspb.RequestHeader header = 1;
inline bool GetColumnRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetColumnRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetColumnRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetColumnRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnRequest.header)
}

// uint64 db_id = 2;
inline void GetColumnRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnRequest.db_id)
  return db_id_;
}
inline void GetColumnRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnRequest.db_id)
}

// uint64 table_id = 3;
inline void GetColumnRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnRequest.table_id)
  return table_id_;
}
inline void GetColumnRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnRequest.table_id)
}

// uint64 col_id = 4;
inline void GetColumnRequest::clear_col_id() {
  col_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetColumnRequest::col_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnRequest.col_id)
  return col_id_;
}
inline void GetColumnRequest::set_col_id(::google::protobuf::uint64 value) {
  
  col_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetColumnRequest.col_id)
}

// string col_name = 5;
inline void GetColumnRequest::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetColumnRequest::col_name() const {
  // @@protoc_insertion_point(field_get:mspb.GetColumnRequest.col_name)
  return col_name_.GetNoArena();
}
inline void GetColumnRequest::set_col_name(const ::std::string& value) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.GetColumnRequest.col_name)
}
#if LANG_CXX11
inline void GetColumnRequest::set_col_name(::std::string&& value) {
  
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.GetColumnRequest.col_name)
}
#endif
inline void GetColumnRequest::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.GetColumnRequest.col_name)
}
inline void GetColumnRequest::set_col_name(const char* value, size_t size) {
  
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.GetColumnRequest.col_name)
}
inline ::std::string* GetColumnRequest::mutable_col_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnRequest.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetColumnRequest::release_col_name() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnRequest.col_name)
  
  return col_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetColumnRequest::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    
  } else {
    
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnRequest.col_name)
}

// -------------------------------------------------------------------

// GetColumnResponse

// .mspb.ResponseHeader header = 1;
inline bool GetColumnResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetColumnResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetColumnResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetColumnResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetColumnResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetColumnResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnResponse.header)
}

// .basepb.Column column = 2;
inline bool GetColumnResponse::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void GetColumnResponse::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::basepb::Column& GetColumnResponse::column() const {
  const ::basepb::Column* p = column_;
  // @@protoc_insertion_point(field_get:mspb.GetColumnResponse.column)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Column*>(
      &::basepb::_Column_default_instance_);
}
inline ::basepb::Column* GetColumnResponse::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::basepb::Column;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetColumnResponse.column)
  return column_;
}
inline ::basepb::Column* GetColumnResponse::release_column() {
  // @@protoc_insertion_point(field_release:mspb.GetColumnResponse.column)
  
  ::basepb::Column* temp = column_;
  column_ = NULL;
  return temp;
}
inline void GetColumnResponse::set_allocated_column(::basepb::Column* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetColumnResponse.column)
}

// -------------------------------------------------------------------

// CreateDatabaseRequest

// .mspb.RequestHeader header = 1;
inline bool CreateDatabaseRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateDatabaseRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& CreateDatabaseRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* CreateDatabaseRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* CreateDatabaseRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateDatabaseRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseRequest.header)
}

// string name = 2;
inline void CreateDatabaseRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateDatabaseRequest::name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseRequest.name)
  return name_.GetNoArena();
}
inline void CreateDatabaseRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateDatabaseRequest.name)
}
#if LANG_CXX11
inline void CreateDatabaseRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateDatabaseRequest.name)
}
#endif
inline void CreateDatabaseRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateDatabaseRequest.name)
}
inline void CreateDatabaseRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateDatabaseRequest.name)
}
inline ::std::string* CreateDatabaseRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateDatabaseRequest::release_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateDatabaseRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseRequest.name)
}

// -------------------------------------------------------------------

// CreateDatabaseResponse

// .mspb.ResponseHeader header = 1;
inline bool CreateDatabaseResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateDatabaseResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& CreateDatabaseResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* CreateDatabaseResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* CreateDatabaseResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateDatabaseResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseResponse.header)
}

// .basepb.DataBase database = 2;
inline bool CreateDatabaseResponse::has_database() const {
  return this != internal_default_instance() && database_ != NULL;
}
inline void CreateDatabaseResponse::clear_database() {
  if (GetArenaNoVirtual() == NULL && database_ != NULL) delete database_;
  database_ = NULL;
}
inline const ::basepb::DataBase& CreateDatabaseResponse::database() const {
  const ::basepb::DataBase* p = database_;
  // @@protoc_insertion_point(field_get:mspb.CreateDatabaseResponse.database)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::DataBase*>(
      &::basepb::_DataBase_default_instance_);
}
inline ::basepb::DataBase* CreateDatabaseResponse::mutable_database() {
  
  if (database_ == NULL) {
    database_ = new ::basepb::DataBase;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateDatabaseResponse.database)
  return database_;
}
inline ::basepb::DataBase* CreateDatabaseResponse::release_database() {
  // @@protoc_insertion_point(field_release:mspb.CreateDatabaseResponse.database)
  
  ::basepb::DataBase* temp = database_;
  database_ = NULL;
  return temp;
}
inline void CreateDatabaseResponse::set_allocated_database(::basepb::DataBase* database) {
  delete database_;
  database_ = database;
  if (database) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateDatabaseResponse.database)
}

// -------------------------------------------------------------------

// CreateTableRequest

// .mspb.RequestHeader header = 1;
inline bool CreateTableRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateTableRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& CreateTableRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* CreateTableRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* CreateTableRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.header)
}

// string db_name = 2;
inline void CreateTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void CreateTableRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.db_name)
}
#if LANG_CXX11
inline void CreateTableRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.db_name)
}
#endif
inline void CreateTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.db_name)
}
inline void CreateTableRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.db_name)
}
inline ::std::string* CreateTableRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.db_name)
}

// string table_name = 3;
inline void CreateTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void CreateTableRequest::set_table_name(const ::std::string& value) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.table_name)
}
#if LANG_CXX11
inline void CreateTableRequest::set_table_name(::std::string&& value) {
  
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.table_name)
}
#endif
inline void CreateTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.table_name)
}
inline void CreateTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.table_name)
}
inline ::std::string* CreateTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.table_name)
}

// string properties = 4;
inline void CreateTableRequest::clear_properties() {
  properties_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTableRequest::properties() const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.properties)
  return properties_.GetNoArena();
}
inline void CreateTableRequest::set_properties(const ::std::string& value) {
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.properties)
}
#if LANG_CXX11
inline void CreateTableRequest::set_properties(::std::string&& value) {
  
  properties_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.CreateTableRequest.properties)
}
#endif
inline void CreateTableRequest::set_properties(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.properties)
}
inline void CreateTableRequest::set_properties(const char* value, size_t size) {
  
  properties_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.properties)
}
inline ::std::string* CreateTableRequest::mutable_properties() {
  
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.properties)
  return properties_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTableRequest::release_properties() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableRequest.properties)
  
  return properties_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_properties(::std::string* properties) {
  if (properties != NULL) {
    
  } else {
    
  }
  properties_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), properties);
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableRequest.properties)
}

// repeated string range_keys = 5;
inline int CreateTableRequest::range_keys_size() const {
  return range_keys_.size();
}
inline void CreateTableRequest::clear_range_keys() {
  range_keys_.Clear();
}
inline const ::std::string& CreateTableRequest::range_keys(int index) const {
  // @@protoc_insertion_point(field_get:mspb.CreateTableRequest.range_keys)
  return range_keys_.Get(index);
}
inline ::std::string* CreateTableRequest::mutable_range_keys(int index) {
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableRequest.range_keys)
  return range_keys_.Mutable(index);
}
inline void CreateTableRequest::set_range_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.range_keys)
  range_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreateTableRequest::set_range_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mspb.CreateTableRequest.range_keys)
  range_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreateTableRequest::set_range_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  range_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mspb.CreateTableRequest.range_keys)
}
inline void CreateTableRequest::set_range_keys(int index, const char* value, size_t size) {
  range_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mspb.CreateTableRequest.range_keys)
}
inline ::std::string* CreateTableRequest::add_range_keys() {
  // @@protoc_insertion_point(field_add_mutable:mspb.CreateTableRequest.range_keys)
  return range_keys_.Add();
}
inline void CreateTableRequest::add_range_keys(const ::std::string& value) {
  range_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mspb.CreateTableRequest.range_keys)
}
#if LANG_CXX11
inline void CreateTableRequest::add_range_keys(::std::string&& value) {
  range_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mspb.CreateTableRequest.range_keys)
}
#endif
inline void CreateTableRequest::add_range_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  range_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mspb.CreateTableRequest.range_keys)
}
inline void CreateTableRequest::add_range_keys(const char* value, size_t size) {
  range_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mspb.CreateTableRequest.range_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateTableRequest::range_keys() const {
  // @@protoc_insertion_point(field_list:mspb.CreateTableRequest.range_keys)
  return range_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateTableRequest::mutable_range_keys() {
  // @@protoc_insertion_point(field_mutable_list:mspb.CreateTableRequest.range_keys)
  return &range_keys_;
}

// -------------------------------------------------------------------

// CreateTableResponse

// .mspb.ResponseHeader header = 1;
inline bool CreateTableResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void CreateTableResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& CreateTableResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.CreateTableResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* CreateTableResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* CreateTableResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CreateTableResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableResponse.header)
}

// .basepb.Table table = 2;
inline bool CreateTableResponse::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline void CreateTableResponse::clear_table() {
  if (GetArenaNoVirtual() == NULL && table_ != NULL) delete table_;
  table_ = NULL;
}
inline const ::basepb::Table& CreateTableResponse::table() const {
  const ::basepb::Table* p = table_;
  // @@protoc_insertion_point(field_get:mspb.CreateTableResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Table*>(
      &::basepb::_Table_default_instance_);
}
inline ::basepb::Table* CreateTableResponse::mutable_table() {
  
  if (table_ == NULL) {
    table_ = new ::basepb::Table;
  }
  // @@protoc_insertion_point(field_mutable:mspb.CreateTableResponse.table)
  return table_;
}
inline ::basepb::Table* CreateTableResponse::release_table() {
  // @@protoc_insertion_point(field_release:mspb.CreateTableResponse.table)
  
  ::basepb::Table* temp = table_;
  table_ = NULL;
  return temp;
}
inline void CreateTableResponse::set_allocated_table(::basepb::Table* table) {
  delete table_;
  table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.CreateTableResponse.table)
}

// -------------------------------------------------------------------

// GetAutoIncIdRequest

// .mspb.RequestHeader header = 1;
inline bool GetAutoIncIdRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAutoIncIdRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::RequestHeader& GetAutoIncIdRequest::header() const {
  const ::mspb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::RequestHeader*>(
      &::mspb::_RequestHeader_default_instance_);
}
inline ::mspb::RequestHeader* GetAutoIncIdRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetAutoIncIdRequest.header)
  return header_;
}
inline ::mspb::RequestHeader* GetAutoIncIdRequest::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetAutoIncIdRequest.header)
  
  ::mspb::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetAutoIncIdRequest::set_allocated_header(::mspb::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetAutoIncIdRequest.header)
}

// uint64 db_id = 2;
inline void GetAutoIncIdRequest::clear_db_id() {
  db_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAutoIncIdRequest::db_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.db_id)
  return db_id_;
}
inline void GetAutoIncIdRequest::set_db_id(::google::protobuf::uint64 value) {
  
  db_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.db_id)
}

// uint64 table_id = 3;
inline void GetAutoIncIdRequest::clear_table_id() {
  table_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetAutoIncIdRequest::table_id() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.table_id)
  return table_id_;
}
inline void GetAutoIncIdRequest::set_table_id(::google::protobuf::uint64 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.table_id)
}

// uint32 size = 4;
inline void GetAutoIncIdRequest::clear_size() {
  size_ = 0u;
}
inline ::google::protobuf::uint32 GetAutoIncIdRequest::size() const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdRequest.size)
  return size_;
}
inline void GetAutoIncIdRequest::set_size(::google::protobuf::uint32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdRequest.size)
}

// -------------------------------------------------------------------

// GetAutoIncIdResponse

// .mspb.ResponseHeader header = 1;
inline bool GetAutoIncIdResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void GetAutoIncIdResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::mspb::ResponseHeader& GetAutoIncIdResponse::header() const {
  const ::mspb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::ResponseHeader*>(
      &::mspb::_ResponseHeader_default_instance_);
}
inline ::mspb::ResponseHeader* GetAutoIncIdResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::mspb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:mspb.GetAutoIncIdResponse.header)
  return header_;
}
inline ::mspb::ResponseHeader* GetAutoIncIdResponse::release_header() {
  // @@protoc_insertion_point(field_release:mspb.GetAutoIncIdResponse.header)
  
  ::mspb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetAutoIncIdResponse::set_allocated_header(::mspb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.GetAutoIncIdResponse.header)
}

// repeated uint64 ids = 2;
inline int GetAutoIncIdResponse::ids_size() const {
  return ids_.size();
}
inline void GetAutoIncIdResponse::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint64 GetAutoIncIdResponse::ids(int index) const {
  // @@protoc_insertion_point(field_get:mspb.GetAutoIncIdResponse.ids)
  return ids_.Get(index);
}
inline void GetAutoIncIdResponse::set_ids(int index, ::google::protobuf::uint64 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mspb.GetAutoIncIdResponse.ids)
}
inline void GetAutoIncIdResponse::add_ids(::google::protobuf::uint64 value) {
  ids_.Add(value);
  // @@protoc_insertion_point(field_add:mspb.GetAutoIncIdResponse.ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAutoIncIdResponse::ids() const {
  // @@protoc_insertion_point(field_list:mspb.GetAutoIncIdResponse.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAutoIncIdResponse::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:mspb.GetAutoIncIdResponse.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:mspb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:mspb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:mspb.ResponseHeader.cluster_id)
}

// .mspb.Error error = 2;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::mspb::Error& ResponseHeader::error() const {
  const ::mspb::Error* p = error_;
  // @@protoc_insertion_point(field_get:mspb.ResponseHeader.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mspb::Error*>(
      &::mspb::_Error_default_instance_);
}
inline ::mspb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::mspb::Error;
  }
  // @@protoc_insertion_point(field_mutable:mspb.ResponseHeader.error)
  return error_;
}
inline ::mspb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:mspb.ResponseHeader.error)
  
  ::mspb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_error(::mspb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mspb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// Error

// uint32 code = 1;
inline void Error::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 Error::code() const {
  // @@protoc_insertion_point(field_get:mspb.Error.code)
  return code_;
}
inline void Error::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:mspb.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:mspb.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mspb.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mspb.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mspb.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mspb.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:mspb.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:mspb.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mspb.Error.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mspb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mspb::ErrorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mspb::ErrorType>() {
  return ::mspb::ErrorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mspb_2fmspb_2eproto__INCLUDED
