// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dspb/error.proto

#ifndef PROTOBUF_dspb_2ferror_2eproto__INCLUDED
#define PROTOBUF_dspb_2ferror_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "basepb/basepb.pb.h"
// @@protoc_insertion_point(includes)
namespace dspb {
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_ClusterMismatched;
class Error_ClusterMismatchedDefaultTypeInternal;
extern Error_ClusterMismatchedDefaultTypeInternal _Error_ClusterMismatched_default_instance_;
class Error_NoLeftSpace;
class Error_NoLeftSpaceDefaultTypeInternal;
extern Error_NoLeftSpaceDefaultTypeInternal _Error_NoLeftSpace_default_instance_;
class Error_NotLeader;
class Error_NotLeaderDefaultTypeInternal;
extern Error_NotLeaderDefaultTypeInternal _Error_NotLeader_default_instance_;
class Error_OutOfBound;
class Error_OutOfBoundDefaultTypeInternal;
extern Error_OutOfBoundDefaultTypeInternal _Error_OutOfBound_default_instance_;
class Error_RaftFail;
class Error_RaftFailDefaultTypeInternal;
extern Error_RaftFailDefaultTypeInternal _Error_RaftFail_default_instance_;
class Error_RangeNotFound;
class Error_RangeNotFoundDefaultTypeInternal;
extern Error_RangeNotFoundDefaultTypeInternal _Error_RangeNotFound_default_instance_;
class Error_ServerError;
class Error_ServerErrorDefaultTypeInternal;
extern Error_ServerErrorDefaultTypeInternal _Error_ServerError_default_instance_;
class Error_StaleEpoch;
class Error_StaleEpochDefaultTypeInternal;
extern Error_StaleEpochDefaultTypeInternal _Error_StaleEpoch_default_instance_;
}  // namespace dspb

namespace dspb {

namespace protobuf_dspb_2ferror_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dspb_2ferror_2eproto

// ===================================================================

class Error_ClusterMismatched : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.ClusterMismatched) */ {
 public:
  Error_ClusterMismatched();
  virtual ~Error_ClusterMismatched();

  Error_ClusterMismatched(const Error_ClusterMismatched& from);

  inline Error_ClusterMismatched& operator=(const Error_ClusterMismatched& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_ClusterMismatched(Error_ClusterMismatched&& from) noexcept
    : Error_ClusterMismatched() {
    *this = ::std::move(from);
  }

  inline Error_ClusterMismatched& operator=(Error_ClusterMismatched&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_ClusterMismatched& default_instance();

  static inline const Error_ClusterMismatched* internal_default_instance() {
    return reinterpret_cast<const Error_ClusterMismatched*>(
               &_Error_ClusterMismatched_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Error_ClusterMismatched* other);
  friend void swap(Error_ClusterMismatched& a, Error_ClusterMismatched& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_ClusterMismatched* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_ClusterMismatched* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_ClusterMismatched& from);
  void MergeFrom(const Error_ClusterMismatched& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_ClusterMismatched* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 request_cluster = 1;
  void clear_request_cluster();
  static const int kRequestClusterFieldNumber = 1;
  ::google::protobuf::uint64 request_cluster() const;
  void set_request_cluster(::google::protobuf::uint64 value);

  // uint64 actual_cluster = 2;
  void clear_actual_cluster();
  static const int kActualClusterFieldNumber = 2;
  ::google::protobuf::uint64 actual_cluster() const;
  void set_actual_cluster(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Error.ClusterMismatched)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 request_cluster_;
  ::google::protobuf::uint64 actual_cluster_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_NotLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.NotLeader) */ {
 public:
  Error_NotLeader();
  virtual ~Error_NotLeader();

  Error_NotLeader(const Error_NotLeader& from);

  inline Error_NotLeader& operator=(const Error_NotLeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_NotLeader(Error_NotLeader&& from) noexcept
    : Error_NotLeader() {
    *this = ::std::move(from);
  }

  inline Error_NotLeader& operator=(Error_NotLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_NotLeader& default_instance();

  static inline const Error_NotLeader* internal_default_instance() {
    return reinterpret_cast<const Error_NotLeader*>(
               &_Error_NotLeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Error_NotLeader* other);
  friend void swap(Error_NotLeader& a, Error_NotLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_NotLeader* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_NotLeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_NotLeader& from);
  void MergeFrom(const Error_NotLeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_NotLeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .basepb.Peer leader = 2;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 2;
  const ::basepb::Peer& leader() const;
  ::basepb::Peer* mutable_leader();
  ::basepb::Peer* release_leader();
  void set_allocated_leader(::basepb::Peer* leader);

  // .basepb.RangeEpoch epoch = 4;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 4;
  const ::basepb::RangeEpoch& epoch() const;
  ::basepb::RangeEpoch* mutable_epoch();
  ::basepb::RangeEpoch* release_epoch();
  void set_allocated_epoch(::basepb::RangeEpoch* epoch);

  // uint64 range_id = 1;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // uint64 term = 3;
  void clear_term();
  static const int kTermFieldNumber = 3;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Error.NotLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::basepb::Peer* leader_;
  ::basepb::RangeEpoch* epoch_;
  ::google::protobuf::uint64 range_id_;
  ::google::protobuf::uint64 term_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_RaftFail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.RaftFail) */ {
 public:
  Error_RaftFail();
  virtual ~Error_RaftFail();

  Error_RaftFail(const Error_RaftFail& from);

  inline Error_RaftFail& operator=(const Error_RaftFail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_RaftFail(Error_RaftFail&& from) noexcept
    : Error_RaftFail() {
    *this = ::std::move(from);
  }

  inline Error_RaftFail& operator=(Error_RaftFail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_RaftFail& default_instance();

  static inline const Error_RaftFail* internal_default_instance() {
    return reinterpret_cast<const Error_RaftFail*>(
               &_Error_RaftFail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Error_RaftFail* other);
  friend void swap(Error_RaftFail& a, Error_RaftFail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_RaftFail* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_RaftFail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_RaftFail& from);
  void MergeFrom(const Error_RaftFail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_RaftFail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:dspb.Error.RaftFail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_RangeNotFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.RangeNotFound) */ {
 public:
  Error_RangeNotFound();
  virtual ~Error_RangeNotFound();

  Error_RangeNotFound(const Error_RangeNotFound& from);

  inline Error_RangeNotFound& operator=(const Error_RangeNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_RangeNotFound(Error_RangeNotFound&& from) noexcept
    : Error_RangeNotFound() {
    *this = ::std::move(from);
  }

  inline Error_RangeNotFound& operator=(Error_RangeNotFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_RangeNotFound& default_instance();

  static inline const Error_RangeNotFound* internal_default_instance() {
    return reinterpret_cast<const Error_RangeNotFound*>(
               &_Error_RangeNotFound_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Error_RangeNotFound* other);
  friend void swap(Error_RangeNotFound& a, Error_RangeNotFound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_RangeNotFound* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_RangeNotFound* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_RangeNotFound& from);
  void MergeFrom(const Error_RangeNotFound& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_RangeNotFound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 range_id = 1;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Error.RangeNotFound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_OutOfBound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.OutOfBound) */ {
 public:
  Error_OutOfBound();
  virtual ~Error_OutOfBound();

  Error_OutOfBound(const Error_OutOfBound& from);

  inline Error_OutOfBound& operator=(const Error_OutOfBound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_OutOfBound(Error_OutOfBound&& from) noexcept
    : Error_OutOfBound() {
    *this = ::std::move(from);
  }

  inline Error_OutOfBound& operator=(Error_OutOfBound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_OutOfBound& default_instance();

  static inline const Error_OutOfBound* internal_default_instance() {
    return reinterpret_cast<const Error_OutOfBound*>(
               &_Error_OutOfBound_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Error_OutOfBound* other);
  friend void swap(Error_OutOfBound& a, Error_OutOfBound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_OutOfBound* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_OutOfBound* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_OutOfBound& from);
  void MergeFrom(const Error_OutOfBound& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_OutOfBound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes range_start = 3;
  void clear_range_start();
  static const int kRangeStartFieldNumber = 3;
  const ::std::string& range_start() const;
  void set_range_start(const ::std::string& value);
  #if LANG_CXX11
  void set_range_start(::std::string&& value);
  #endif
  void set_range_start(const char* value);
  void set_range_start(const void* value, size_t size);
  ::std::string* mutable_range_start();
  ::std::string* release_range_start();
  void set_allocated_range_start(::std::string* range_start);

  // bytes range_limit = 4;
  void clear_range_limit();
  static const int kRangeLimitFieldNumber = 4;
  const ::std::string& range_limit() const;
  void set_range_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_range_limit(::std::string&& value);
  #endif
  void set_range_limit(const char* value);
  void set_range_limit(const void* value, size_t size);
  ::std::string* mutable_range_limit();
  ::std::string* release_range_limit();
  void set_allocated_range_limit(::std::string* range_limit);

  // uint64 range_id = 2;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 2;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Error.OutOfBound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr range_start_;
  ::google::protobuf::internal::ArenaStringPtr range_limit_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_StaleEpoch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.StaleEpoch) */ {
 public:
  Error_StaleEpoch();
  virtual ~Error_StaleEpoch();

  Error_StaleEpoch(const Error_StaleEpoch& from);

  inline Error_StaleEpoch& operator=(const Error_StaleEpoch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_StaleEpoch(Error_StaleEpoch&& from) noexcept
    : Error_StaleEpoch() {
    *this = ::std::move(from);
  }

  inline Error_StaleEpoch& operator=(Error_StaleEpoch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_StaleEpoch& default_instance();

  static inline const Error_StaleEpoch* internal_default_instance() {
    return reinterpret_cast<const Error_StaleEpoch*>(
               &_Error_StaleEpoch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Error_StaleEpoch* other);
  friend void swap(Error_StaleEpoch& a, Error_StaleEpoch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_StaleEpoch* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_StaleEpoch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_StaleEpoch& from);
  void MergeFrom(const Error_StaleEpoch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_StaleEpoch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .basepb.Range old_range = 1;
  bool has_old_range() const;
  void clear_old_range();
  static const int kOldRangeFieldNumber = 1;
  const ::basepb::Range& old_range() const;
  ::basepb::Range* mutable_old_range();
  ::basepb::Range* release_old_range();
  void set_allocated_old_range(::basepb::Range* old_range);

  // .basepb.Range new_range = 2;
  bool has_new_range() const;
  void clear_new_range();
  static const int kNewRangeFieldNumber = 2;
  const ::basepb::Range& new_range() const;
  ::basepb::Range* mutable_new_range();
  ::basepb::Range* release_new_range();
  void set_allocated_new_range(::basepb::Range* new_range);

  // @@protoc_insertion_point(class_scope:dspb.Error.StaleEpoch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::basepb::Range* old_range_;
  ::basepb::Range* new_range_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_NoLeftSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.NoLeftSpace) */ {
 public:
  Error_NoLeftSpace();
  virtual ~Error_NoLeftSpace();

  Error_NoLeftSpace(const Error_NoLeftSpace& from);

  inline Error_NoLeftSpace& operator=(const Error_NoLeftSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_NoLeftSpace(Error_NoLeftSpace&& from) noexcept
    : Error_NoLeftSpace() {
    *this = ::std::move(from);
  }

  inline Error_NoLeftSpace& operator=(Error_NoLeftSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_NoLeftSpace& default_instance();

  static inline const Error_NoLeftSpace* internal_default_instance() {
    return reinterpret_cast<const Error_NoLeftSpace*>(
               &_Error_NoLeftSpace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Error_NoLeftSpace* other);
  friend void swap(Error_NoLeftSpace& a, Error_NoLeftSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_NoLeftSpace* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_NoLeftSpace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_NoLeftSpace& from);
  void MergeFrom(const Error_NoLeftSpace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_NoLeftSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dspb.Error.NoLeftSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_ServerError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error.ServerError) */ {
 public:
  Error_ServerError();
  virtual ~Error_ServerError();

  Error_ServerError(const Error_ServerError& from);

  inline Error_ServerError& operator=(const Error_ServerError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_ServerError(Error_ServerError&& from) noexcept
    : Error_ServerError() {
    *this = ::std::move(from);
  }

  inline Error_ServerError& operator=(Error_ServerError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_ServerError& default_instance();

  static inline const Error_ServerError* internal_default_instance() {
    return reinterpret_cast<const Error_ServerError*>(
               &_Error_ServerError_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Error_ServerError* other);
  friend void swap(Error_ServerError& a, Error_ServerError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_ServerError* New() const PROTOBUF_FINAL { return New(NULL); }

  Error_ServerError* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error_ServerError& from);
  void MergeFrom(const Error_ServerError& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error_ServerError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:dspb.Error.ServerError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  enum ErrCase {
    kClusterMismatch = 1,
    kNotLeader = 2,
    kRaftFail = 3,
    kRangeNotFound = 4,
    kOutOfBound = 5,
    kStaleEpoch = 6,
    kNoLeftSpace = 7,
    kServerError = 8,
    ERR_NOT_SET = 0,
  };

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Error_ClusterMismatched ClusterMismatched;
  typedef Error_NotLeader NotLeader;
  typedef Error_RaftFail RaftFail;
  typedef Error_RangeNotFound RangeNotFound;
  typedef Error_OutOfBound OutOfBound;
  typedef Error_StaleEpoch StaleEpoch;
  typedef Error_NoLeftSpace NoLeftSpace;
  typedef Error_ServerError ServerError;

  // accessors -------------------------------------------------------

  // string detail = 100;
  void clear_detail();
  static const int kDetailFieldNumber = 100;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // .dspb.Error.ClusterMismatched cluster_mismatch = 1;
  bool has_cluster_mismatch() const;
  void clear_cluster_mismatch();
  static const int kClusterMismatchFieldNumber = 1;
  const ::dspb::Error_ClusterMismatched& cluster_mismatch() const;
  ::dspb::Error_ClusterMismatched* mutable_cluster_mismatch();
  ::dspb::Error_ClusterMismatched* release_cluster_mismatch();
  void set_allocated_cluster_mismatch(::dspb::Error_ClusterMismatched* cluster_mismatch);

  // .dspb.Error.NotLeader not_leader = 2;
  bool has_not_leader() const;
  void clear_not_leader();
  static const int kNotLeaderFieldNumber = 2;
  const ::dspb::Error_NotLeader& not_leader() const;
  ::dspb::Error_NotLeader* mutable_not_leader();
  ::dspb::Error_NotLeader* release_not_leader();
  void set_allocated_not_leader(::dspb::Error_NotLeader* not_leader);

  // .dspb.Error.RaftFail raft_fail = 3;
  bool has_raft_fail() const;
  void clear_raft_fail();
  static const int kRaftFailFieldNumber = 3;
  const ::dspb::Error_RaftFail& raft_fail() const;
  ::dspb::Error_RaftFail* mutable_raft_fail();
  ::dspb::Error_RaftFail* release_raft_fail();
  void set_allocated_raft_fail(::dspb::Error_RaftFail* raft_fail);

  // .dspb.Error.RangeNotFound range_not_found = 4;
  bool has_range_not_found() const;
  void clear_range_not_found();
  static const int kRangeNotFoundFieldNumber = 4;
  const ::dspb::Error_RangeNotFound& range_not_found() const;
  ::dspb::Error_RangeNotFound* mutable_range_not_found();
  ::dspb::Error_RangeNotFound* release_range_not_found();
  void set_allocated_range_not_found(::dspb::Error_RangeNotFound* range_not_found);

  // .dspb.Error.OutOfBound out_of_bound = 5;
  bool has_out_of_bound() const;
  void clear_out_of_bound();
  static const int kOutOfBoundFieldNumber = 5;
  const ::dspb::Error_OutOfBound& out_of_bound() const;
  ::dspb::Error_OutOfBound* mutable_out_of_bound();
  ::dspb::Error_OutOfBound* release_out_of_bound();
  void set_allocated_out_of_bound(::dspb::Error_OutOfBound* out_of_bound);

  // .dspb.Error.StaleEpoch stale_epoch = 6;
  bool has_stale_epoch() const;
  void clear_stale_epoch();
  static const int kStaleEpochFieldNumber = 6;
  const ::dspb::Error_StaleEpoch& stale_epoch() const;
  ::dspb::Error_StaleEpoch* mutable_stale_epoch();
  ::dspb::Error_StaleEpoch* release_stale_epoch();
  void set_allocated_stale_epoch(::dspb::Error_StaleEpoch* stale_epoch);

  // .dspb.Error.NoLeftSpace no_left_space = 7;
  bool has_no_left_space() const;
  void clear_no_left_space();
  static const int kNoLeftSpaceFieldNumber = 7;
  const ::dspb::Error_NoLeftSpace& no_left_space() const;
  ::dspb::Error_NoLeftSpace* mutable_no_left_space();
  ::dspb::Error_NoLeftSpace* release_no_left_space();
  void set_allocated_no_left_space(::dspb::Error_NoLeftSpace* no_left_space);

  // .dspb.Error.ServerError server_error = 8;
  bool has_server_error() const;
  void clear_server_error();
  static const int kServerErrorFieldNumber = 8;
  const ::dspb::Error_ServerError& server_error() const;
  ::dspb::Error_ServerError* mutable_server_error();
  ::dspb::Error_ServerError* release_server_error();
  void set_allocated_server_error(::dspb::Error_ServerError* server_error);

  ErrCase err_case() const;
  // @@protoc_insertion_point(class_scope:dspb.Error)
 private:
  void set_has_cluster_mismatch();
  void set_has_not_leader();
  void set_has_raft_fail();
  void set_has_range_not_found();
  void set_has_out_of_bound();
  void set_has_stale_epoch();
  void set_has_no_left_space();
  void set_has_server_error();

  inline bool has_err() const;
  void clear_err();
  inline void clear_has_err();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  union ErrUnion {
    ErrUnion() {}
    ::dspb::Error_ClusterMismatched* cluster_mismatch_;
    ::dspb::Error_NotLeader* not_leader_;
    ::dspb::Error_RaftFail* raft_fail_;
    ::dspb::Error_RangeNotFound* range_not_found_;
    ::dspb::Error_OutOfBound* out_of_bound_;
    ::dspb::Error_StaleEpoch* stale_epoch_;
    ::dspb::Error_NoLeftSpace* no_left_space_;
    ::dspb::Error_ServerError* server_error_;
  } err_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_dspb_2ferror_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Error_ClusterMismatched

// uint64 request_cluster = 1;
inline void Error_ClusterMismatched::clear_request_cluster() {
  request_cluster_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_ClusterMismatched::request_cluster() const {
  // @@protoc_insertion_point(field_get:dspb.Error.ClusterMismatched.request_cluster)
  return request_cluster_;
}
inline void Error_ClusterMismatched::set_request_cluster(::google::protobuf::uint64 value) {
  
  request_cluster_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.ClusterMismatched.request_cluster)
}

// uint64 actual_cluster = 2;
inline void Error_ClusterMismatched::clear_actual_cluster() {
  actual_cluster_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_ClusterMismatched::actual_cluster() const {
  // @@protoc_insertion_point(field_get:dspb.Error.ClusterMismatched.actual_cluster)
  return actual_cluster_;
}
inline void Error_ClusterMismatched::set_actual_cluster(::google::protobuf::uint64 value) {
  
  actual_cluster_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.ClusterMismatched.actual_cluster)
}

// -------------------------------------------------------------------

// Error_NotLeader

// uint64 range_id = 1;
inline void Error_NotLeader::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_NotLeader::range_id() const {
  // @@protoc_insertion_point(field_get:dspb.Error.NotLeader.range_id)
  return range_id_;
}
inline void Error_NotLeader::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.NotLeader.range_id)
}

// .basepb.Peer leader = 2;
inline bool Error_NotLeader::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void Error_NotLeader::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) delete leader_;
  leader_ = NULL;
}
inline const ::basepb::Peer& Error_NotLeader::leader() const {
  const ::basepb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:dspb.Error.NotLeader.leader)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Peer*>(
      &::basepb::_Peer_default_instance_);
}
inline ::basepb::Peer* Error_NotLeader::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::basepb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.NotLeader.leader)
  return leader_;
}
inline ::basepb::Peer* Error_NotLeader::release_leader() {
  // @@protoc_insertion_point(field_release:dspb.Error.NotLeader.leader)
  
  ::basepb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline void Error_NotLeader::set_allocated_leader(::basepb::Peer* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.NotLeader.leader)
}

// uint64 term = 3;
inline void Error_NotLeader::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_NotLeader::term() const {
  // @@protoc_insertion_point(field_get:dspb.Error.NotLeader.term)
  return term_;
}
inline void Error_NotLeader::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.NotLeader.term)
}

// .basepb.RangeEpoch epoch = 4;
inline bool Error_NotLeader::has_epoch() const {
  return this != internal_default_instance() && epoch_ != NULL;
}
inline void Error_NotLeader::clear_epoch() {
  if (GetArenaNoVirtual() == NULL && epoch_ != NULL) delete epoch_;
  epoch_ = NULL;
}
inline const ::basepb::RangeEpoch& Error_NotLeader::epoch() const {
  const ::basepb::RangeEpoch* p = epoch_;
  // @@protoc_insertion_point(field_get:dspb.Error.NotLeader.epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::RangeEpoch*>(
      &::basepb::_RangeEpoch_default_instance_);
}
inline ::basepb::RangeEpoch* Error_NotLeader::mutable_epoch() {
  
  if (epoch_ == NULL) {
    epoch_ = new ::basepb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.NotLeader.epoch)
  return epoch_;
}
inline ::basepb::RangeEpoch* Error_NotLeader::release_epoch() {
  // @@protoc_insertion_point(field_release:dspb.Error.NotLeader.epoch)
  
  ::basepb::RangeEpoch* temp = epoch_;
  epoch_ = NULL;
  return temp;
}
inline void Error_NotLeader::set_allocated_epoch(::basepb::RangeEpoch* epoch) {
  delete epoch_;
  epoch_ = epoch;
  if (epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.NotLeader.epoch)
}

// -------------------------------------------------------------------

// Error_RaftFail

// string reason = 1;
inline void Error_RaftFail::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_RaftFail::reason() const {
  // @@protoc_insertion_point(field_get:dspb.Error.RaftFail.reason)
  return reason_.GetNoArena();
}
inline void Error_RaftFail::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.RaftFail.reason)
}
#if LANG_CXX11
inline void Error_RaftFail::set_reason(::std::string&& value) {
  
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.RaftFail.reason)
}
#endif
inline void Error_RaftFail::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.RaftFail.reason)
}
inline void Error_RaftFail::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.RaftFail.reason)
}
inline ::std::string* Error_RaftFail::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.RaftFail.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_RaftFail::release_reason() {
  // @@protoc_insertion_point(field_release:dspb.Error.RaftFail.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_RaftFail::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.RaftFail.reason)
}

// -------------------------------------------------------------------

// Error_RangeNotFound

// uint64 range_id = 1;
inline void Error_RangeNotFound::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_RangeNotFound::range_id() const {
  // @@protoc_insertion_point(field_get:dspb.Error.RangeNotFound.range_id)
  return range_id_;
}
inline void Error_RangeNotFound::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.RangeNotFound.range_id)
}

// -------------------------------------------------------------------

// Error_OutOfBound

// bytes key = 1;
inline void Error_OutOfBound::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_OutOfBound::key() const {
  // @@protoc_insertion_point(field_get:dspb.Error.OutOfBound.key)
  return key_.GetNoArena();
}
inline void Error_OutOfBound::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.OutOfBound.key)
}
#if LANG_CXX11
inline void Error_OutOfBound::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.OutOfBound.key)
}
#endif
inline void Error_OutOfBound::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.OutOfBound.key)
}
inline void Error_OutOfBound::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.OutOfBound.key)
}
inline ::std::string* Error_OutOfBound::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.OutOfBound.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_OutOfBound::release_key() {
  // @@protoc_insertion_point(field_release:dspb.Error.OutOfBound.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_OutOfBound::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.OutOfBound.key)
}

// uint64 range_id = 2;
inline void Error_OutOfBound::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Error_OutOfBound::range_id() const {
  // @@protoc_insertion_point(field_get:dspb.Error.OutOfBound.range_id)
  return range_id_;
}
inline void Error_OutOfBound::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.Error.OutOfBound.range_id)
}

// bytes range_start = 3;
inline void Error_OutOfBound::clear_range_start() {
  range_start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_OutOfBound::range_start() const {
  // @@protoc_insertion_point(field_get:dspb.Error.OutOfBound.range_start)
  return range_start_.GetNoArena();
}
inline void Error_OutOfBound::set_range_start(const ::std::string& value) {
  
  range_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.OutOfBound.range_start)
}
#if LANG_CXX11
inline void Error_OutOfBound::set_range_start(::std::string&& value) {
  
  range_start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.OutOfBound.range_start)
}
#endif
inline void Error_OutOfBound::set_range_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  range_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.OutOfBound.range_start)
}
inline void Error_OutOfBound::set_range_start(const void* value, size_t size) {
  
  range_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.OutOfBound.range_start)
}
inline ::std::string* Error_OutOfBound::mutable_range_start() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.OutOfBound.range_start)
  return range_start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_OutOfBound::release_range_start() {
  // @@protoc_insertion_point(field_release:dspb.Error.OutOfBound.range_start)
  
  return range_start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_OutOfBound::set_allocated_range_start(::std::string* range_start) {
  if (range_start != NULL) {
    
  } else {
    
  }
  range_start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), range_start);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.OutOfBound.range_start)
}

// bytes range_limit = 4;
inline void Error_OutOfBound::clear_range_limit() {
  range_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_OutOfBound::range_limit() const {
  // @@protoc_insertion_point(field_get:dspb.Error.OutOfBound.range_limit)
  return range_limit_.GetNoArena();
}
inline void Error_OutOfBound::set_range_limit(const ::std::string& value) {
  
  range_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.OutOfBound.range_limit)
}
#if LANG_CXX11
inline void Error_OutOfBound::set_range_limit(::std::string&& value) {
  
  range_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.OutOfBound.range_limit)
}
#endif
inline void Error_OutOfBound::set_range_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  range_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.OutOfBound.range_limit)
}
inline void Error_OutOfBound::set_range_limit(const void* value, size_t size) {
  
  range_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.OutOfBound.range_limit)
}
inline ::std::string* Error_OutOfBound::mutable_range_limit() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.OutOfBound.range_limit)
  return range_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_OutOfBound::release_range_limit() {
  // @@protoc_insertion_point(field_release:dspb.Error.OutOfBound.range_limit)
  
  return range_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_OutOfBound::set_allocated_range_limit(::std::string* range_limit) {
  if (range_limit != NULL) {
    
  } else {
    
  }
  range_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), range_limit);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.OutOfBound.range_limit)
}

// -------------------------------------------------------------------

// Error_StaleEpoch

// .basepb.Range old_range = 1;
inline bool Error_StaleEpoch::has_old_range() const {
  return this != internal_default_instance() && old_range_ != NULL;
}
inline void Error_StaleEpoch::clear_old_range() {
  if (GetArenaNoVirtual() == NULL && old_range_ != NULL) delete old_range_;
  old_range_ = NULL;
}
inline const ::basepb::Range& Error_StaleEpoch::old_range() const {
  const ::basepb::Range* p = old_range_;
  // @@protoc_insertion_point(field_get:dspb.Error.StaleEpoch.old_range)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Range*>(
      &::basepb::_Range_default_instance_);
}
inline ::basepb::Range* Error_StaleEpoch::mutable_old_range() {
  
  if (old_range_ == NULL) {
    old_range_ = new ::basepb::Range;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.StaleEpoch.old_range)
  return old_range_;
}
inline ::basepb::Range* Error_StaleEpoch::release_old_range() {
  // @@protoc_insertion_point(field_release:dspb.Error.StaleEpoch.old_range)
  
  ::basepb::Range* temp = old_range_;
  old_range_ = NULL;
  return temp;
}
inline void Error_StaleEpoch::set_allocated_old_range(::basepb::Range* old_range) {
  delete old_range_;
  old_range_ = old_range;
  if (old_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.StaleEpoch.old_range)
}

// .basepb.Range new_range = 2;
inline bool Error_StaleEpoch::has_new_range() const {
  return this != internal_default_instance() && new_range_ != NULL;
}
inline void Error_StaleEpoch::clear_new_range() {
  if (GetArenaNoVirtual() == NULL && new_range_ != NULL) delete new_range_;
  new_range_ = NULL;
}
inline const ::basepb::Range& Error_StaleEpoch::new_range() const {
  const ::basepb::Range* p = new_range_;
  // @@protoc_insertion_point(field_get:dspb.Error.StaleEpoch.new_range)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::Range*>(
      &::basepb::_Range_default_instance_);
}
inline ::basepb::Range* Error_StaleEpoch::mutable_new_range() {
  
  if (new_range_ == NULL) {
    new_range_ = new ::basepb::Range;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.StaleEpoch.new_range)
  return new_range_;
}
inline ::basepb::Range* Error_StaleEpoch::release_new_range() {
  // @@protoc_insertion_point(field_release:dspb.Error.StaleEpoch.new_range)
  
  ::basepb::Range* temp = new_range_;
  new_range_ = NULL;
  return temp;
}
inline void Error_StaleEpoch::set_allocated_new_range(::basepb::Range* new_range) {
  delete new_range_;
  new_range_ = new_range;
  if (new_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.StaleEpoch.new_range)
}

// -------------------------------------------------------------------

// Error_NoLeftSpace

// -------------------------------------------------------------------

// Error_ServerError

// string msg = 1;
inline void Error_ServerError::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_ServerError::msg() const {
  // @@protoc_insertion_point(field_get:dspb.Error.ServerError.msg)
  return msg_.GetNoArena();
}
inline void Error_ServerError::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.ServerError.msg)
}
#if LANG_CXX11
inline void Error_ServerError::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.ServerError.msg)
}
#endif
inline void Error_ServerError::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.ServerError.msg)
}
inline void Error_ServerError::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.ServerError.msg)
}
inline ::std::string* Error_ServerError::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.ServerError.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_ServerError::release_msg() {
  // @@protoc_insertion_point(field_release:dspb.Error.ServerError.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_ServerError::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.ServerError.msg)
}

// -------------------------------------------------------------------

// Error

// .dspb.Error.ClusterMismatched cluster_mismatch = 1;
inline bool Error::has_cluster_mismatch() const {
  return err_case() == kClusterMismatch;
}
inline void Error::set_has_cluster_mismatch() {
  _oneof_case_[0] = kClusterMismatch;
}
inline void Error::clear_cluster_mismatch() {
  if (has_cluster_mismatch()) {
    delete err_.cluster_mismatch_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_ClusterMismatched& Error::cluster_mismatch() const {
  // @@protoc_insertion_point(field_get:dspb.Error.cluster_mismatch)
  return has_cluster_mismatch()
      ? *err_.cluster_mismatch_
      : ::dspb::Error_ClusterMismatched::default_instance();
}
inline ::dspb::Error_ClusterMismatched* Error::mutable_cluster_mismatch() {
  if (!has_cluster_mismatch()) {
    clear_err();
    set_has_cluster_mismatch();
    err_.cluster_mismatch_ = new ::dspb::Error_ClusterMismatched;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.cluster_mismatch)
  return err_.cluster_mismatch_;
}
inline ::dspb::Error_ClusterMismatched* Error::release_cluster_mismatch() {
  // @@protoc_insertion_point(field_release:dspb.Error.cluster_mismatch)
  if (has_cluster_mismatch()) {
    clear_has_err();
    ::dspb::Error_ClusterMismatched* temp = err_.cluster_mismatch_;
    err_.cluster_mismatch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_cluster_mismatch(::dspb::Error_ClusterMismatched* cluster_mismatch) {
  clear_err();
  if (cluster_mismatch) {
    set_has_cluster_mismatch();
    err_.cluster_mismatch_ = cluster_mismatch;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.cluster_mismatch)
}

// .dspb.Error.NotLeader not_leader = 2;
inline bool Error::has_not_leader() const {
  return err_case() == kNotLeader;
}
inline void Error::set_has_not_leader() {
  _oneof_case_[0] = kNotLeader;
}
inline void Error::clear_not_leader() {
  if (has_not_leader()) {
    delete err_.not_leader_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_NotLeader& Error::not_leader() const {
  // @@protoc_insertion_point(field_get:dspb.Error.not_leader)
  return has_not_leader()
      ? *err_.not_leader_
      : ::dspb::Error_NotLeader::default_instance();
}
inline ::dspb::Error_NotLeader* Error::mutable_not_leader() {
  if (!has_not_leader()) {
    clear_err();
    set_has_not_leader();
    err_.not_leader_ = new ::dspb::Error_NotLeader;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.not_leader)
  return err_.not_leader_;
}
inline ::dspb::Error_NotLeader* Error::release_not_leader() {
  // @@protoc_insertion_point(field_release:dspb.Error.not_leader)
  if (has_not_leader()) {
    clear_has_err();
    ::dspb::Error_NotLeader* temp = err_.not_leader_;
    err_.not_leader_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_not_leader(::dspb::Error_NotLeader* not_leader) {
  clear_err();
  if (not_leader) {
    set_has_not_leader();
    err_.not_leader_ = not_leader;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.not_leader)
}

// .dspb.Error.RaftFail raft_fail = 3;
inline bool Error::has_raft_fail() const {
  return err_case() == kRaftFail;
}
inline void Error::set_has_raft_fail() {
  _oneof_case_[0] = kRaftFail;
}
inline void Error::clear_raft_fail() {
  if (has_raft_fail()) {
    delete err_.raft_fail_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_RaftFail& Error::raft_fail() const {
  // @@protoc_insertion_point(field_get:dspb.Error.raft_fail)
  return has_raft_fail()
      ? *err_.raft_fail_
      : ::dspb::Error_RaftFail::default_instance();
}
inline ::dspb::Error_RaftFail* Error::mutable_raft_fail() {
  if (!has_raft_fail()) {
    clear_err();
    set_has_raft_fail();
    err_.raft_fail_ = new ::dspb::Error_RaftFail;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.raft_fail)
  return err_.raft_fail_;
}
inline ::dspb::Error_RaftFail* Error::release_raft_fail() {
  // @@protoc_insertion_point(field_release:dspb.Error.raft_fail)
  if (has_raft_fail()) {
    clear_has_err();
    ::dspb::Error_RaftFail* temp = err_.raft_fail_;
    err_.raft_fail_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_raft_fail(::dspb::Error_RaftFail* raft_fail) {
  clear_err();
  if (raft_fail) {
    set_has_raft_fail();
    err_.raft_fail_ = raft_fail;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.raft_fail)
}

// .dspb.Error.RangeNotFound range_not_found = 4;
inline bool Error::has_range_not_found() const {
  return err_case() == kRangeNotFound;
}
inline void Error::set_has_range_not_found() {
  _oneof_case_[0] = kRangeNotFound;
}
inline void Error::clear_range_not_found() {
  if (has_range_not_found()) {
    delete err_.range_not_found_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_RangeNotFound& Error::range_not_found() const {
  // @@protoc_insertion_point(field_get:dspb.Error.range_not_found)
  return has_range_not_found()
      ? *err_.range_not_found_
      : ::dspb::Error_RangeNotFound::default_instance();
}
inline ::dspb::Error_RangeNotFound* Error::mutable_range_not_found() {
  if (!has_range_not_found()) {
    clear_err();
    set_has_range_not_found();
    err_.range_not_found_ = new ::dspb::Error_RangeNotFound;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.range_not_found)
  return err_.range_not_found_;
}
inline ::dspb::Error_RangeNotFound* Error::release_range_not_found() {
  // @@protoc_insertion_point(field_release:dspb.Error.range_not_found)
  if (has_range_not_found()) {
    clear_has_err();
    ::dspb::Error_RangeNotFound* temp = err_.range_not_found_;
    err_.range_not_found_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_range_not_found(::dspb::Error_RangeNotFound* range_not_found) {
  clear_err();
  if (range_not_found) {
    set_has_range_not_found();
    err_.range_not_found_ = range_not_found;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.range_not_found)
}

// .dspb.Error.OutOfBound out_of_bound = 5;
inline bool Error::has_out_of_bound() const {
  return err_case() == kOutOfBound;
}
inline void Error::set_has_out_of_bound() {
  _oneof_case_[0] = kOutOfBound;
}
inline void Error::clear_out_of_bound() {
  if (has_out_of_bound()) {
    delete err_.out_of_bound_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_OutOfBound& Error::out_of_bound() const {
  // @@protoc_insertion_point(field_get:dspb.Error.out_of_bound)
  return has_out_of_bound()
      ? *err_.out_of_bound_
      : ::dspb::Error_OutOfBound::default_instance();
}
inline ::dspb::Error_OutOfBound* Error::mutable_out_of_bound() {
  if (!has_out_of_bound()) {
    clear_err();
    set_has_out_of_bound();
    err_.out_of_bound_ = new ::dspb::Error_OutOfBound;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.out_of_bound)
  return err_.out_of_bound_;
}
inline ::dspb::Error_OutOfBound* Error::release_out_of_bound() {
  // @@protoc_insertion_point(field_release:dspb.Error.out_of_bound)
  if (has_out_of_bound()) {
    clear_has_err();
    ::dspb::Error_OutOfBound* temp = err_.out_of_bound_;
    err_.out_of_bound_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_out_of_bound(::dspb::Error_OutOfBound* out_of_bound) {
  clear_err();
  if (out_of_bound) {
    set_has_out_of_bound();
    err_.out_of_bound_ = out_of_bound;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.out_of_bound)
}

// .dspb.Error.StaleEpoch stale_epoch = 6;
inline bool Error::has_stale_epoch() const {
  return err_case() == kStaleEpoch;
}
inline void Error::set_has_stale_epoch() {
  _oneof_case_[0] = kStaleEpoch;
}
inline void Error::clear_stale_epoch() {
  if (has_stale_epoch()) {
    delete err_.stale_epoch_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_StaleEpoch& Error::stale_epoch() const {
  // @@protoc_insertion_point(field_get:dspb.Error.stale_epoch)
  return has_stale_epoch()
      ? *err_.stale_epoch_
      : ::dspb::Error_StaleEpoch::default_instance();
}
inline ::dspb::Error_StaleEpoch* Error::mutable_stale_epoch() {
  if (!has_stale_epoch()) {
    clear_err();
    set_has_stale_epoch();
    err_.stale_epoch_ = new ::dspb::Error_StaleEpoch;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.stale_epoch)
  return err_.stale_epoch_;
}
inline ::dspb::Error_StaleEpoch* Error::release_stale_epoch() {
  // @@protoc_insertion_point(field_release:dspb.Error.stale_epoch)
  if (has_stale_epoch()) {
    clear_has_err();
    ::dspb::Error_StaleEpoch* temp = err_.stale_epoch_;
    err_.stale_epoch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_stale_epoch(::dspb::Error_StaleEpoch* stale_epoch) {
  clear_err();
  if (stale_epoch) {
    set_has_stale_epoch();
    err_.stale_epoch_ = stale_epoch;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.stale_epoch)
}

// .dspb.Error.NoLeftSpace no_left_space = 7;
inline bool Error::has_no_left_space() const {
  return err_case() == kNoLeftSpace;
}
inline void Error::set_has_no_left_space() {
  _oneof_case_[0] = kNoLeftSpace;
}
inline void Error::clear_no_left_space() {
  if (has_no_left_space()) {
    delete err_.no_left_space_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_NoLeftSpace& Error::no_left_space() const {
  // @@protoc_insertion_point(field_get:dspb.Error.no_left_space)
  return has_no_left_space()
      ? *err_.no_left_space_
      : ::dspb::Error_NoLeftSpace::default_instance();
}
inline ::dspb::Error_NoLeftSpace* Error::mutable_no_left_space() {
  if (!has_no_left_space()) {
    clear_err();
    set_has_no_left_space();
    err_.no_left_space_ = new ::dspb::Error_NoLeftSpace;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.no_left_space)
  return err_.no_left_space_;
}
inline ::dspb::Error_NoLeftSpace* Error::release_no_left_space() {
  // @@protoc_insertion_point(field_release:dspb.Error.no_left_space)
  if (has_no_left_space()) {
    clear_has_err();
    ::dspb::Error_NoLeftSpace* temp = err_.no_left_space_;
    err_.no_left_space_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_no_left_space(::dspb::Error_NoLeftSpace* no_left_space) {
  clear_err();
  if (no_left_space) {
    set_has_no_left_space();
    err_.no_left_space_ = no_left_space;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.no_left_space)
}

// .dspb.Error.ServerError server_error = 8;
inline bool Error::has_server_error() const {
  return err_case() == kServerError;
}
inline void Error::set_has_server_error() {
  _oneof_case_[0] = kServerError;
}
inline void Error::clear_server_error() {
  if (has_server_error()) {
    delete err_.server_error_;
    clear_has_err();
  }
}
inline  const ::dspb::Error_ServerError& Error::server_error() const {
  // @@protoc_insertion_point(field_get:dspb.Error.server_error)
  return has_server_error()
      ? *err_.server_error_
      : ::dspb::Error_ServerError::default_instance();
}
inline ::dspb::Error_ServerError* Error::mutable_server_error() {
  if (!has_server_error()) {
    clear_err();
    set_has_server_error();
    err_.server_error_ = new ::dspb::Error_ServerError;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Error.server_error)
  return err_.server_error_;
}
inline ::dspb::Error_ServerError* Error::release_server_error() {
  // @@protoc_insertion_point(field_release:dspb.Error.server_error)
  if (has_server_error()) {
    clear_has_err();
    ::dspb::Error_ServerError* temp = err_.server_error_;
    err_.server_error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Error::set_allocated_server_error(::dspb::Error_ServerError* server_error) {
  clear_err();
  if (server_error) {
    set_has_server_error();
    err_.server_error_ = server_error;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.server_error)
}

// string detail = 100;
inline void Error::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::detail() const {
  // @@protoc_insertion_point(field_get:dspb.Error.detail)
  return detail_.GetNoArena();
}
inline void Error::set_detail(const ::std::string& value) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Error.detail)
}
#if LANG_CXX11
inline void Error::set_detail(::std::string&& value) {
  
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Error.detail)
}
#endif
inline void Error::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Error.detail)
}
inline void Error::set_detail(const char* value, size_t size) {
  
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Error.detail)
}
inline ::std::string* Error::mutable_detail() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Error.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_detail() {
  // @@protoc_insertion_point(field_release:dspb.Error.detail)
  
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    
  } else {
    
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:dspb.Error.detail)
}

inline bool Error::has_err() const {
  return err_case() != ERR_NOT_SET;
}
inline void Error::clear_has_err() {
  _oneof_case_[0] = ERR_NOT_SET;
}
inline Error::ErrCase Error::err_case() const {
  return Error::ErrCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dspb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dspb_2ferror_2eproto__INCLUDED
