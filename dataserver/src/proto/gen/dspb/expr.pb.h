// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dspb/expr.proto

#ifndef PROTOBUF_dspb_2fexpr_2eproto__INCLUDED
#define PROTOBUF_dspb_2fexpr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basepb/basepb.pb.h"
// @@protoc_insertion_point(includes)
namespace dspb {
class ColumnInfo;
class ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
}  // namespace dspb

namespace dspb {

namespace protobuf_dspb_2fexpr_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dspb_2fexpr_2eproto

enum ExprType {
  Invalid_Expr = 0,
  Column = 1,
  Const_Int = 2,
  Const_UInt = 3,
  Const_Double = 4,
  Const_Bytes = 5,
  Const_Decimal = 6,
  Const_Date = 7,
  Const_Time = 8,
  Equal = 20,
  NotEqual = 21,
  Less = 22,
  LessOrEqual = 23,
  Larger = 24,
  LargerOrEqual = 25,
  Avg = 151,
  Count = 152,
  Max = 153,
  Min = 154,
  Sum = 155,
  Std = 156,
  Distinct = 157,
  LogicAnd = 201,
  LogicOr = 202,
  LogicNot = 203,
  LogicXor = 204,
  UnaryNot = 205,
  UnaryMinus = 206,
  IsNull = 207,
  DecimalIsNull = 208,
  DateIsNull = 209,
  RealIsNull = 210,
  StringIsNull = 211,
  TimeIsNull = 212,
  IntIsNull = 213,
  JsonIsNull = 214,
  IsNotNull = 215,
  IsTrue = 216,
  IsFalse = 217,
  LeftShift = 218,
  RightShift = 219,
  CastIntToInt = 301,
  CastIntToReal = 302,
  CastIntToString = 303,
  CastIntToDecimal = 304,
  CastIntToTime = 305,
  CastIntToDate = 306,
  CastIntToJson = 307,
  CastRealToInt = 308,
  CastRealToReal = 309,
  CastRealToString = 310,
  CastRealToDecimal = 311,
  CastRealToTime = 312,
  CastRealToDate = 313,
  CastRealToJson = 314,
  CastDecimalToInt = 315,
  CastDecimalToReal = 316,
  CastDecimalToString = 317,
  CastDecimalToDecimal = 318,
  CastDecimalToTime = 319,
  CastDecimalToDate = 320,
  CastDecimalToJson = 321,
  CastStringToInt = 322,
  CastStringToReal = 323,
  CastStringToString = 324,
  CastStringToDecimal = 325,
  CastStringToTime = 326,
  CastStringToDate = 327,
  CastStringToJson = 328,
  CastTimeToInt = 329,
  CastTimeToReal = 330,
  CastTimeToString = 331,
  CastTimeToDecimal = 332,
  CastTimeToTime = 333,
  CastTimeToDate = 334,
  CastTimeToJson = 335,
  CastDateToInt = 336,
  CastDateToReal = 337,
  CastDateToString = 338,
  CastDateToDecimal = 339,
  CastDateToTime = 340,
  CastDateToDate = 341,
  CastDateToJson = 342,
  CastJsonToInt = 343,
  CastJsonToReal = 344,
  CastJsonToString = 345,
  CastJsonToDecimal = 346,
  CastJsonToTime = 347,
  CastJsonToDate = 348,
  CastJsonToJson = 349,
  Coalesce = 401,
  EqualInt = 402,
  EqualReal = 403,
  EqualString = 404,
  EqualDecimal = 405,
  EqualTime = 406,
  EqualDate = 407,
  EqualJson = 408,
  NotEqualInt = 409,
  NotEqualReal = 410,
  NotEqualDecimal = 411,
  NotEqualString = 412,
  NotEqualTime = 413,
  NotEqualDate = 414,
  NotEqualJson = 415,
  LessInt = 416,
  LessReal = 417,
  LessDecimal = 418,
  LessString = 419,
  LessTime = 420,
  LessDate = 421,
  LessJson = 422,
  LessOrEqualInt = 423,
  LessOrEqualReal = 424,
  LessOrEqualDecimal = 425,
  LessOrEqualString = 426,
  LessOrEqualTime = 427,
  LessOrEqualDate = 428,
  LessOrEqualJson = 429,
  GreaterInt = 430,
  GreaterReal = 431,
  GreaterDecimal = 432,
  GreaterString = 433,
  GreaterTime = 434,
  GreaterDate = 435,
  GreaterJson = 436,
  GreaterOrEqualInt = 437,
  GreaterOrEqualReal = 438,
  GreaterOrEqualDecimal = 439,
  GreaterOrEqualString = 440,
  GreaterOrEqualTime = 441,
  GreaterOrEqualDate = 442,
  GreaterOrEqualJson = 443,
  Like = 444,
  NotLike = 445,
  RegexpLike = 446,
  Regexp = 447,
  NotRegexp = 448,
  IN = 449,
  Plus = 551,
  PlusReal = 552,
  PlusDecimal = 553,
  PlusInt = 554,
  Minus = 561,
  MinusReal = 562,
  MinusDecimal = 563,
  MinusInt = 564,
  Mult = 571,
  MultReal = 572,
  MultDecimal = 573,
  MultInt = 574,
  MultIntUnsigned = 575,
  Div = 581,
  DivReal = 582,
  DivDecimal = 583,
  IntDivInt = 584,
  IntDivDecimal = 585,
  Mod = 591,
  ModReal = 592,
  ModDecimal = 593,
  ModInt = 594,
  Abs = 701,
  Ceil = 702,
  Floor = 703,
  Round = 704,
  Rand = 705,
  Conv = 706,
  CRC32 = 707,
  Degrees = 708,
  Exp = 709,
  Acos = 710,
  Asin = 711,
  Atan = 712,
  Atan2 = 713,
  Cos = 714,
  Cot = 715,
  Ln = 716,
  Log = 717,
  Log10 = 718,
  Log2 = 719,
  PI = 720,
  Pow = 721,
  Radians = 722,
  Sign = 723,
  Sin = 724,
  Sqrt = 725,
  Tan = 726,
  Truncate = 727,
  CaseWhen = 751,
  If = 752,
  IfInt = 753,
  IfReal = 754,
  IfDecimal = 755,
  IfString = 756,
  IfTime = 757,
  IfDate = 758,
  IfNullJson = 759,
  IfJson = 760,
  IfNull = 761,
  Aes_decrypt = 901,
  Aes_encrypt = 902,
  Compress = 903,
  Uncompress = 904,
  Md5 = 905,
  Password = 906,
  SHA1 = 907,
  SHA2 = 908,
  Ascii = 1201,
  Bin = 1202,
  Bit_length = 1203,
  Char = 1204,
  Char_length = 1205,
  Character_length = 1206,
  Concat = 1207,
  Concat_ws = 1208,
  Elt = 1209,
  Export_set = 1210,
  Field = 1211,
  Find_in_set = 1212,
  Format = 1213,
  From_base64 = 1214,
  Hex = 1215,
  Insert = 1216,
  Instr = 1217,
  Lcase = 1218,
  Left = 1219,
  Length = 1220,
  Str_Like = 1221,
  Load_file = 1222,
  Locate = 1223,
  Lower = 1224,
  Lpad = 1225,
  Ltrim = 1226,
  Make_set = 1227,
  Match = 1228,
  Mid = 1229,
  Str_Not_like = 1230,
  Str_Not_regexp = 1231,
  Oct = 1232,
  Octet_length = 1233,
  Ord = 1234,
  Position = 1235,
  Quote = 1236,
  StrRegexp = 1237,
  Repeat = 1238,
  Replace = 1239,
  Reverse = 1240,
  Right = 1241,
  Rlike = 1242,
  Rpad = 1243,
  Rtrim = 1244,
  Soundex = 1245,
  SoundsLike = 1246,
  Space = 1247,
  Strcmp = 1248,
  Substr = 1249,
  Substring = 1250,
  SubstringIndex = 1251,
  ToBase64 = 1252,
  Trim = 1253,
  Ucase = 1254,
  Unhex = 1255,
  Upper = 1256,
  WeightString = 1257,
  Adddate = 2001,
  Addtime = 2002,
  Convert_tz = 2003,
  Curdate = 2004,
  CurrentDate = 2005,
  CurrentTime = 2006,
  CurrentTimestamp = 2007,
  Curtime = 2008,
  Date = 2009,
  Date_add = 2010,
  Date_format = 2011,
  Date_sub = 2012,
  Datediff = 2013,
  Day = 2014,
  Dayname = 2015,
  Dayofmonth = 2016,
  Dayofweek = 2017,
  Dayofyear = 2018,
  Extract = 2019,
  From_days = 2020,
  From_unixtime = 2021,
  Get_format = 2022,
  Hour = 2023,
  Last_day = 2024,
  Localtime = 2025,
  Localtimestamp = 2026,
  Makedate = 2027,
  Maketime = 2028,
  Microsecond = 2029,
  Minute = 2030,
  Month = 2031,
  Monthname = 2032,
  Now = 2033,
  Period_add = 2034,
  Period_diff = 2035,
  Quarter = 2036,
  Sec_to_time = 2037,
  Second = 2038,
  Str_to_date = 2039,
  Subdate = 2040,
  Subtime = 2041,
  Sysdate = 2042,
  Time = 2043,
  Time_format = 2044,
  Time_to_sec = 2045,
  Timediff = 2046,
  Timestamp = 2047,
  Timestampadd = 2048,
  Timestampdiff = 2049,
  To_days = 2050,
  To_seconds = 2051,
  Unix_timestamp = 2052,
  Utc_date = 2053,
  Utc_time = 2054,
  Utc_timestamp = 2055,
  Week = 2056,
  Weekday = 2057,
  Weekofyear = 2058,
  Year = 2059,
  Yearweek = 2060,
  ExprType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExprType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExprType_IsValid(int value);
const ExprType ExprType_MIN = Invalid_Expr;
const ExprType ExprType_MAX = Yearweek;
const int ExprType_ARRAYSIZE = ExprType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExprType_descriptor();
inline const ::std::string& ExprType_Name(ExprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExprType_descriptor(), value);
}
inline bool ExprType_Parse(
    const ::std::string& name, ExprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExprType>(
    ExprType_descriptor(), name, value);
}
// ===================================================================

class ColumnInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.ColumnInfo) */ {
 public:
  ColumnInfo();
  virtual ~ColumnInfo();

  ColumnInfo(const ColumnInfo& from);

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnInfo& default_instance();

  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ColumnInfo* other);
  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ColumnInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ColumnInfo& from);
  void MergeFrom(const ColumnInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ColumnInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .basepb.DataType typ = 2;
  void clear_typ();
  static const int kTypFieldNumber = 2;
  ::basepb::DataType typ() const;
  void set_typ(::basepb::DataType value);

  // bool unsigned = 3;
  void clear_unsigned_();
  static const int kUnsignedFieldNumber = 3;
  bool unsigned_() const;
  void set_unsigned_(bool value);

  // @@protoc_insertion_point(class_scope:dspb.ColumnInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 id_;
  int typ_;
  bool unsigned__;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fexpr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Expr* other);
  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const PROTOBUF_FINAL { return New(NULL); }

  Expr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Expr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.Expr child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  const ::dspb::Expr& child(int index) const;
  ::dspb::Expr* mutable_child(int index);
  ::dspb::Expr* add_child();
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
      child() const;

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .dspb.ColumnInfo column = 2;
  bool has_column() const;
  void clear_column();
  static const int kColumnFieldNumber = 2;
  const ::dspb::ColumnInfo& column() const;
  ::dspb::ColumnInfo* mutable_column();
  ::dspb::ColumnInfo* release_column();
  void set_allocated_column(::dspb::ColumnInfo* column);

  // .dspb.ExprType expr_type = 1;
  void clear_expr_type();
  static const int kExprTypeFieldNumber = 1;
  ::dspb::ExprType expr_type() const;
  void set_expr_type(::dspb::ExprType value);

  // @@protoc_insertion_point(class_scope:dspb.Expr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr > child_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::dspb::ColumnInfo* column_;
  int expr_type_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fexpr_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ColumnInfo

// uint32 id = 1;
inline void ColumnInfo::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 ColumnInfo::id() const {
  // @@protoc_insertion_point(field_get:dspb.ColumnInfo.id)
  return id_;
}
inline void ColumnInfo::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:dspb.ColumnInfo.id)
}

// .basepb.DataType typ = 2;
inline void ColumnInfo::clear_typ() {
  typ_ = 0;
}
inline ::basepb::DataType ColumnInfo::typ() const {
  // @@protoc_insertion_point(field_get:dspb.ColumnInfo.typ)
  return static_cast< ::basepb::DataType >(typ_);
}
inline void ColumnInfo::set_typ(::basepb::DataType value) {
  
  typ_ = value;
  // @@protoc_insertion_point(field_set:dspb.ColumnInfo.typ)
}

// bool unsigned = 3;
inline void ColumnInfo::clear_unsigned_() {
  unsigned__ = false;
}
inline bool ColumnInfo::unsigned_() const {
  // @@protoc_insertion_point(field_get:dspb.ColumnInfo.unsigned)
  return unsigned__;
}
inline void ColumnInfo::set_unsigned_(bool value) {
  
  unsigned__ = value;
  // @@protoc_insertion_point(field_set:dspb.ColumnInfo.unsigned)
}

// -------------------------------------------------------------------

// Expr

// .dspb.ExprType expr_type = 1;
inline void Expr::clear_expr_type() {
  expr_type_ = 0;
}
inline ::dspb::ExprType Expr::expr_type() const {
  // @@protoc_insertion_point(field_get:dspb.Expr.expr_type)
  return static_cast< ::dspb::ExprType >(expr_type_);
}
inline void Expr::set_expr_type(::dspb::ExprType value) {
  
  expr_type_ = value;
  // @@protoc_insertion_point(field_set:dspb.Expr.expr_type)
}

// .dspb.ColumnInfo column = 2;
inline bool Expr::has_column() const {
  return this != internal_default_instance() && column_ != NULL;
}
inline void Expr::clear_column() {
  if (GetArenaNoVirtual() == NULL && column_ != NULL) delete column_;
  column_ = NULL;
}
inline const ::dspb::ColumnInfo& Expr::column() const {
  const ::dspb::ColumnInfo* p = column_;
  // @@protoc_insertion_point(field_get:dspb.Expr.column)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::ColumnInfo*>(
      &::dspb::_ColumnInfo_default_instance_);
}
inline ::dspb::ColumnInfo* Expr::mutable_column() {
  
  if (column_ == NULL) {
    column_ = new ::dspb::ColumnInfo;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Expr.column)
  return column_;
}
inline ::dspb::ColumnInfo* Expr::release_column() {
  // @@protoc_insertion_point(field_release:dspb.Expr.column)
  
  ::dspb::ColumnInfo* temp = column_;
  column_ = NULL;
  return temp;
}
inline void Expr::set_allocated_column(::dspb::ColumnInfo* column) {
  delete column_;
  column_ = column;
  if (column) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Expr.column)
}

// bytes value = 3;
inline void Expr::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expr::value() const {
  // @@protoc_insertion_point(field_get:dspb.Expr.value)
  return value_.GetNoArena();
}
inline void Expr::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.Expr.value)
}
#if LANG_CXX11
inline void Expr::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.Expr.value)
}
#endif
inline void Expr::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.Expr.value)
}
inline void Expr::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.Expr.value)
}
inline ::std::string* Expr::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:dspb.Expr.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expr::release_value() {
  // @@protoc_insertion_point(field_release:dspb.Expr.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:dspb.Expr.value)
}

// repeated .dspb.Expr child = 4;
inline int Expr::child_size() const {
  return child_.size();
}
inline void Expr::clear_child() {
  child_.Clear();
}
inline const ::dspb::Expr& Expr::child(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Expr.child)
  return child_.Get(index);
}
inline ::dspb::Expr* Expr::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Expr.child)
  return child_.Mutable(index);
}
inline ::dspb::Expr* Expr::add_child() {
  // @@protoc_insertion_point(field_add:dspb.Expr.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
Expr::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Expr.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
Expr::child() const {
  // @@protoc_insertion_point(field_list:dspb.Expr.child)
  return child_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dspb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dspb::ExprType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dspb::ExprType>() {
  return ::dspb::ExprType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dspb_2fexpr_2eproto__INCLUDED
