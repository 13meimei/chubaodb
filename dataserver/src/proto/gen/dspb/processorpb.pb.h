// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dspb/processorpb.proto

#ifndef PROTOBUF_dspb_2fprocessorpb_2eproto__INCLUDED
#define PROTOBUF_dspb_2fprocessorpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dspb/expr.pb.h"
// @@protoc_insertion_point(includes)
namespace dspb {
class Aggregation;
class AggregationDefaultTypeInternal;
extern AggregationDefaultTypeInternal _Aggregation_default_instance_;
class DataSample;
class DataSampleDefaultTypeInternal;
extern DataSampleDefaultTypeInternal _DataSample_default_instance_;
class IndexRead;
class IndexReadDefaultTypeInternal;
extern IndexReadDefaultTypeInternal _IndexRead_default_instance_;
class KeyRange;
class KeyRangeDefaultTypeInternal;
extern KeyRangeDefaultTypeInternal _KeyRange_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class OrderByColumn;
class OrderByColumnDefaultTypeInternal;
extern OrderByColumnDefaultTypeInternal _OrderByColumn_default_instance_;
class Ordering;
class OrderingDefaultTypeInternal;
extern OrderingDefaultTypeInternal _Ordering_default_instance_;
class Processor;
class ProcessorDefaultTypeInternal;
extern ProcessorDefaultTypeInternal _Processor_default_instance_;
class ProcessorTrace;
class ProcessorTraceDefaultTypeInternal;
extern ProcessorTraceDefaultTypeInternal _ProcessorTrace_default_instance_;
class Projection;
class ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Selection;
class SelectionDefaultTypeInternal;
extern SelectionDefaultTypeInternal _Selection_default_instance_;
class TableRead;
class TableReadDefaultTypeInternal;
extern TableReadDefaultTypeInternal _TableRead_default_instance_;
}  // namespace dspb

namespace dspb {

namespace protobuf_dspb_2fprocessorpb_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dspb_2fprocessorpb_2eproto

enum DataSample_SampleMethod {
  DataSample_SampleMethod_RESERVIOR_SAMPLING = 0,
  DataSample_SampleMethod_DataSample_SampleMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataSample_SampleMethod_DataSample_SampleMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataSample_SampleMethod_IsValid(int value);
const DataSample_SampleMethod DataSample_SampleMethod_SampleMethod_MIN = DataSample_SampleMethod_RESERVIOR_SAMPLING;
const DataSample_SampleMethod DataSample_SampleMethod_SampleMethod_MAX = DataSample_SampleMethod_RESERVIOR_SAMPLING;
const int DataSample_SampleMethod_SampleMethod_ARRAYSIZE = DataSample_SampleMethod_SampleMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataSample_SampleMethod_descriptor();
inline const ::std::string& DataSample_SampleMethod_Name(DataSample_SampleMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataSample_SampleMethod_descriptor(), value);
}
inline bool DataSample_SampleMethod_Parse(
    const ::std::string& name, DataSample_SampleMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataSample_SampleMethod>(
    DataSample_SampleMethod_descriptor(), name, value);
}
enum ProcessorType {
  TABLE_READ_TYPE = 0,
  INDEX_READ_TYPE = 1,
  SELECTION_TYPE = 2,
  PROJECTION_TYPE = 3,
  AGGREGATION_TYPE = 4,
  STREAM_AGGREGATION_TYPE = 5,
  ORDER_BY_TYPE = 6,
  LIMIT_TYPE = 7,
  DATA_SAMPLE_TYPE = 8,
  ProcessorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProcessorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProcessorType_IsValid(int value);
const ProcessorType ProcessorType_MIN = TABLE_READ_TYPE;
const ProcessorType ProcessorType_MAX = DATA_SAMPLE_TYPE;
const int ProcessorType_ARRAYSIZE = ProcessorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessorType_descriptor();
inline const ::std::string& ProcessorType_Name(ProcessorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessorType_descriptor(), value);
}
inline bool ProcessorType_Parse(
    const ::std::string& name, ProcessorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessorType>(
    ProcessorType_descriptor(), name, value);
}
enum KeyType {
  DEFAULT_RANGE_TYPE = 0,
  PRIMARY_KEY_TYPE = 1,
  KEYS_RANGE_TYPE = 2,
  KeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KeyType_IsValid(int value);
const KeyType KeyType_MIN = DEFAULT_RANGE_TYPE;
const KeyType KeyType_MAX = KEYS_RANGE_TYPE;
const int KeyType_ARRAYSIZE = KeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyType_descriptor();
inline const ::std::string& KeyType_Name(KeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyType_descriptor(), value);
}
inline bool KeyType_Parse(
    const ::std::string& name, KeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyType>(
    KeyType_descriptor(), name, value);
}
// ===================================================================

class Processor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Processor) */ {
 public:
  Processor();
  virtual ~Processor();

  Processor(const Processor& from);

  inline Processor& operator=(const Processor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Processor(Processor&& from) noexcept
    : Processor() {
    *this = ::std::move(from);
  }

  inline Processor& operator=(Processor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Processor& default_instance();

  static inline const Processor* internal_default_instance() {
    return reinterpret_cast<const Processor*>(
               &_Processor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Processor* other);
  friend void swap(Processor& a, Processor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Processor* New() const PROTOBUF_FINAL { return New(NULL); }

  Processor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Processor& from);
  void MergeFrom(const Processor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Processor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .dspb.TableRead table_read = 2;
  bool has_table_read() const;
  void clear_table_read();
  static const int kTableReadFieldNumber = 2;
  const ::dspb::TableRead& table_read() const;
  ::dspb::TableRead* mutable_table_read();
  ::dspb::TableRead* release_table_read();
  void set_allocated_table_read(::dspb::TableRead* table_read);

  // .dspb.IndexRead index_read = 3;
  bool has_index_read() const;
  void clear_index_read();
  static const int kIndexReadFieldNumber = 3;
  const ::dspb::IndexRead& index_read() const;
  ::dspb::IndexRead* mutable_index_read();
  ::dspb::IndexRead* release_index_read();
  void set_allocated_index_read(::dspb::IndexRead* index_read);

  // .dspb.Selection selection = 4;
  bool has_selection() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 4;
  const ::dspb::Selection& selection() const;
  ::dspb::Selection* mutable_selection();
  ::dspb::Selection* release_selection();
  void set_allocated_selection(::dspb::Selection* selection);

  // .dspb.Projection projection = 5;
  bool has_projection() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 5;
  const ::dspb::Projection& projection() const;
  ::dspb::Projection* mutable_projection();
  ::dspb::Projection* release_projection();
  void set_allocated_projection(::dspb::Projection* projection);

  // .dspb.Aggregation aggregation = 6;
  bool has_aggregation() const;
  void clear_aggregation();
  static const int kAggregationFieldNumber = 6;
  const ::dspb::Aggregation& aggregation() const;
  ::dspb::Aggregation* mutable_aggregation();
  ::dspb::Aggregation* release_aggregation();
  void set_allocated_aggregation(::dspb::Aggregation* aggregation);

  // .dspb.Aggregation stream_aggregation = 7;
  bool has_stream_aggregation() const;
  void clear_stream_aggregation();
  static const int kStreamAggregationFieldNumber = 7;
  const ::dspb::Aggregation& stream_aggregation() const;
  ::dspb::Aggregation* mutable_stream_aggregation();
  ::dspb::Aggregation* release_stream_aggregation();
  void set_allocated_stream_aggregation(::dspb::Aggregation* stream_aggregation);

  // .dspb.Ordering ordering = 8;
  bool has_ordering() const;
  void clear_ordering();
  static const int kOrderingFieldNumber = 8;
  const ::dspb::Ordering& ordering() const;
  ::dspb::Ordering* mutable_ordering();
  ::dspb::Ordering* release_ordering();
  void set_allocated_ordering(::dspb::Ordering* ordering);

  // .dspb.Limit limit = 9;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 9;
  const ::dspb::Limit& limit() const;
  ::dspb::Limit* mutable_limit();
  ::dspb::Limit* release_limit();
  void set_allocated_limit(::dspb::Limit* limit);

  // .dspb.DataSample data_sample = 10;
  bool has_data_sample() const;
  void clear_data_sample();
  static const int kDataSampleFieldNumber = 10;
  const ::dspb::DataSample& data_sample() const;
  ::dspb::DataSample* mutable_data_sample();
  ::dspb::DataSample* release_data_sample();
  void set_allocated_data_sample(::dspb::DataSample* data_sample);

  // .dspb.ProcessorType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::dspb::ProcessorType type() const;
  void set_type(::dspb::ProcessorType value);

  // @@protoc_insertion_point(class_scope:dspb.Processor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::dspb::TableRead* table_read_;
  ::dspb::IndexRead* index_read_;
  ::dspb::Selection* selection_;
  ::dspb::Projection* projection_;
  ::dspb::Aggregation* aggregation_;
  ::dspb::Aggregation* stream_aggregation_;
  ::dspb::Ordering* ordering_;
  ::dspb::Limit* limit_;
  ::dspb::DataSample* data_sample_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableRead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.TableRead) */ {
 public:
  TableRead();
  virtual ~TableRead();

  TableRead(const TableRead& from);

  inline TableRead& operator=(const TableRead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableRead(TableRead&& from) noexcept
    : TableRead() {
    *this = ::std::move(from);
  }

  inline TableRead& operator=(TableRead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableRead& default_instance();

  static inline const TableRead* internal_default_instance() {
    return reinterpret_cast<const TableRead*>(
               &_TableRead_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TableRead* other);
  friend void swap(TableRead& a, TableRead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableRead* New() const PROTOBUF_FINAL { return New(NULL); }

  TableRead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TableRead& from);
  void MergeFrom(const TableRead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TableRead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.ColumnInfo columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  const ::dspb::ColumnInfo& columns(int index) const;
  ::dspb::ColumnInfo* mutable_columns(int index);
  ::dspb::ColumnInfo* add_columns();
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
      columns() const;

  // repeated bytes pk_keys = 4;
  int pk_keys_size() const;
  void clear_pk_keys();
  static const int kPkKeysFieldNumber = 4;
  const ::std::string& pk_keys(int index) const;
  ::std::string* mutable_pk_keys(int index);
  void set_pk_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pk_keys(int index, ::std::string&& value);
  #endif
  void set_pk_keys(int index, const char* value);
  void set_pk_keys(int index, const void* value, size_t size);
  ::std::string* add_pk_keys();
  void add_pk_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_pk_keys(::std::string&& value);
  #endif
  void add_pk_keys(const char* value);
  void add_pk_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pk_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pk_keys();

  // .dspb.KeyRange range = 3;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 3;
  const ::dspb::KeyRange& range() const;
  ::dspb::KeyRange* mutable_range();
  ::dspb::KeyRange* release_range();
  void set_allocated_range(::dspb::KeyRange* range);

  // .dspb.KeyType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::dspb::KeyType type() const;
  void set_type(::dspb::KeyType value);

  // bool desc = 5;
  void clear_desc();
  static const int kDescFieldNumber = 5;
  bool desc() const;
  void set_desc(bool value);

  // @@protoc_insertion_point(class_scope:dspb.TableRead)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo > columns_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pk_keys_;
  ::dspb::KeyRange* range_;
  int type_;
  bool desc_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.KeyRange) */ {
 public:
  KeyRange();
  virtual ~KeyRange();

  KeyRange(const KeyRange& from);

  inline KeyRange& operator=(const KeyRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyRange(KeyRange&& from) noexcept
    : KeyRange() {
    *this = ::std::move(from);
  }

  inline KeyRange& operator=(KeyRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyRange& default_instance();

  static inline const KeyRange* internal_default_instance() {
    return reinterpret_cast<const KeyRange*>(
               &_KeyRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(KeyRange* other);
  friend void swap(KeyRange& a, KeyRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyRange* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyRange& from);
  void MergeFrom(const KeyRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 1;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 1;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // bytes end_key = 2;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 2;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // @@protoc_insertion_point(class_scope:dspb.KeyRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexRead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.IndexRead) */ {
 public:
  IndexRead();
  virtual ~IndexRead();

  IndexRead(const IndexRead& from);

  inline IndexRead& operator=(const IndexRead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexRead(IndexRead&& from) noexcept
    : IndexRead() {
    *this = ::std::move(from);
  }

  inline IndexRead& operator=(IndexRead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexRead& default_instance();

  static inline const IndexRead* internal_default_instance() {
    return reinterpret_cast<const IndexRead*>(
               &_IndexRead_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(IndexRead* other);
  friend void swap(IndexRead& a, IndexRead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexRead* New() const PROTOBUF_FINAL { return New(NULL); }

  IndexRead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IndexRead& from);
  void MergeFrom(const IndexRead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IndexRead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.ColumnInfo columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  const ::dspb::ColumnInfo& columns(int index) const;
  ::dspb::ColumnInfo* mutable_columns(int index);
  ::dspb::ColumnInfo* add_columns();
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
      columns() const;

  // repeated bytes index_keys = 4;
  int index_keys_size() const;
  void clear_index_keys();
  static const int kIndexKeysFieldNumber = 4;
  const ::std::string& index_keys(int index) const;
  ::std::string* mutable_index_keys(int index);
  void set_index_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_index_keys(int index, ::std::string&& value);
  #endif
  void set_index_keys(int index, const char* value);
  void set_index_keys(int index, const void* value, size_t size);
  ::std::string* add_index_keys();
  void add_index_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_index_keys(::std::string&& value);
  #endif
  void add_index_keys(const char* value);
  void add_index_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& index_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_index_keys();

  // .dspb.KeyRange range = 3;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 3;
  const ::dspb::KeyRange& range() const;
  ::dspb::KeyRange* mutable_range();
  ::dspb::KeyRange* release_range();
  void set_allocated_range(::dspb::KeyRange* range);

  // .dspb.KeyType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::dspb::KeyType type() const;
  void set_type(::dspb::KeyType value);

  // bool desc = 5;
  void clear_desc();
  static const int kDescFieldNumber = 5;
  bool desc() const;
  void set_desc(bool value);

  // bool unique = 6;
  void clear_unique();
  static const int kUniqueFieldNumber = 6;
  bool unique() const;
  void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:dspb.IndexRead)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo > columns_;
  ::google::protobuf::RepeatedPtrField< ::std::string> index_keys_;
  ::dspb::KeyRange* range_;
  int type_;
  bool desc_;
  bool unique_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Selection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Selection) */ {
 public:
  Selection();
  virtual ~Selection();

  Selection(const Selection& from);

  inline Selection& operator=(const Selection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Selection(Selection&& from) noexcept
    : Selection() {
    *this = ::std::move(from);
  }

  inline Selection& operator=(Selection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Selection& default_instance();

  static inline const Selection* internal_default_instance() {
    return reinterpret_cast<const Selection*>(
               &_Selection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Selection* other);
  friend void swap(Selection& a, Selection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Selection* New() const PROTOBUF_FINAL { return New(NULL); }

  Selection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Selection& from);
  void MergeFrom(const Selection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Selection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.Expr filter = 1;
  int filter_size() const;
  void clear_filter();
  static const int kFilterFieldNumber = 1;
  const ::dspb::Expr& filter(int index) const;
  ::dspb::Expr* mutable_filter(int index);
  ::dspb::Expr* add_filter();
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
      mutable_filter();
  const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
      filter() const;

  // @@protoc_insertion_point(class_scope:dspb.Selection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr > filter_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Projection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Projection) */ {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Projection(Projection&& from) noexcept
    : Projection() {
    *this = ::std::move(from);
  }

  inline Projection& operator=(Projection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Projection& default_instance();

  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Projection* other);
  friend void swap(Projection& a, Projection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Projection* New() const PROTOBUF_FINAL { return New(NULL); }

  Projection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Projection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.Expr columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  const ::dspb::Expr& columns(int index) const;
  ::dspb::Expr* mutable_columns(int index);
  ::dspb::Expr* add_columns();
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
      columns() const;

  // @@protoc_insertion_point(class_scope:dspb.Projection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr > columns_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ordering : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Ordering) */ {
 public:
  Ordering();
  virtual ~Ordering();

  Ordering(const Ordering& from);

  inline Ordering& operator=(const Ordering& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ordering(Ordering&& from) noexcept
    : Ordering() {
    *this = ::std::move(from);
  }

  inline Ordering& operator=(Ordering&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ordering& default_instance();

  static inline const Ordering* internal_default_instance() {
    return reinterpret_cast<const Ordering*>(
               &_Ordering_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Ordering* other);
  friend void swap(Ordering& a, Ordering& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ordering* New() const PROTOBUF_FINAL { return New(NULL); }

  Ordering* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ordering& from);
  void MergeFrom(const Ordering& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ordering* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.OrderByColumn columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  const ::dspb::OrderByColumn& columns(int index) const;
  ::dspb::OrderByColumn* mutable_columns(int index);
  ::dspb::OrderByColumn* add_columns();
  ::google::protobuf::RepeatedPtrField< ::dspb::OrderByColumn >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::dspb::OrderByColumn >&
      columns() const;

  // uint64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Ordering)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::OrderByColumn > columns_;
  ::google::protobuf::uint64 count_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Aggregation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Aggregation) */ {
 public:
  Aggregation();
  virtual ~Aggregation();

  Aggregation(const Aggregation& from);

  inline Aggregation& operator=(const Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Aggregation(Aggregation&& from) noexcept
    : Aggregation() {
    *this = ::std::move(from);
  }

  inline Aggregation& operator=(Aggregation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Aggregation& default_instance();

  static inline const Aggregation* internal_default_instance() {
    return reinterpret_cast<const Aggregation*>(
               &_Aggregation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Aggregation* other);
  friend void swap(Aggregation& a, Aggregation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Aggregation* New() const PROTOBUF_FINAL { return New(NULL); }

  Aggregation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Aggregation& from);
  void MergeFrom(const Aggregation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Aggregation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dspb.Expr func = 1;
  int func_size() const;
  void clear_func();
  static const int kFuncFieldNumber = 1;
  const ::dspb::Expr& func(int index) const;
  ::dspb::Expr* mutable_func(int index);
  ::dspb::Expr* add_func();
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
      mutable_func();
  const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
      func() const;

  // repeated .dspb.Expr group_by = 2;
  int group_by_size() const;
  void clear_group_by();
  static const int kGroupByFieldNumber = 2;
  const ::dspb::Expr& group_by(int index) const;
  ::dspb::Expr* mutable_group_by(int index);
  ::dspb::Expr* add_group_by();
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
      mutable_group_by();
  const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
      group_by() const;

  // @@protoc_insertion_point(class_scope:dspb.Aggregation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr > func_;
  ::google::protobuf::RepeatedPtrField< ::dspb::Expr > group_by_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const PROTOBUF_FINAL { return New(NULL); }

  Limit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // uint64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.Limit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 count_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.DataSample) */ {
 public:
  DataSample();
  virtual ~DataSample();

  DataSample(const DataSample& from);

  inline DataSample& operator=(const DataSample& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataSample(DataSample&& from) noexcept
    : DataSample() {
    *this = ::std::move(from);
  }

  inline DataSample& operator=(DataSample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSample& default_instance();

  static inline const DataSample* internal_default_instance() {
    return reinterpret_cast<const DataSample*>(
               &_DataSample_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(DataSample* other);
  friend void swap(DataSample& a, DataSample& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataSample* New() const PROTOBUF_FINAL { return New(NULL); }

  DataSample* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataSample& from);
  void MergeFrom(const DataSample& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DataSample_SampleMethod SampleMethod;
  static const SampleMethod RESERVIOR_SAMPLING =
    DataSample_SampleMethod_RESERVIOR_SAMPLING;
  static inline bool SampleMethod_IsValid(int value) {
    return DataSample_SampleMethod_IsValid(value);
  }
  static const SampleMethod SampleMethod_MIN =
    DataSample_SampleMethod_SampleMethod_MIN;
  static const SampleMethod SampleMethod_MAX =
    DataSample_SampleMethod_SampleMethod_MAX;
  static const int SampleMethod_ARRAYSIZE =
    DataSample_SampleMethod_SampleMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SampleMethod_descriptor() {
    return DataSample_SampleMethod_descriptor();
  }
  static inline const ::std::string& SampleMethod_Name(SampleMethod value) {
    return DataSample_SampleMethod_Name(value);
  }
  static inline bool SampleMethod_Parse(const ::std::string& name,
      SampleMethod* value) {
    return DataSample_SampleMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .dspb.ColumnInfo columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::dspb::ColumnInfo& columns(int index) const;
  ::dspb::ColumnInfo* mutable_columns(int index);
  ::dspb::ColumnInfo* add_columns();
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
      columns() const;

  // .dspb.KeyRange range = 3;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 3;
  const ::dspb::KeyRange& range() const;
  ::dspb::KeyRange* mutable_range();
  ::dspb::KeyRange* release_range();
  void set_allocated_range(::dspb::KeyRange* range);

  // double ratio = 4;
  void clear_ratio();
  static const int kRatioFieldNumber = 4;
  double ratio() const;
  void set_ratio(double value);

  // .dspb.DataSample.SampleMethod method = 1;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  ::dspb::DataSample_SampleMethod method() const;
  void set_method(::dspb::DataSample_SampleMethod value);

  // @@protoc_insertion_point(class_scope:dspb.DataSample)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo > columns_;
  ::dspb::KeyRange* range_;
  double ratio_;
  int method_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderByColumn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.OrderByColumn) */ {
 public:
  OrderByColumn();
  virtual ~OrderByColumn();

  OrderByColumn(const OrderByColumn& from);

  inline OrderByColumn& operator=(const OrderByColumn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderByColumn(OrderByColumn&& from) noexcept
    : OrderByColumn() {
    *this = ::std::move(from);
  }

  inline OrderByColumn& operator=(OrderByColumn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderByColumn& default_instance();

  static inline const OrderByColumn* internal_default_instance() {
    return reinterpret_cast<const OrderByColumn*>(
               &_OrderByColumn_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(OrderByColumn* other);
  friend void swap(OrderByColumn& a, OrderByColumn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderByColumn* New() const PROTOBUF_FINAL { return New(NULL); }

  OrderByColumn* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OrderByColumn& from);
  void MergeFrom(const OrderByColumn& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OrderByColumn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .dspb.Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::dspb::Expr& expr() const;
  ::dspb::Expr* mutable_expr();
  ::dspb::Expr* release_expr();
  void set_allocated_expr(::dspb::Expr* expr);

  // bool asc = 2;
  void clear_asc();
  static const int kAscFieldNumber = 2;
  bool asc() const;
  void set_asc(bool value);

  // @@protoc_insertion_point(class_scope:dspb.OrderByColumn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::dspb::Expr* expr_;
  bool asc_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessorTrace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.ProcessorTrace) */ {
 public:
  ProcessorTrace();
  virtual ~ProcessorTrace();

  ProcessorTrace(const ProcessorTrace& from);

  inline ProcessorTrace& operator=(const ProcessorTrace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessorTrace(ProcessorTrace&& from) noexcept
    : ProcessorTrace() {
    *this = ::std::move(from);
  }

  inline ProcessorTrace& operator=(ProcessorTrace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorTrace& default_instance();

  static inline const ProcessorTrace* internal_default_instance() {
    return reinterpret_cast<const ProcessorTrace*>(
               &_ProcessorTrace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ProcessorTrace* other);
  friend void swap(ProcessorTrace& a, ProcessorTrace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessorTrace* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessorTrace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessorTrace& from);
  void MergeFrom(const ProcessorTrace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessorTrace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 processed_rows = 1;
  void clear_processed_rows();
  static const int kProcessedRowsFieldNumber = 1;
  ::google::protobuf::uint64 processed_rows() const;
  void set_processed_rows(::google::protobuf::uint64 value);

  // uint64 elapse_time = 2;
  void clear_elapse_time();
  static const int kElapseTimeFieldNumber = 2;
  ::google::protobuf::uint64 elapse_time() const;
  void set_elapse_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.ProcessorTrace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 processed_rows_;
  ::google::protobuf::uint64 elapse_time_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fprocessorpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Processor

// .dspb.ProcessorType type = 1;
inline void Processor::clear_type() {
  type_ = 0;
}
inline ::dspb::ProcessorType Processor::type() const {
  // @@protoc_insertion_point(field_get:dspb.Processor.type)
  return static_cast< ::dspb::ProcessorType >(type_);
}
inline void Processor::set_type(::dspb::ProcessorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dspb.Processor.type)
}

// .dspb.TableRead table_read = 2;
inline bool Processor::has_table_read() const {
  return this != internal_default_instance() && table_read_ != NULL;
}
inline void Processor::clear_table_read() {
  if (GetArenaNoVirtual() == NULL && table_read_ != NULL) delete table_read_;
  table_read_ = NULL;
}
inline const ::dspb::TableRead& Processor::table_read() const {
  const ::dspb::TableRead* p = table_read_;
  // @@protoc_insertion_point(field_get:dspb.Processor.table_read)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::TableRead*>(
      &::dspb::_TableRead_default_instance_);
}
inline ::dspb::TableRead* Processor::mutable_table_read() {
  
  if (table_read_ == NULL) {
    table_read_ = new ::dspb::TableRead;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.table_read)
  return table_read_;
}
inline ::dspb::TableRead* Processor::release_table_read() {
  // @@protoc_insertion_point(field_release:dspb.Processor.table_read)
  
  ::dspb::TableRead* temp = table_read_;
  table_read_ = NULL;
  return temp;
}
inline void Processor::set_allocated_table_read(::dspb::TableRead* table_read) {
  delete table_read_;
  table_read_ = table_read;
  if (table_read) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.table_read)
}

// .dspb.IndexRead index_read = 3;
inline bool Processor::has_index_read() const {
  return this != internal_default_instance() && index_read_ != NULL;
}
inline void Processor::clear_index_read() {
  if (GetArenaNoVirtual() == NULL && index_read_ != NULL) delete index_read_;
  index_read_ = NULL;
}
inline const ::dspb::IndexRead& Processor::index_read() const {
  const ::dspb::IndexRead* p = index_read_;
  // @@protoc_insertion_point(field_get:dspb.Processor.index_read)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::IndexRead*>(
      &::dspb::_IndexRead_default_instance_);
}
inline ::dspb::IndexRead* Processor::mutable_index_read() {
  
  if (index_read_ == NULL) {
    index_read_ = new ::dspb::IndexRead;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.index_read)
  return index_read_;
}
inline ::dspb::IndexRead* Processor::release_index_read() {
  // @@protoc_insertion_point(field_release:dspb.Processor.index_read)
  
  ::dspb::IndexRead* temp = index_read_;
  index_read_ = NULL;
  return temp;
}
inline void Processor::set_allocated_index_read(::dspb::IndexRead* index_read) {
  delete index_read_;
  index_read_ = index_read;
  if (index_read) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.index_read)
}

// .dspb.Selection selection = 4;
inline bool Processor::has_selection() const {
  return this != internal_default_instance() && selection_ != NULL;
}
inline void Processor::clear_selection() {
  if (GetArenaNoVirtual() == NULL && selection_ != NULL) delete selection_;
  selection_ = NULL;
}
inline const ::dspb::Selection& Processor::selection() const {
  const ::dspb::Selection* p = selection_;
  // @@protoc_insertion_point(field_get:dspb.Processor.selection)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Selection*>(
      &::dspb::_Selection_default_instance_);
}
inline ::dspb::Selection* Processor::mutable_selection() {
  
  if (selection_ == NULL) {
    selection_ = new ::dspb::Selection;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.selection)
  return selection_;
}
inline ::dspb::Selection* Processor::release_selection() {
  // @@protoc_insertion_point(field_release:dspb.Processor.selection)
  
  ::dspb::Selection* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void Processor::set_allocated_selection(::dspb::Selection* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.selection)
}

// .dspb.Projection projection = 5;
inline bool Processor::has_projection() const {
  return this != internal_default_instance() && projection_ != NULL;
}
inline void Processor::clear_projection() {
  if (GetArenaNoVirtual() == NULL && projection_ != NULL) delete projection_;
  projection_ = NULL;
}
inline const ::dspb::Projection& Processor::projection() const {
  const ::dspb::Projection* p = projection_;
  // @@protoc_insertion_point(field_get:dspb.Processor.projection)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Projection*>(
      &::dspb::_Projection_default_instance_);
}
inline ::dspb::Projection* Processor::mutable_projection() {
  
  if (projection_ == NULL) {
    projection_ = new ::dspb::Projection;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.projection)
  return projection_;
}
inline ::dspb::Projection* Processor::release_projection() {
  // @@protoc_insertion_point(field_release:dspb.Processor.projection)
  
  ::dspb::Projection* temp = projection_;
  projection_ = NULL;
  return temp;
}
inline void Processor::set_allocated_projection(::dspb::Projection* projection) {
  delete projection_;
  projection_ = projection;
  if (projection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.projection)
}

// .dspb.Aggregation aggregation = 6;
inline bool Processor::has_aggregation() const {
  return this != internal_default_instance() && aggregation_ != NULL;
}
inline void Processor::clear_aggregation() {
  if (GetArenaNoVirtual() == NULL && aggregation_ != NULL) delete aggregation_;
  aggregation_ = NULL;
}
inline const ::dspb::Aggregation& Processor::aggregation() const {
  const ::dspb::Aggregation* p = aggregation_;
  // @@protoc_insertion_point(field_get:dspb.Processor.aggregation)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Aggregation*>(
      &::dspb::_Aggregation_default_instance_);
}
inline ::dspb::Aggregation* Processor::mutable_aggregation() {
  
  if (aggregation_ == NULL) {
    aggregation_ = new ::dspb::Aggregation;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.aggregation)
  return aggregation_;
}
inline ::dspb::Aggregation* Processor::release_aggregation() {
  // @@protoc_insertion_point(field_release:dspb.Processor.aggregation)
  
  ::dspb::Aggregation* temp = aggregation_;
  aggregation_ = NULL;
  return temp;
}
inline void Processor::set_allocated_aggregation(::dspb::Aggregation* aggregation) {
  delete aggregation_;
  aggregation_ = aggregation;
  if (aggregation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.aggregation)
}

// .dspb.Aggregation stream_aggregation = 7;
inline bool Processor::has_stream_aggregation() const {
  return this != internal_default_instance() && stream_aggregation_ != NULL;
}
inline void Processor::clear_stream_aggregation() {
  if (GetArenaNoVirtual() == NULL && stream_aggregation_ != NULL) delete stream_aggregation_;
  stream_aggregation_ = NULL;
}
inline const ::dspb::Aggregation& Processor::stream_aggregation() const {
  const ::dspb::Aggregation* p = stream_aggregation_;
  // @@protoc_insertion_point(field_get:dspb.Processor.stream_aggregation)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Aggregation*>(
      &::dspb::_Aggregation_default_instance_);
}
inline ::dspb::Aggregation* Processor::mutable_stream_aggregation() {
  
  if (stream_aggregation_ == NULL) {
    stream_aggregation_ = new ::dspb::Aggregation;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.stream_aggregation)
  return stream_aggregation_;
}
inline ::dspb::Aggregation* Processor::release_stream_aggregation() {
  // @@protoc_insertion_point(field_release:dspb.Processor.stream_aggregation)
  
  ::dspb::Aggregation* temp = stream_aggregation_;
  stream_aggregation_ = NULL;
  return temp;
}
inline void Processor::set_allocated_stream_aggregation(::dspb::Aggregation* stream_aggregation) {
  delete stream_aggregation_;
  stream_aggregation_ = stream_aggregation;
  if (stream_aggregation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.stream_aggregation)
}

// .dspb.Ordering ordering = 8;
inline bool Processor::has_ordering() const {
  return this != internal_default_instance() && ordering_ != NULL;
}
inline void Processor::clear_ordering() {
  if (GetArenaNoVirtual() == NULL && ordering_ != NULL) delete ordering_;
  ordering_ = NULL;
}
inline const ::dspb::Ordering& Processor::ordering() const {
  const ::dspb::Ordering* p = ordering_;
  // @@protoc_insertion_point(field_get:dspb.Processor.ordering)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Ordering*>(
      &::dspb::_Ordering_default_instance_);
}
inline ::dspb::Ordering* Processor::mutable_ordering() {
  
  if (ordering_ == NULL) {
    ordering_ = new ::dspb::Ordering;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.ordering)
  return ordering_;
}
inline ::dspb::Ordering* Processor::release_ordering() {
  // @@protoc_insertion_point(field_release:dspb.Processor.ordering)
  
  ::dspb::Ordering* temp = ordering_;
  ordering_ = NULL;
  return temp;
}
inline void Processor::set_allocated_ordering(::dspb::Ordering* ordering) {
  delete ordering_;
  ordering_ = ordering;
  if (ordering) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.ordering)
}

// .dspb.Limit limit = 9;
inline bool Processor::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void Processor::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) delete limit_;
  limit_ = NULL;
}
inline const ::dspb::Limit& Processor::limit() const {
  const ::dspb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:dspb.Processor.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Limit*>(
      &::dspb::_Limit_default_instance_);
}
inline ::dspb::Limit* Processor::mutable_limit() {
  
  if (limit_ == NULL) {
    limit_ = new ::dspb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.limit)
  return limit_;
}
inline ::dspb::Limit* Processor::release_limit() {
  // @@protoc_insertion_point(field_release:dspb.Processor.limit)
  
  ::dspb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline void Processor::set_allocated_limit(::dspb::Limit* limit) {
  delete limit_;
  limit_ = limit;
  if (limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.limit)
}

// .dspb.DataSample data_sample = 10;
inline bool Processor::has_data_sample() const {
  return this != internal_default_instance() && data_sample_ != NULL;
}
inline void Processor::clear_data_sample() {
  if (GetArenaNoVirtual() == NULL && data_sample_ != NULL) delete data_sample_;
  data_sample_ = NULL;
}
inline const ::dspb::DataSample& Processor::data_sample() const {
  const ::dspb::DataSample* p = data_sample_;
  // @@protoc_insertion_point(field_get:dspb.Processor.data_sample)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::DataSample*>(
      &::dspb::_DataSample_default_instance_);
}
inline ::dspb::DataSample* Processor::mutable_data_sample() {
  
  if (data_sample_ == NULL) {
    data_sample_ = new ::dspb::DataSample;
  }
  // @@protoc_insertion_point(field_mutable:dspb.Processor.data_sample)
  return data_sample_;
}
inline ::dspb::DataSample* Processor::release_data_sample() {
  // @@protoc_insertion_point(field_release:dspb.Processor.data_sample)
  
  ::dspb::DataSample* temp = data_sample_;
  data_sample_ = NULL;
  return temp;
}
inline void Processor::set_allocated_data_sample(::dspb::DataSample* data_sample) {
  delete data_sample_;
  data_sample_ = data_sample;
  if (data_sample) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.Processor.data_sample)
}

// -------------------------------------------------------------------

// TableRead

// repeated .dspb.ColumnInfo columns = 1;
inline int TableRead::columns_size() const {
  return columns_.size();
}
inline void TableRead::clear_columns() {
  columns_.Clear();
}
inline const ::dspb::ColumnInfo& TableRead::columns(int index) const {
  // @@protoc_insertion_point(field_get:dspb.TableRead.columns)
  return columns_.Get(index);
}
inline ::dspb::ColumnInfo* TableRead::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.TableRead.columns)
  return columns_.Mutable(index);
}
inline ::dspb::ColumnInfo* TableRead::add_columns() {
  // @@protoc_insertion_point(field_add:dspb.TableRead.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
TableRead::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dspb.TableRead.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
TableRead::columns() const {
  // @@protoc_insertion_point(field_list:dspb.TableRead.columns)
  return columns_;
}

// .dspb.KeyType type = 2;
inline void TableRead::clear_type() {
  type_ = 0;
}
inline ::dspb::KeyType TableRead::type() const {
  // @@protoc_insertion_point(field_get:dspb.TableRead.type)
  return static_cast< ::dspb::KeyType >(type_);
}
inline void TableRead::set_type(::dspb::KeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dspb.TableRead.type)
}

// .dspb.KeyRange range = 3;
inline bool TableRead::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void TableRead::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::dspb::KeyRange& TableRead::range() const {
  const ::dspb::KeyRange* p = range_;
  // @@protoc_insertion_point(field_get:dspb.TableRead.range)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::KeyRange*>(
      &::dspb::_KeyRange_default_instance_);
}
inline ::dspb::KeyRange* TableRead::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::dspb::KeyRange;
  }
  // @@protoc_insertion_point(field_mutable:dspb.TableRead.range)
  return range_;
}
inline ::dspb::KeyRange* TableRead::release_range() {
  // @@protoc_insertion_point(field_release:dspb.TableRead.range)
  
  ::dspb::KeyRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void TableRead::set_allocated_range(::dspb::KeyRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.TableRead.range)
}

// repeated bytes pk_keys = 4;
inline int TableRead::pk_keys_size() const {
  return pk_keys_.size();
}
inline void TableRead::clear_pk_keys() {
  pk_keys_.Clear();
}
inline const ::std::string& TableRead::pk_keys(int index) const {
  // @@protoc_insertion_point(field_get:dspb.TableRead.pk_keys)
  return pk_keys_.Get(index);
}
inline ::std::string* TableRead::mutable_pk_keys(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.TableRead.pk_keys)
  return pk_keys_.Mutable(index);
}
inline void TableRead::set_pk_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dspb.TableRead.pk_keys)
  pk_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TableRead::set_pk_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:dspb.TableRead.pk_keys)
  pk_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TableRead::set_pk_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pk_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dspb.TableRead.pk_keys)
}
inline void TableRead::set_pk_keys(int index, const void* value, size_t size) {
  pk_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dspb.TableRead.pk_keys)
}
inline ::std::string* TableRead::add_pk_keys() {
  // @@protoc_insertion_point(field_add_mutable:dspb.TableRead.pk_keys)
  return pk_keys_.Add();
}
inline void TableRead::add_pk_keys(const ::std::string& value) {
  pk_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dspb.TableRead.pk_keys)
}
#if LANG_CXX11
inline void TableRead::add_pk_keys(::std::string&& value) {
  pk_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dspb.TableRead.pk_keys)
}
#endif
inline void TableRead::add_pk_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pk_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dspb.TableRead.pk_keys)
}
inline void TableRead::add_pk_keys(const void* value, size_t size) {
  pk_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dspb.TableRead.pk_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TableRead::pk_keys() const {
  // @@protoc_insertion_point(field_list:dspb.TableRead.pk_keys)
  return pk_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TableRead::mutable_pk_keys() {
  // @@protoc_insertion_point(field_mutable_list:dspb.TableRead.pk_keys)
  return &pk_keys_;
}

// bool desc = 5;
inline void TableRead::clear_desc() {
  desc_ = false;
}
inline bool TableRead::desc() const {
  // @@protoc_insertion_point(field_get:dspb.TableRead.desc)
  return desc_;
}
inline void TableRead::set_desc(bool value) {
  
  desc_ = value;
  // @@protoc_insertion_point(field_set:dspb.TableRead.desc)
}

// -------------------------------------------------------------------

// KeyRange

// bytes start_key = 1;
inline void KeyRange::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRange::start_key() const {
  // @@protoc_insertion_point(field_get:dspb.KeyRange.start_key)
  return start_key_.GetNoArena();
}
inline void KeyRange::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.KeyRange.start_key)
}
#if LANG_CXX11
inline void KeyRange::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.KeyRange.start_key)
}
#endif
inline void KeyRange::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.KeyRange.start_key)
}
inline void KeyRange::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.KeyRange.start_key)
}
inline ::std::string* KeyRange::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:dspb.KeyRange.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRange::release_start_key() {
  // @@protoc_insertion_point(field_release:dspb.KeyRange.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRange::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:dspb.KeyRange.start_key)
}

// bytes end_key = 2;
inline void KeyRange::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRange::end_key() const {
  // @@protoc_insertion_point(field_get:dspb.KeyRange.end_key)
  return end_key_.GetNoArena();
}
inline void KeyRange::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dspb.KeyRange.end_key)
}
#if LANG_CXX11
inline void KeyRange::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dspb.KeyRange.end_key)
}
#endif
inline void KeyRange::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dspb.KeyRange.end_key)
}
inline void KeyRange::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dspb.KeyRange.end_key)
}
inline ::std::string* KeyRange::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:dspb.KeyRange.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRange::release_end_key() {
  // @@protoc_insertion_point(field_release:dspb.KeyRange.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRange::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:dspb.KeyRange.end_key)
}

// -------------------------------------------------------------------

// IndexRead

// repeated .dspb.ColumnInfo columns = 1;
inline int IndexRead::columns_size() const {
  return columns_.size();
}
inline void IndexRead::clear_columns() {
  columns_.Clear();
}
inline const ::dspb::ColumnInfo& IndexRead::columns(int index) const {
  // @@protoc_insertion_point(field_get:dspb.IndexRead.columns)
  return columns_.Get(index);
}
inline ::dspb::ColumnInfo* IndexRead::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.IndexRead.columns)
  return columns_.Mutable(index);
}
inline ::dspb::ColumnInfo* IndexRead::add_columns() {
  // @@protoc_insertion_point(field_add:dspb.IndexRead.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
IndexRead::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dspb.IndexRead.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
IndexRead::columns() const {
  // @@protoc_insertion_point(field_list:dspb.IndexRead.columns)
  return columns_;
}

// .dspb.KeyType type = 2;
inline void IndexRead::clear_type() {
  type_ = 0;
}
inline ::dspb::KeyType IndexRead::type() const {
  // @@protoc_insertion_point(field_get:dspb.IndexRead.type)
  return static_cast< ::dspb::KeyType >(type_);
}
inline void IndexRead::set_type(::dspb::KeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:dspb.IndexRead.type)
}

// .dspb.KeyRange range = 3;
inline bool IndexRead::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void IndexRead::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::dspb::KeyRange& IndexRead::range() const {
  const ::dspb::KeyRange* p = range_;
  // @@protoc_insertion_point(field_get:dspb.IndexRead.range)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::KeyRange*>(
      &::dspb::_KeyRange_default_instance_);
}
inline ::dspb::KeyRange* IndexRead::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::dspb::KeyRange;
  }
  // @@protoc_insertion_point(field_mutable:dspb.IndexRead.range)
  return range_;
}
inline ::dspb::KeyRange* IndexRead::release_range() {
  // @@protoc_insertion_point(field_release:dspb.IndexRead.range)
  
  ::dspb::KeyRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void IndexRead::set_allocated_range(::dspb::KeyRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.IndexRead.range)
}

// repeated bytes index_keys = 4;
inline int IndexRead::index_keys_size() const {
  return index_keys_.size();
}
inline void IndexRead::clear_index_keys() {
  index_keys_.Clear();
}
inline const ::std::string& IndexRead::index_keys(int index) const {
  // @@protoc_insertion_point(field_get:dspb.IndexRead.index_keys)
  return index_keys_.Get(index);
}
inline ::std::string* IndexRead::mutable_index_keys(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.IndexRead.index_keys)
  return index_keys_.Mutable(index);
}
inline void IndexRead::set_index_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dspb.IndexRead.index_keys)
  index_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IndexRead::set_index_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:dspb.IndexRead.index_keys)
  index_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IndexRead::set_index_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  index_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dspb.IndexRead.index_keys)
}
inline void IndexRead::set_index_keys(int index, const void* value, size_t size) {
  index_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dspb.IndexRead.index_keys)
}
inline ::std::string* IndexRead::add_index_keys() {
  // @@protoc_insertion_point(field_add_mutable:dspb.IndexRead.index_keys)
  return index_keys_.Add();
}
inline void IndexRead::add_index_keys(const ::std::string& value) {
  index_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dspb.IndexRead.index_keys)
}
#if LANG_CXX11
inline void IndexRead::add_index_keys(::std::string&& value) {
  index_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dspb.IndexRead.index_keys)
}
#endif
inline void IndexRead::add_index_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  index_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dspb.IndexRead.index_keys)
}
inline void IndexRead::add_index_keys(const void* value, size_t size) {
  index_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dspb.IndexRead.index_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexRead::index_keys() const {
  // @@protoc_insertion_point(field_list:dspb.IndexRead.index_keys)
  return index_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexRead::mutable_index_keys() {
  // @@protoc_insertion_point(field_mutable_list:dspb.IndexRead.index_keys)
  return &index_keys_;
}

// bool desc = 5;
inline void IndexRead::clear_desc() {
  desc_ = false;
}
inline bool IndexRead::desc() const {
  // @@protoc_insertion_point(field_get:dspb.IndexRead.desc)
  return desc_;
}
inline void IndexRead::set_desc(bool value) {
  
  desc_ = value;
  // @@protoc_insertion_point(field_set:dspb.IndexRead.desc)
}

// bool unique = 6;
inline void IndexRead::clear_unique() {
  unique_ = false;
}
inline bool IndexRead::unique() const {
  // @@protoc_insertion_point(field_get:dspb.IndexRead.unique)
  return unique_;
}
inline void IndexRead::set_unique(bool value) {
  
  unique_ = value;
  // @@protoc_insertion_point(field_set:dspb.IndexRead.unique)
}

// -------------------------------------------------------------------

// Selection

// repeated .dspb.Expr filter = 1;
inline int Selection::filter_size() const {
  return filter_.size();
}
inline void Selection::clear_filter() {
  filter_.Clear();
}
inline const ::dspb::Expr& Selection::filter(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Selection.filter)
  return filter_.Get(index);
}
inline ::dspb::Expr* Selection::mutable_filter(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Selection.filter)
  return filter_.Mutable(index);
}
inline ::dspb::Expr* Selection::add_filter() {
  // @@protoc_insertion_point(field_add:dspb.Selection.filter)
  return filter_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
Selection::mutable_filter() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Selection.filter)
  return &filter_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
Selection::filter() const {
  // @@protoc_insertion_point(field_list:dspb.Selection.filter)
  return filter_;
}

// -------------------------------------------------------------------

// Projection

// repeated .dspb.Expr columns = 1;
inline int Projection::columns_size() const {
  return columns_.size();
}
inline void Projection::clear_columns() {
  columns_.Clear();
}
inline const ::dspb::Expr& Projection::columns(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Projection.columns)
  return columns_.Get(index);
}
inline ::dspb::Expr* Projection::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Projection.columns)
  return columns_.Mutable(index);
}
inline ::dspb::Expr* Projection::add_columns() {
  // @@protoc_insertion_point(field_add:dspb.Projection.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
Projection::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Projection.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
Projection::columns() const {
  // @@protoc_insertion_point(field_list:dspb.Projection.columns)
  return columns_;
}

// -------------------------------------------------------------------

// Ordering

// repeated .dspb.OrderByColumn columns = 1;
inline int Ordering::columns_size() const {
  return columns_.size();
}
inline void Ordering::clear_columns() {
  columns_.Clear();
}
inline const ::dspb::OrderByColumn& Ordering::columns(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Ordering.columns)
  return columns_.Get(index);
}
inline ::dspb::OrderByColumn* Ordering::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Ordering.columns)
  return columns_.Mutable(index);
}
inline ::dspb::OrderByColumn* Ordering::add_columns() {
  // @@protoc_insertion_point(field_add:dspb.Ordering.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::OrderByColumn >*
Ordering::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Ordering.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::OrderByColumn >&
Ordering::columns() const {
  // @@protoc_insertion_point(field_list:dspb.Ordering.columns)
  return columns_;
}

// uint64 count = 2;
inline void Ordering::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Ordering::count() const {
  // @@protoc_insertion_point(field_get:dspb.Ordering.count)
  return count_;
}
inline void Ordering::set_count(::google::protobuf::uint64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:dspb.Ordering.count)
}

// -------------------------------------------------------------------

// Aggregation

// repeated .dspb.Expr func = 1;
inline int Aggregation::func_size() const {
  return func_.size();
}
inline void Aggregation::clear_func() {
  func_.Clear();
}
inline const ::dspb::Expr& Aggregation::func(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Aggregation.func)
  return func_.Get(index);
}
inline ::dspb::Expr* Aggregation::mutable_func(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Aggregation.func)
  return func_.Mutable(index);
}
inline ::dspb::Expr* Aggregation::add_func() {
  // @@protoc_insertion_point(field_add:dspb.Aggregation.func)
  return func_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
Aggregation::mutable_func() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Aggregation.func)
  return &func_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
Aggregation::func() const {
  // @@protoc_insertion_point(field_list:dspb.Aggregation.func)
  return func_;
}

// repeated .dspb.Expr group_by = 2;
inline int Aggregation::group_by_size() const {
  return group_by_.size();
}
inline void Aggregation::clear_group_by() {
  group_by_.Clear();
}
inline const ::dspb::Expr& Aggregation::group_by(int index) const {
  // @@protoc_insertion_point(field_get:dspb.Aggregation.group_by)
  return group_by_.Get(index);
}
inline ::dspb::Expr* Aggregation::mutable_group_by(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.Aggregation.group_by)
  return group_by_.Mutable(index);
}
inline ::dspb::Expr* Aggregation::add_group_by() {
  // @@protoc_insertion_point(field_add:dspb.Aggregation.group_by)
  return group_by_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::Expr >*
Aggregation::mutable_group_by() {
  // @@protoc_insertion_point(field_mutable_list:dspb.Aggregation.group_by)
  return &group_by_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::Expr >&
Aggregation::group_by() const {
  // @@protoc_insertion_point(field_list:dspb.Aggregation.group_by)
  return group_by_;
}

// -------------------------------------------------------------------

// Limit

// uint64 offset = 1;
inline void Limit::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::offset() const {
  // @@protoc_insertion_point(field_get:dspb.Limit.offset)
  return offset_;
}
inline void Limit::set_offset(::google::protobuf::uint64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:dspb.Limit.offset)
}

// uint64 count = 2;
inline void Limit::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Limit::count() const {
  // @@protoc_insertion_point(field_get:dspb.Limit.count)
  return count_;
}
inline void Limit::set_count(::google::protobuf::uint64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:dspb.Limit.count)
}

// -------------------------------------------------------------------

// DataSample

// .dspb.DataSample.SampleMethod method = 1;
inline void DataSample::clear_method() {
  method_ = 0;
}
inline ::dspb::DataSample_SampleMethod DataSample::method() const {
  // @@protoc_insertion_point(field_get:dspb.DataSample.method)
  return static_cast< ::dspb::DataSample_SampleMethod >(method_);
}
inline void DataSample::set_method(::dspb::DataSample_SampleMethod value) {
  
  method_ = value;
  // @@protoc_insertion_point(field_set:dspb.DataSample.method)
}

// repeated .dspb.ColumnInfo columns = 2;
inline int DataSample::columns_size() const {
  return columns_.size();
}
inline void DataSample::clear_columns() {
  columns_.Clear();
}
inline const ::dspb::ColumnInfo& DataSample::columns(int index) const {
  // @@protoc_insertion_point(field_get:dspb.DataSample.columns)
  return columns_.Get(index);
}
inline ::dspb::ColumnInfo* DataSample::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dspb.DataSample.columns)
  return columns_.Mutable(index);
}
inline ::dspb::ColumnInfo* DataSample::add_columns() {
  // @@protoc_insertion_point(field_add:dspb.DataSample.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >*
DataSample::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dspb.DataSample.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dspb::ColumnInfo >&
DataSample::columns() const {
  // @@protoc_insertion_point(field_list:dspb.DataSample.columns)
  return columns_;
}

// .dspb.KeyRange range = 3;
inline bool DataSample::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void DataSample::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) delete range_;
  range_ = NULL;
}
inline const ::dspb::KeyRange& DataSample::range() const {
  const ::dspb::KeyRange* p = range_;
  // @@protoc_insertion_point(field_get:dspb.DataSample.range)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::KeyRange*>(
      &::dspb::_KeyRange_default_instance_);
}
inline ::dspb::KeyRange* DataSample::mutable_range() {
  
  if (range_ == NULL) {
    range_ = new ::dspb::KeyRange;
  }
  // @@protoc_insertion_point(field_mutable:dspb.DataSample.range)
  return range_;
}
inline ::dspb::KeyRange* DataSample::release_range() {
  // @@protoc_insertion_point(field_release:dspb.DataSample.range)
  
  ::dspb::KeyRange* temp = range_;
  range_ = NULL;
  return temp;
}
inline void DataSample::set_allocated_range(::dspb::KeyRange* range) {
  delete range_;
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.DataSample.range)
}

// double ratio = 4;
inline void DataSample::clear_ratio() {
  ratio_ = 0;
}
inline double DataSample::ratio() const {
  // @@protoc_insertion_point(field_get:dspb.DataSample.ratio)
  return ratio_;
}
inline void DataSample::set_ratio(double value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:dspb.DataSample.ratio)
}

// -------------------------------------------------------------------

// OrderByColumn

// .dspb.Expr expr = 1;
inline bool OrderByColumn::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void OrderByColumn::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::dspb::Expr& OrderByColumn::expr() const {
  const ::dspb::Expr* p = expr_;
  // @@protoc_insertion_point(field_get:dspb.OrderByColumn.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Expr*>(
      &::dspb::_Expr_default_instance_);
}
inline ::dspb::Expr* OrderByColumn::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::dspb::Expr;
  }
  // @@protoc_insertion_point(field_mutable:dspb.OrderByColumn.expr)
  return expr_;
}
inline ::dspb::Expr* OrderByColumn::release_expr() {
  // @@protoc_insertion_point(field_release:dspb.OrderByColumn.expr)
  
  ::dspb::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void OrderByColumn::set_allocated_expr(::dspb::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.OrderByColumn.expr)
}

// bool asc = 2;
inline void OrderByColumn::clear_asc() {
  asc_ = false;
}
inline bool OrderByColumn::asc() const {
  // @@protoc_insertion_point(field_get:dspb.OrderByColumn.asc)
  return asc_;
}
inline void OrderByColumn::set_asc(bool value) {
  
  asc_ = value;
  // @@protoc_insertion_point(field_set:dspb.OrderByColumn.asc)
}

// -------------------------------------------------------------------

// ProcessorTrace

// uint64 processed_rows = 1;
inline void ProcessorTrace::clear_processed_rows() {
  processed_rows_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ProcessorTrace::processed_rows() const {
  // @@protoc_insertion_point(field_get:dspb.ProcessorTrace.processed_rows)
  return processed_rows_;
}
inline void ProcessorTrace::set_processed_rows(::google::protobuf::uint64 value) {
  
  processed_rows_ = value;
  // @@protoc_insertion_point(field_set:dspb.ProcessorTrace.processed_rows)
}

// uint64 elapse_time = 2;
inline void ProcessorTrace::clear_elapse_time() {
  elapse_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ProcessorTrace::elapse_time() const {
  // @@protoc_insertion_point(field_get:dspb.ProcessorTrace.elapse_time)
  return elapse_time_;
}
inline void ProcessorTrace::set_elapse_time(::google::protobuf::uint64 value) {
  
  elapse_time_ = value;
  // @@protoc_insertion_point(field_set:dspb.ProcessorTrace.elapse_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dspb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dspb::DataSample_SampleMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dspb::DataSample_SampleMethod>() {
  return ::dspb::DataSample_SampleMethod_descriptor();
}
template <> struct is_proto_enum< ::dspb::ProcessorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dspb::ProcessorType>() {
  return ::dspb::ProcessorType_descriptor();
}
template <> struct is_proto_enum< ::dspb::KeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dspb::KeyType>() {
  return ::dspb::KeyType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dspb_2fprocessorpb_2eproto__INCLUDED
