// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dspb/api.proto

#ifndef PROTOBUF_dspb_2fapi_2eproto__INCLUDED
#define PROTOBUF_dspb_2fapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "basepb/basepb.pb.h"
#include "dspb/error.pb.h"
#include "dspb/kv.pb.h"
#include "dspb/txn.pb.h"
// @@protoc_insertion_point(includes)
namespace dspb {
class RangeRequest;
class RangeRequestDefaultTypeInternal;
extern RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
class RangeRequest_Header;
class RangeRequest_HeaderDefaultTypeInternal;
extern RangeRequest_HeaderDefaultTypeInternal _RangeRequest_Header_default_instance_;
class RangeResponse;
class RangeResponseDefaultTypeInternal;
extern RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
class RangeResponse_Header;
class RangeResponse_HeaderDefaultTypeInternal;
extern RangeResponse_HeaderDefaultTypeInternal _RangeResponse_Header_default_instance_;
}  // namespace dspb

namespace dspb {

namespace protobuf_dspb_2fapi_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dspb_2fapi_2eproto

// ===================================================================

class RangeRequest_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.RangeRequest.Header) */ {
 public:
  RangeRequest_Header();
  virtual ~RangeRequest_Header();

  RangeRequest_Header(const RangeRequest_Header& from);

  inline RangeRequest_Header& operator=(const RangeRequest_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeRequest_Header(RangeRequest_Header&& from) noexcept
    : RangeRequest_Header() {
    *this = ::std::move(from);
  }

  inline RangeRequest_Header& operator=(RangeRequest_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeRequest_Header& default_instance();

  static inline const RangeRequest_Header* internal_default_instance() {
    return reinterpret_cast<const RangeRequest_Header*>(
               &_RangeRequest_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RangeRequest_Header* other);
  friend void swap(RangeRequest_Header& a, RangeRequest_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeRequest_Header* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeRequest_Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeRequest_Header& from);
  void MergeFrom(const RangeRequest_Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeRequest_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .basepb.RangeEpoch range_epoch = 4;
  bool has_range_epoch() const;
  void clear_range_epoch();
  static const int kRangeEpochFieldNumber = 4;
  const ::basepb::RangeEpoch& range_epoch() const;
  ::basepb::RangeEpoch* mutable_range_epoch();
  ::basepb::RangeEpoch* release_range_epoch();
  void set_allocated_range_epoch(::basepb::RangeEpoch* range_epoch);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 2;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 2;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // uint64 range_id = 3;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 3;
  ::google::protobuf::uint64 range_id() const;
  void set_range_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.RangeRequest.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::basepb::RangeEpoch* range_epoch_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 range_id_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.RangeRequest) */ {
 public:
  RangeRequest();
  virtual ~RangeRequest();

  RangeRequest(const RangeRequest& from);

  inline RangeRequest& operator=(const RangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeRequest(RangeRequest&& from) noexcept
    : RangeRequest() {
    *this = ::std::move(from);
  }

  inline RangeRequest& operator=(RangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeRequest& default_instance();

  enum ReqCase {
    kPrepare = 2,
    kDecide = 3,
    kClearUp = 4,
    kGetLockInfo = 5,
    kSelect = 6,
    kScan = 7,
    kKvGet = 20,
    kKvPut = 21,
    kKvDelete = 22,
    REQ_NOT_SET = 0,
  };

  static inline const RangeRequest* internal_default_instance() {
    return reinterpret_cast<const RangeRequest*>(
               &_RangeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RangeRequest* other);
  friend void swap(RangeRequest& a, RangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeRequest& from);
  void MergeFrom(const RangeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RangeRequest_Header Header;

  // accessors -------------------------------------------------------

  // .dspb.RangeRequest.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::dspb::RangeRequest_Header& header() const;
  ::dspb::RangeRequest_Header* mutable_header();
  ::dspb::RangeRequest_Header* release_header();
  void set_allocated_header(::dspb::RangeRequest_Header* header);

  // .dspb.PrepareRequest prepare = 2;
  bool has_prepare() const;
  void clear_prepare();
  static const int kPrepareFieldNumber = 2;
  const ::dspb::PrepareRequest& prepare() const;
  ::dspb::PrepareRequest* mutable_prepare();
  ::dspb::PrepareRequest* release_prepare();
  void set_allocated_prepare(::dspb::PrepareRequest* prepare);

  // .dspb.DecideRequest decide = 3;
  bool has_decide() const;
  void clear_decide();
  static const int kDecideFieldNumber = 3;
  const ::dspb::DecideRequest& decide() const;
  ::dspb::DecideRequest* mutable_decide();
  ::dspb::DecideRequest* release_decide();
  void set_allocated_decide(::dspb::DecideRequest* decide);

  // .dspb.ClearupRequest clear_up = 4;
  bool has_clear_up() const;
  void clear_clear_up();
  static const int kClearUpFieldNumber = 4;
  const ::dspb::ClearupRequest& clear_up() const;
  ::dspb::ClearupRequest* mutable_clear_up();
  ::dspb::ClearupRequest* release_clear_up();
  void set_allocated_clear_up(::dspb::ClearupRequest* clear_up);

  // .dspb.GetLockInfoRequest get_lock_info = 5;
  bool has_get_lock_info() const;
  void clear_get_lock_info();
  static const int kGetLockInfoFieldNumber = 5;
  const ::dspb::GetLockInfoRequest& get_lock_info() const;
  ::dspb::GetLockInfoRequest* mutable_get_lock_info();
  ::dspb::GetLockInfoRequest* release_get_lock_info();
  void set_allocated_get_lock_info(::dspb::GetLockInfoRequest* get_lock_info);

  // .dspb.SelectRequest select = 6;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 6;
  const ::dspb::SelectRequest& select() const;
  ::dspb::SelectRequest* mutable_select();
  ::dspb::SelectRequest* release_select();
  void set_allocated_select(::dspb::SelectRequest* select);

  // .dspb.ScanRequest scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  const ::dspb::ScanRequest& scan() const;
  ::dspb::ScanRequest* mutable_scan();
  ::dspb::ScanRequest* release_scan();
  void set_allocated_scan(::dspb::ScanRequest* scan);

  // .dspb.KvGetRequest kv_get = 20;
  bool has_kv_get() const;
  void clear_kv_get();
  static const int kKvGetFieldNumber = 20;
  const ::dspb::KvGetRequest& kv_get() const;
  ::dspb::KvGetRequest* mutable_kv_get();
  ::dspb::KvGetRequest* release_kv_get();
  void set_allocated_kv_get(::dspb::KvGetRequest* kv_get);

  // .dspb.KvPutRequest kv_put = 21;
  bool has_kv_put() const;
  void clear_kv_put();
  static const int kKvPutFieldNumber = 21;
  const ::dspb::KvPutRequest& kv_put() const;
  ::dspb::KvPutRequest* mutable_kv_put();
  ::dspb::KvPutRequest* release_kv_put();
  void set_allocated_kv_put(::dspb::KvPutRequest* kv_put);

  // .dspb.KvDeleteRequest kv_delete = 22;
  bool has_kv_delete() const;
  void clear_kv_delete();
  static const int kKvDeleteFieldNumber = 22;
  const ::dspb::KvDeleteRequest& kv_delete() const;
  ::dspb::KvDeleteRequest* mutable_kv_delete();
  ::dspb::KvDeleteRequest* release_kv_delete();
  void set_allocated_kv_delete(::dspb::KvDeleteRequest* kv_delete);

  ReqCase req_case() const;
  // @@protoc_insertion_point(class_scope:dspb.RangeRequest)
 private:
  void set_has_prepare();
  void set_has_decide();
  void set_has_clear_up();
  void set_has_get_lock_info();
  void set_has_select();
  void set_has_scan();
  void set_has_kv_get();
  void set_has_kv_put();
  void set_has_kv_delete();

  inline bool has_req() const;
  void clear_req();
  inline void clear_has_req();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::dspb::RangeRequest_Header* header_;
  union ReqUnion {
    ReqUnion() {}
    ::dspb::PrepareRequest* prepare_;
    ::dspb::DecideRequest* decide_;
    ::dspb::ClearupRequest* clear_up_;
    ::dspb::GetLockInfoRequest* get_lock_info_;
    ::dspb::SelectRequest* select_;
    ::dspb::ScanRequest* scan_;
    ::dspb::KvGetRequest* kv_get_;
    ::dspb::KvPutRequest* kv_put_;
    ::dspb::KvDeleteRequest* kv_delete_;
  } req_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_dspb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeResponse_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.RangeResponse.Header) */ {
 public:
  RangeResponse_Header();
  virtual ~RangeResponse_Header();

  RangeResponse_Header(const RangeResponse_Header& from);

  inline RangeResponse_Header& operator=(const RangeResponse_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeResponse_Header(RangeResponse_Header&& from) noexcept
    : RangeResponse_Header() {
    *this = ::std::move(from);
  }

  inline RangeResponse_Header& operator=(RangeResponse_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeResponse_Header& default_instance();

  static inline const RangeResponse_Header* internal_default_instance() {
    return reinterpret_cast<const RangeResponse_Header*>(
               &_RangeResponse_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RangeResponse_Header* other);
  friend void swap(RangeResponse_Header& a, RangeResponse_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeResponse_Header* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeResponse_Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeResponse_Header& from);
  void MergeFrom(const RangeResponse_Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeResponse_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .dspb.Error error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::dspb::Error& error() const;
  ::dspb::Error* mutable_error();
  ::dspb::Error* release_error();
  void set_allocated_error(::dspb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // uint64 trace_id = 2;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 2;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dspb.RangeResponse.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::dspb::Error* error_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint64 trace_id_;
  mutable int _cached_size_;
  friend struct protobuf_dspb_2fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dspb.RangeResponse) */ {
 public:
  RangeResponse();
  virtual ~RangeResponse();

  RangeResponse(const RangeResponse& from);

  inline RangeResponse& operator=(const RangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeResponse(RangeResponse&& from) noexcept
    : RangeResponse() {
    *this = ::std::move(from);
  }

  inline RangeResponse& operator=(RangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeResponse& default_instance();

  enum RespCase {
    kPrepare = 2,
    kDecide = 3,
    kClearUp = 4,
    kGetLockInfo = 5,
    kSelect = 6,
    kScan = 7,
    kKvGet = 20,
    kKvPut = 21,
    kKvDelete = 22,
    RESP_NOT_SET = 0,
  };

  static inline const RangeResponse* internal_default_instance() {
    return reinterpret_cast<const RangeResponse*>(
               &_RangeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RangeResponse* other);
  friend void swap(RangeResponse& a, RangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeResponse& from);
  void MergeFrom(const RangeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RangeResponse_Header Header;

  // accessors -------------------------------------------------------

  // .dspb.RangeResponse.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::dspb::RangeResponse_Header& header() const;
  ::dspb::RangeResponse_Header* mutable_header();
  ::dspb::RangeResponse_Header* release_header();
  void set_allocated_header(::dspb::RangeResponse_Header* header);

  // .dspb.PrepareResponse prepare = 2;
  bool has_prepare() const;
  void clear_prepare();
  static const int kPrepareFieldNumber = 2;
  const ::dspb::PrepareResponse& prepare() const;
  ::dspb::PrepareResponse* mutable_prepare();
  ::dspb::PrepareResponse* release_prepare();
  void set_allocated_prepare(::dspb::PrepareResponse* prepare);

  // .dspb.DecideResponse decide = 3;
  bool has_decide() const;
  void clear_decide();
  static const int kDecideFieldNumber = 3;
  const ::dspb::DecideResponse& decide() const;
  ::dspb::DecideResponse* mutable_decide();
  ::dspb::DecideResponse* release_decide();
  void set_allocated_decide(::dspb::DecideResponse* decide);

  // .dspb.ClearupResponse clear_up = 4;
  bool has_clear_up() const;
  void clear_clear_up();
  static const int kClearUpFieldNumber = 4;
  const ::dspb::ClearupResponse& clear_up() const;
  ::dspb::ClearupResponse* mutable_clear_up();
  ::dspb::ClearupResponse* release_clear_up();
  void set_allocated_clear_up(::dspb::ClearupResponse* clear_up);

  // .dspb.GetLockInfoResponse get_lock_info = 5;
  bool has_get_lock_info() const;
  void clear_get_lock_info();
  static const int kGetLockInfoFieldNumber = 5;
  const ::dspb::GetLockInfoResponse& get_lock_info() const;
  ::dspb::GetLockInfoResponse* mutable_get_lock_info();
  ::dspb::GetLockInfoResponse* release_get_lock_info();
  void set_allocated_get_lock_info(::dspb::GetLockInfoResponse* get_lock_info);

  // .dspb.SelectResponse select = 6;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 6;
  const ::dspb::SelectResponse& select() const;
  ::dspb::SelectResponse* mutable_select();
  ::dspb::SelectResponse* release_select();
  void set_allocated_select(::dspb::SelectResponse* select);

  // .dspb.ScanResponse scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  const ::dspb::ScanResponse& scan() const;
  ::dspb::ScanResponse* mutable_scan();
  ::dspb::ScanResponse* release_scan();
  void set_allocated_scan(::dspb::ScanResponse* scan);

  // .dspb.KvGetResponse kv_get = 20;
  bool has_kv_get() const;
  void clear_kv_get();
  static const int kKvGetFieldNumber = 20;
  const ::dspb::KvGetResponse& kv_get() const;
  ::dspb::KvGetResponse* mutable_kv_get();
  ::dspb::KvGetResponse* release_kv_get();
  void set_allocated_kv_get(::dspb::KvGetResponse* kv_get);

  // .dspb.KvPutResponse kv_put = 21;
  bool has_kv_put() const;
  void clear_kv_put();
  static const int kKvPutFieldNumber = 21;
  const ::dspb::KvPutResponse& kv_put() const;
  ::dspb::KvPutResponse* mutable_kv_put();
  ::dspb::KvPutResponse* release_kv_put();
  void set_allocated_kv_put(::dspb::KvPutResponse* kv_put);

  // .dspb.KvDeleteResponse kv_delete = 22;
  bool has_kv_delete() const;
  void clear_kv_delete();
  static const int kKvDeleteFieldNumber = 22;
  const ::dspb::KvDeleteResponse& kv_delete() const;
  ::dspb::KvDeleteResponse* mutable_kv_delete();
  ::dspb::KvDeleteResponse* release_kv_delete();
  void set_allocated_kv_delete(::dspb::KvDeleteResponse* kv_delete);

  RespCase resp_case() const;
  // @@protoc_insertion_point(class_scope:dspb.RangeResponse)
 private:
  void set_has_prepare();
  void set_has_decide();
  void set_has_clear_up();
  void set_has_get_lock_info();
  void set_has_select();
  void set_has_scan();
  void set_has_kv_get();
  void set_has_kv_put();
  void set_has_kv_delete();

  inline bool has_resp() const;
  void clear_resp();
  inline void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::dspb::RangeResponse_Header* header_;
  union RespUnion {
    RespUnion() {}
    ::dspb::PrepareResponse* prepare_;
    ::dspb::DecideResponse* decide_;
    ::dspb::ClearupResponse* clear_up_;
    ::dspb::GetLockInfoResponse* get_lock_info_;
    ::dspb::SelectResponse* select_;
    ::dspb::ScanResponse* scan_;
    ::dspb::KvGetResponse* kv_get_;
    ::dspb::KvPutResponse* kv_put_;
    ::dspb::KvDeleteResponse* kv_delete_;
  } resp_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_dspb_2fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RangeRequest_Header

// uint64 cluster_id = 1;
inline void RangeRequest_Header::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeRequest_Header::cluster_id() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.Header.cluster_id)
  return cluster_id_;
}
inline void RangeRequest_Header::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.RangeRequest.Header.cluster_id)
}

// uint64 trace_id = 2;
inline void RangeRequest_Header::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeRequest_Header::trace_id() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.Header.trace_id)
  return trace_id_;
}
inline void RangeRequest_Header::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.RangeRequest.Header.trace_id)
}

// uint64 range_id = 3;
inline void RangeRequest_Header::clear_range_id() {
  range_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeRequest_Header::range_id() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.Header.range_id)
  return range_id_;
}
inline void RangeRequest_Header::set_range_id(::google::protobuf::uint64 value) {
  
  range_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.RangeRequest.Header.range_id)
}

// .basepb.RangeEpoch range_epoch = 4;
inline bool RangeRequest_Header::has_range_epoch() const {
  return this != internal_default_instance() && range_epoch_ != NULL;
}
inline void RangeRequest_Header::clear_range_epoch() {
  if (GetArenaNoVirtual() == NULL && range_epoch_ != NULL) delete range_epoch_;
  range_epoch_ = NULL;
}
inline const ::basepb::RangeEpoch& RangeRequest_Header::range_epoch() const {
  const ::basepb::RangeEpoch* p = range_epoch_;
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.Header.range_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::basepb::RangeEpoch*>(
      &::basepb::_RangeEpoch_default_instance_);
}
inline ::basepb::RangeEpoch* RangeRequest_Header::mutable_range_epoch() {
  
  if (range_epoch_ == NULL) {
    range_epoch_ = new ::basepb::RangeEpoch;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.Header.range_epoch)
  return range_epoch_;
}
inline ::basepb::RangeEpoch* RangeRequest_Header::release_range_epoch() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.Header.range_epoch)
  
  ::basepb::RangeEpoch* temp = range_epoch_;
  range_epoch_ = NULL;
  return temp;
}
inline void RangeRequest_Header::set_allocated_range_epoch(::basepb::RangeEpoch* range_epoch) {
  delete range_epoch_;
  range_epoch_ = range_epoch;
  if (range_epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.Header.range_epoch)
}

// -------------------------------------------------------------------

// RangeRequest

// .dspb.RangeRequest.Header header = 1;
inline bool RangeRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::dspb::RangeRequest_Header& RangeRequest::header() const {
  const ::dspb::RangeRequest_Header* p = header_;
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::RangeRequest_Header*>(
      &::dspb::_RangeRequest_Header_default_instance_);
}
inline ::dspb::RangeRequest_Header* RangeRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::dspb::RangeRequest_Header;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.header)
  return header_;
}
inline ::dspb::RangeRequest_Header* RangeRequest::release_header() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.header)
  
  ::dspb::RangeRequest_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeRequest::set_allocated_header(::dspb::RangeRequest_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.header)
}

// .dspb.PrepareRequest prepare = 2;
inline bool RangeRequest::has_prepare() const {
  return req_case() == kPrepare;
}
inline void RangeRequest::set_has_prepare() {
  _oneof_case_[0] = kPrepare;
}
inline void RangeRequest::clear_prepare() {
  if (has_prepare()) {
    delete req_.prepare_;
    clear_has_req();
  }
}
inline  const ::dspb::PrepareRequest& RangeRequest::prepare() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.prepare)
  return has_prepare()
      ? *req_.prepare_
      : ::dspb::PrepareRequest::default_instance();
}
inline ::dspb::PrepareRequest* RangeRequest::mutable_prepare() {
  if (!has_prepare()) {
    clear_req();
    set_has_prepare();
    req_.prepare_ = new ::dspb::PrepareRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.prepare)
  return req_.prepare_;
}
inline ::dspb::PrepareRequest* RangeRequest::release_prepare() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.prepare)
  if (has_prepare()) {
    clear_has_req();
    ::dspb::PrepareRequest* temp = req_.prepare_;
    req_.prepare_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_prepare(::dspb::PrepareRequest* prepare) {
  clear_req();
  if (prepare) {
    set_has_prepare();
    req_.prepare_ = prepare;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.prepare)
}

// .dspb.DecideRequest decide = 3;
inline bool RangeRequest::has_decide() const {
  return req_case() == kDecide;
}
inline void RangeRequest::set_has_decide() {
  _oneof_case_[0] = kDecide;
}
inline void RangeRequest::clear_decide() {
  if (has_decide()) {
    delete req_.decide_;
    clear_has_req();
  }
}
inline  const ::dspb::DecideRequest& RangeRequest::decide() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.decide)
  return has_decide()
      ? *req_.decide_
      : ::dspb::DecideRequest::default_instance();
}
inline ::dspb::DecideRequest* RangeRequest::mutable_decide() {
  if (!has_decide()) {
    clear_req();
    set_has_decide();
    req_.decide_ = new ::dspb::DecideRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.decide)
  return req_.decide_;
}
inline ::dspb::DecideRequest* RangeRequest::release_decide() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.decide)
  if (has_decide()) {
    clear_has_req();
    ::dspb::DecideRequest* temp = req_.decide_;
    req_.decide_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_decide(::dspb::DecideRequest* decide) {
  clear_req();
  if (decide) {
    set_has_decide();
    req_.decide_ = decide;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.decide)
}

// .dspb.ClearupRequest clear_up = 4;
inline bool RangeRequest::has_clear_up() const {
  return req_case() == kClearUp;
}
inline void RangeRequest::set_has_clear_up() {
  _oneof_case_[0] = kClearUp;
}
inline void RangeRequest::clear_clear_up() {
  if (has_clear_up()) {
    delete req_.clear_up_;
    clear_has_req();
  }
}
inline  const ::dspb::ClearupRequest& RangeRequest::clear_up() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.clear_up)
  return has_clear_up()
      ? *req_.clear_up_
      : ::dspb::ClearupRequest::default_instance();
}
inline ::dspb::ClearupRequest* RangeRequest::mutable_clear_up() {
  if (!has_clear_up()) {
    clear_req();
    set_has_clear_up();
    req_.clear_up_ = new ::dspb::ClearupRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.clear_up)
  return req_.clear_up_;
}
inline ::dspb::ClearupRequest* RangeRequest::release_clear_up() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.clear_up)
  if (has_clear_up()) {
    clear_has_req();
    ::dspb::ClearupRequest* temp = req_.clear_up_;
    req_.clear_up_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_clear_up(::dspb::ClearupRequest* clear_up) {
  clear_req();
  if (clear_up) {
    set_has_clear_up();
    req_.clear_up_ = clear_up;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.clear_up)
}

// .dspb.GetLockInfoRequest get_lock_info = 5;
inline bool RangeRequest::has_get_lock_info() const {
  return req_case() == kGetLockInfo;
}
inline void RangeRequest::set_has_get_lock_info() {
  _oneof_case_[0] = kGetLockInfo;
}
inline void RangeRequest::clear_get_lock_info() {
  if (has_get_lock_info()) {
    delete req_.get_lock_info_;
    clear_has_req();
  }
}
inline  const ::dspb::GetLockInfoRequest& RangeRequest::get_lock_info() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.get_lock_info)
  return has_get_lock_info()
      ? *req_.get_lock_info_
      : ::dspb::GetLockInfoRequest::default_instance();
}
inline ::dspb::GetLockInfoRequest* RangeRequest::mutable_get_lock_info() {
  if (!has_get_lock_info()) {
    clear_req();
    set_has_get_lock_info();
    req_.get_lock_info_ = new ::dspb::GetLockInfoRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.get_lock_info)
  return req_.get_lock_info_;
}
inline ::dspb::GetLockInfoRequest* RangeRequest::release_get_lock_info() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.get_lock_info)
  if (has_get_lock_info()) {
    clear_has_req();
    ::dspb::GetLockInfoRequest* temp = req_.get_lock_info_;
    req_.get_lock_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_get_lock_info(::dspb::GetLockInfoRequest* get_lock_info) {
  clear_req();
  if (get_lock_info) {
    set_has_get_lock_info();
    req_.get_lock_info_ = get_lock_info;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.get_lock_info)
}

// .dspb.SelectRequest select = 6;
inline bool RangeRequest::has_select() const {
  return req_case() == kSelect;
}
inline void RangeRequest::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void RangeRequest::clear_select() {
  if (has_select()) {
    delete req_.select_;
    clear_has_req();
  }
}
inline  const ::dspb::SelectRequest& RangeRequest::select() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.select)
  return has_select()
      ? *req_.select_
      : ::dspb::SelectRequest::default_instance();
}
inline ::dspb::SelectRequest* RangeRequest::mutable_select() {
  if (!has_select()) {
    clear_req();
    set_has_select();
    req_.select_ = new ::dspb::SelectRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.select)
  return req_.select_;
}
inline ::dspb::SelectRequest* RangeRequest::release_select() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.select)
  if (has_select()) {
    clear_has_req();
    ::dspb::SelectRequest* temp = req_.select_;
    req_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_select(::dspb::SelectRequest* select) {
  clear_req();
  if (select) {
    set_has_select();
    req_.select_ = select;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.select)
}

// .dspb.ScanRequest scan = 7;
inline bool RangeRequest::has_scan() const {
  return req_case() == kScan;
}
inline void RangeRequest::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void RangeRequest::clear_scan() {
  if (has_scan()) {
    delete req_.scan_;
    clear_has_req();
  }
}
inline  const ::dspb::ScanRequest& RangeRequest::scan() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.scan)
  return has_scan()
      ? *req_.scan_
      : ::dspb::ScanRequest::default_instance();
}
inline ::dspb::ScanRequest* RangeRequest::mutable_scan() {
  if (!has_scan()) {
    clear_req();
    set_has_scan();
    req_.scan_ = new ::dspb::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.scan)
  return req_.scan_;
}
inline ::dspb::ScanRequest* RangeRequest::release_scan() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.scan)
  if (has_scan()) {
    clear_has_req();
    ::dspb::ScanRequest* temp = req_.scan_;
    req_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_scan(::dspb::ScanRequest* scan) {
  clear_req();
  if (scan) {
    set_has_scan();
    req_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.scan)
}

// .dspb.KvGetRequest kv_get = 20;
inline bool RangeRequest::has_kv_get() const {
  return req_case() == kKvGet;
}
inline void RangeRequest::set_has_kv_get() {
  _oneof_case_[0] = kKvGet;
}
inline void RangeRequest::clear_kv_get() {
  if (has_kv_get()) {
    delete req_.kv_get_;
    clear_has_req();
  }
}
inline  const ::dspb::KvGetRequest& RangeRequest::kv_get() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.kv_get)
  return has_kv_get()
      ? *req_.kv_get_
      : ::dspb::KvGetRequest::default_instance();
}
inline ::dspb::KvGetRequest* RangeRequest::mutable_kv_get() {
  if (!has_kv_get()) {
    clear_req();
    set_has_kv_get();
    req_.kv_get_ = new ::dspb::KvGetRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.kv_get)
  return req_.kv_get_;
}
inline ::dspb::KvGetRequest* RangeRequest::release_kv_get() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.kv_get)
  if (has_kv_get()) {
    clear_has_req();
    ::dspb::KvGetRequest* temp = req_.kv_get_;
    req_.kv_get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_kv_get(::dspb::KvGetRequest* kv_get) {
  clear_req();
  if (kv_get) {
    set_has_kv_get();
    req_.kv_get_ = kv_get;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.kv_get)
}

// .dspb.KvPutRequest kv_put = 21;
inline bool RangeRequest::has_kv_put() const {
  return req_case() == kKvPut;
}
inline void RangeRequest::set_has_kv_put() {
  _oneof_case_[0] = kKvPut;
}
inline void RangeRequest::clear_kv_put() {
  if (has_kv_put()) {
    delete req_.kv_put_;
    clear_has_req();
  }
}
inline  const ::dspb::KvPutRequest& RangeRequest::kv_put() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.kv_put)
  return has_kv_put()
      ? *req_.kv_put_
      : ::dspb::KvPutRequest::default_instance();
}
inline ::dspb::KvPutRequest* RangeRequest::mutable_kv_put() {
  if (!has_kv_put()) {
    clear_req();
    set_has_kv_put();
    req_.kv_put_ = new ::dspb::KvPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.kv_put)
  return req_.kv_put_;
}
inline ::dspb::KvPutRequest* RangeRequest::release_kv_put() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.kv_put)
  if (has_kv_put()) {
    clear_has_req();
    ::dspb::KvPutRequest* temp = req_.kv_put_;
    req_.kv_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_kv_put(::dspb::KvPutRequest* kv_put) {
  clear_req();
  if (kv_put) {
    set_has_kv_put();
    req_.kv_put_ = kv_put;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.kv_put)
}

// .dspb.KvDeleteRequest kv_delete = 22;
inline bool RangeRequest::has_kv_delete() const {
  return req_case() == kKvDelete;
}
inline void RangeRequest::set_has_kv_delete() {
  _oneof_case_[0] = kKvDelete;
}
inline void RangeRequest::clear_kv_delete() {
  if (has_kv_delete()) {
    delete req_.kv_delete_;
    clear_has_req();
  }
}
inline  const ::dspb::KvDeleteRequest& RangeRequest::kv_delete() const {
  // @@protoc_insertion_point(field_get:dspb.RangeRequest.kv_delete)
  return has_kv_delete()
      ? *req_.kv_delete_
      : ::dspb::KvDeleteRequest::default_instance();
}
inline ::dspb::KvDeleteRequest* RangeRequest::mutable_kv_delete() {
  if (!has_kv_delete()) {
    clear_req();
    set_has_kv_delete();
    req_.kv_delete_ = new ::dspb::KvDeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeRequest.kv_delete)
  return req_.kv_delete_;
}
inline ::dspb::KvDeleteRequest* RangeRequest::release_kv_delete() {
  // @@protoc_insertion_point(field_release:dspb.RangeRequest.kv_delete)
  if (has_kv_delete()) {
    clear_has_req();
    ::dspb::KvDeleteRequest* temp = req_.kv_delete_;
    req_.kv_delete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeRequest::set_allocated_kv_delete(::dspb::KvDeleteRequest* kv_delete) {
  clear_req();
  if (kv_delete) {
    set_has_kv_delete();
    req_.kv_delete_ = kv_delete;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeRequest.kv_delete)
}

inline bool RangeRequest::has_req() const {
  return req_case() != REQ_NOT_SET;
}
inline void RangeRequest::clear_has_req() {
  _oneof_case_[0] = REQ_NOT_SET;
}
inline RangeRequest::ReqCase RangeRequest::req_case() const {
  return RangeRequest::ReqCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RangeResponse_Header

// uint64 cluster_id = 1;
inline void RangeResponse_Header::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeResponse_Header::cluster_id() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.Header.cluster_id)
  return cluster_id_;
}
inline void RangeResponse_Header::set_cluster_id(::google::protobuf::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.RangeResponse.Header.cluster_id)
}

// uint64 trace_id = 2;
inline void RangeResponse_Header::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RangeResponse_Header::trace_id() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.Header.trace_id)
  return trace_id_;
}
inline void RangeResponse_Header::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:dspb.RangeResponse.Header.trace_id)
}

// .dspb.Error error = 3;
inline bool RangeResponse_Header::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void RangeResponse_Header::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::dspb::Error& RangeResponse_Header::error() const {
  const ::dspb::Error* p = error_;
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.Header.error)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::Error*>(
      &::dspb::_Error_default_instance_);
}
inline ::dspb::Error* RangeResponse_Header::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::dspb::Error;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.Header.error)
  return error_;
}
inline ::dspb::Error* RangeResponse_Header::release_error() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.Header.error)
  
  ::dspb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void RangeResponse_Header::set_allocated_error(::dspb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.Header.error)
}

// -------------------------------------------------------------------

// RangeResponse

// .dspb.RangeResponse.Header header = 1;
inline bool RangeResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RangeResponse::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::dspb::RangeResponse_Header& RangeResponse::header() const {
  const ::dspb::RangeResponse_Header* p = header_;
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::dspb::RangeResponse_Header*>(
      &::dspb::_RangeResponse_Header_default_instance_);
}
inline ::dspb::RangeResponse_Header* RangeResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::dspb::RangeResponse_Header;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.header)
  return header_;
}
inline ::dspb::RangeResponse_Header* RangeResponse::release_header() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.header)
  
  ::dspb::RangeResponse_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeResponse::set_allocated_header(::dspb::RangeResponse_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.header)
}

// .dspb.PrepareResponse prepare = 2;
inline bool RangeResponse::has_prepare() const {
  return resp_case() == kPrepare;
}
inline void RangeResponse::set_has_prepare() {
  _oneof_case_[0] = kPrepare;
}
inline void RangeResponse::clear_prepare() {
  if (has_prepare()) {
    delete resp_.prepare_;
    clear_has_resp();
  }
}
inline  const ::dspb::PrepareResponse& RangeResponse::prepare() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.prepare)
  return has_prepare()
      ? *resp_.prepare_
      : ::dspb::PrepareResponse::default_instance();
}
inline ::dspb::PrepareResponse* RangeResponse::mutable_prepare() {
  if (!has_prepare()) {
    clear_resp();
    set_has_prepare();
    resp_.prepare_ = new ::dspb::PrepareResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.prepare)
  return resp_.prepare_;
}
inline ::dspb::PrepareResponse* RangeResponse::release_prepare() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.prepare)
  if (has_prepare()) {
    clear_has_resp();
    ::dspb::PrepareResponse* temp = resp_.prepare_;
    resp_.prepare_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_prepare(::dspb::PrepareResponse* prepare) {
  clear_resp();
  if (prepare) {
    set_has_prepare();
    resp_.prepare_ = prepare;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.prepare)
}

// .dspb.DecideResponse decide = 3;
inline bool RangeResponse::has_decide() const {
  return resp_case() == kDecide;
}
inline void RangeResponse::set_has_decide() {
  _oneof_case_[0] = kDecide;
}
inline void RangeResponse::clear_decide() {
  if (has_decide()) {
    delete resp_.decide_;
    clear_has_resp();
  }
}
inline  const ::dspb::DecideResponse& RangeResponse::decide() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.decide)
  return has_decide()
      ? *resp_.decide_
      : ::dspb::DecideResponse::default_instance();
}
inline ::dspb::DecideResponse* RangeResponse::mutable_decide() {
  if (!has_decide()) {
    clear_resp();
    set_has_decide();
    resp_.decide_ = new ::dspb::DecideResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.decide)
  return resp_.decide_;
}
inline ::dspb::DecideResponse* RangeResponse::release_decide() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.decide)
  if (has_decide()) {
    clear_has_resp();
    ::dspb::DecideResponse* temp = resp_.decide_;
    resp_.decide_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_decide(::dspb::DecideResponse* decide) {
  clear_resp();
  if (decide) {
    set_has_decide();
    resp_.decide_ = decide;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.decide)
}

// .dspb.ClearupResponse clear_up = 4;
inline bool RangeResponse::has_clear_up() const {
  return resp_case() == kClearUp;
}
inline void RangeResponse::set_has_clear_up() {
  _oneof_case_[0] = kClearUp;
}
inline void RangeResponse::clear_clear_up() {
  if (has_clear_up()) {
    delete resp_.clear_up_;
    clear_has_resp();
  }
}
inline  const ::dspb::ClearupResponse& RangeResponse::clear_up() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.clear_up)
  return has_clear_up()
      ? *resp_.clear_up_
      : ::dspb::ClearupResponse::default_instance();
}
inline ::dspb::ClearupResponse* RangeResponse::mutable_clear_up() {
  if (!has_clear_up()) {
    clear_resp();
    set_has_clear_up();
    resp_.clear_up_ = new ::dspb::ClearupResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.clear_up)
  return resp_.clear_up_;
}
inline ::dspb::ClearupResponse* RangeResponse::release_clear_up() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.clear_up)
  if (has_clear_up()) {
    clear_has_resp();
    ::dspb::ClearupResponse* temp = resp_.clear_up_;
    resp_.clear_up_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_clear_up(::dspb::ClearupResponse* clear_up) {
  clear_resp();
  if (clear_up) {
    set_has_clear_up();
    resp_.clear_up_ = clear_up;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.clear_up)
}

// .dspb.GetLockInfoResponse get_lock_info = 5;
inline bool RangeResponse::has_get_lock_info() const {
  return resp_case() == kGetLockInfo;
}
inline void RangeResponse::set_has_get_lock_info() {
  _oneof_case_[0] = kGetLockInfo;
}
inline void RangeResponse::clear_get_lock_info() {
  if (has_get_lock_info()) {
    delete resp_.get_lock_info_;
    clear_has_resp();
  }
}
inline  const ::dspb::GetLockInfoResponse& RangeResponse::get_lock_info() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.get_lock_info)
  return has_get_lock_info()
      ? *resp_.get_lock_info_
      : ::dspb::GetLockInfoResponse::default_instance();
}
inline ::dspb::GetLockInfoResponse* RangeResponse::mutable_get_lock_info() {
  if (!has_get_lock_info()) {
    clear_resp();
    set_has_get_lock_info();
    resp_.get_lock_info_ = new ::dspb::GetLockInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.get_lock_info)
  return resp_.get_lock_info_;
}
inline ::dspb::GetLockInfoResponse* RangeResponse::release_get_lock_info() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.get_lock_info)
  if (has_get_lock_info()) {
    clear_has_resp();
    ::dspb::GetLockInfoResponse* temp = resp_.get_lock_info_;
    resp_.get_lock_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_get_lock_info(::dspb::GetLockInfoResponse* get_lock_info) {
  clear_resp();
  if (get_lock_info) {
    set_has_get_lock_info();
    resp_.get_lock_info_ = get_lock_info;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.get_lock_info)
}

// .dspb.SelectResponse select = 6;
inline bool RangeResponse::has_select() const {
  return resp_case() == kSelect;
}
inline void RangeResponse::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void RangeResponse::clear_select() {
  if (has_select()) {
    delete resp_.select_;
    clear_has_resp();
  }
}
inline  const ::dspb::SelectResponse& RangeResponse::select() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.select)
  return has_select()
      ? *resp_.select_
      : ::dspb::SelectResponse::default_instance();
}
inline ::dspb::SelectResponse* RangeResponse::mutable_select() {
  if (!has_select()) {
    clear_resp();
    set_has_select();
    resp_.select_ = new ::dspb::SelectResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.select)
  return resp_.select_;
}
inline ::dspb::SelectResponse* RangeResponse::release_select() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.select)
  if (has_select()) {
    clear_has_resp();
    ::dspb::SelectResponse* temp = resp_.select_;
    resp_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_select(::dspb::SelectResponse* select) {
  clear_resp();
  if (select) {
    set_has_select();
    resp_.select_ = select;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.select)
}

// .dspb.ScanResponse scan = 7;
inline bool RangeResponse::has_scan() const {
  return resp_case() == kScan;
}
inline void RangeResponse::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void RangeResponse::clear_scan() {
  if (has_scan()) {
    delete resp_.scan_;
    clear_has_resp();
  }
}
inline  const ::dspb::ScanResponse& RangeResponse::scan() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.scan)
  return has_scan()
      ? *resp_.scan_
      : ::dspb::ScanResponse::default_instance();
}
inline ::dspb::ScanResponse* RangeResponse::mutable_scan() {
  if (!has_scan()) {
    clear_resp();
    set_has_scan();
    resp_.scan_ = new ::dspb::ScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.scan)
  return resp_.scan_;
}
inline ::dspb::ScanResponse* RangeResponse::release_scan() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.scan)
  if (has_scan()) {
    clear_has_resp();
    ::dspb::ScanResponse* temp = resp_.scan_;
    resp_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_scan(::dspb::ScanResponse* scan) {
  clear_resp();
  if (scan) {
    set_has_scan();
    resp_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.scan)
}

// .dspb.KvGetResponse kv_get = 20;
inline bool RangeResponse::has_kv_get() const {
  return resp_case() == kKvGet;
}
inline void RangeResponse::set_has_kv_get() {
  _oneof_case_[0] = kKvGet;
}
inline void RangeResponse::clear_kv_get() {
  if (has_kv_get()) {
    delete resp_.kv_get_;
    clear_has_resp();
  }
}
inline  const ::dspb::KvGetResponse& RangeResponse::kv_get() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.kv_get)
  return has_kv_get()
      ? *resp_.kv_get_
      : ::dspb::KvGetResponse::default_instance();
}
inline ::dspb::KvGetResponse* RangeResponse::mutable_kv_get() {
  if (!has_kv_get()) {
    clear_resp();
    set_has_kv_get();
    resp_.kv_get_ = new ::dspb::KvGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.kv_get)
  return resp_.kv_get_;
}
inline ::dspb::KvGetResponse* RangeResponse::release_kv_get() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.kv_get)
  if (has_kv_get()) {
    clear_has_resp();
    ::dspb::KvGetResponse* temp = resp_.kv_get_;
    resp_.kv_get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_kv_get(::dspb::KvGetResponse* kv_get) {
  clear_resp();
  if (kv_get) {
    set_has_kv_get();
    resp_.kv_get_ = kv_get;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.kv_get)
}

// .dspb.KvPutResponse kv_put = 21;
inline bool RangeResponse::has_kv_put() const {
  return resp_case() == kKvPut;
}
inline void RangeResponse::set_has_kv_put() {
  _oneof_case_[0] = kKvPut;
}
inline void RangeResponse::clear_kv_put() {
  if (has_kv_put()) {
    delete resp_.kv_put_;
    clear_has_resp();
  }
}
inline  const ::dspb::KvPutResponse& RangeResponse::kv_put() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.kv_put)
  return has_kv_put()
      ? *resp_.kv_put_
      : ::dspb::KvPutResponse::default_instance();
}
inline ::dspb::KvPutResponse* RangeResponse::mutable_kv_put() {
  if (!has_kv_put()) {
    clear_resp();
    set_has_kv_put();
    resp_.kv_put_ = new ::dspb::KvPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.kv_put)
  return resp_.kv_put_;
}
inline ::dspb::KvPutResponse* RangeResponse::release_kv_put() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.kv_put)
  if (has_kv_put()) {
    clear_has_resp();
    ::dspb::KvPutResponse* temp = resp_.kv_put_;
    resp_.kv_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_kv_put(::dspb::KvPutResponse* kv_put) {
  clear_resp();
  if (kv_put) {
    set_has_kv_put();
    resp_.kv_put_ = kv_put;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.kv_put)
}

// .dspb.KvDeleteResponse kv_delete = 22;
inline bool RangeResponse::has_kv_delete() const {
  return resp_case() == kKvDelete;
}
inline void RangeResponse::set_has_kv_delete() {
  _oneof_case_[0] = kKvDelete;
}
inline void RangeResponse::clear_kv_delete() {
  if (has_kv_delete()) {
    delete resp_.kv_delete_;
    clear_has_resp();
  }
}
inline  const ::dspb::KvDeleteResponse& RangeResponse::kv_delete() const {
  // @@protoc_insertion_point(field_get:dspb.RangeResponse.kv_delete)
  return has_kv_delete()
      ? *resp_.kv_delete_
      : ::dspb::KvDeleteResponse::default_instance();
}
inline ::dspb::KvDeleteResponse* RangeResponse::mutable_kv_delete() {
  if (!has_kv_delete()) {
    clear_resp();
    set_has_kv_delete();
    resp_.kv_delete_ = new ::dspb::KvDeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:dspb.RangeResponse.kv_delete)
  return resp_.kv_delete_;
}
inline ::dspb::KvDeleteResponse* RangeResponse::release_kv_delete() {
  // @@protoc_insertion_point(field_release:dspb.RangeResponse.kv_delete)
  if (has_kv_delete()) {
    clear_has_resp();
    ::dspb::KvDeleteResponse* temp = resp_.kv_delete_;
    resp_.kv_delete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RangeResponse::set_allocated_kv_delete(::dspb::KvDeleteResponse* kv_delete) {
  clear_resp();
  if (kv_delete) {
    set_has_kv_delete();
    resp_.kv_delete_ = kv_delete;
  }
  // @@protoc_insertion_point(field_set_allocated:dspb.RangeResponse.kv_delete)
}

inline bool RangeResponse::has_resp() const {
  return resp_case() != RESP_NOT_SET;
}
inline void RangeResponse::clear_has_resp() {
  _oneof_case_[0] = RESP_NOT_SET;
}
inline RangeResponse::RespCase RangeResponse::resp_case() const {
  return RangeResponse::RespCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dspb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dspb_2fapi_2eproto__INCLUDED
